use serde::{Deserialize, Serialize};

/// A Rust funtion with its file source, attributes, and raw function content.
#[derive(Debug, Serialize, Deserialize)]
pub struct SerFunction {
    pub hash: String,
    /// DefId in stable_mir.
    pub def_id: String,
    /// Every funtion must be declared in a specific file, even for those
    /// generated by macros.
    pub file: String,
    /// Attributes are attached the function, but it seems that attributes
    /// and function must be separated to query.
    pub attrs: Vec<String>,
    /// Raw function string, including name, signature, and body.
    pub func: String,
    /// Recursive function calls inside the body.
    pub callees: Vec<Callee>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct Callee {
    pub def_id: String,
    pub file: String,
    pub func: String,
}

/// A local path to kani's artifacts.
///
/// Choose the following if found
/// * `$KANI_DIR`
/// * or `$KANI_HOME/kani-{version}`
/// * or `$HOME/.kani/kani-{version}`
pub fn kani_path() -> String {
    use std::env::var;
    let path = if let Ok(path) = var("KANI_DIR") {
        path
    } else {
        let kani = std::process::Command::new("kani").arg("--version").output().unwrap();
        let kani_folder = std::str::from_utf8(&kani.stdout).unwrap().trim().replace(' ', "-");
        let home = var("KANI_HOME").or_else(|_| var("HOME")).unwrap();
        format!("{home}/.kani/{kani_folder}")
    };
    assert!(std::fs::exists(&path).unwrap());
    path
}
