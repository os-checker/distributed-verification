use rustc_middle::ty::TyCtxt;
use rustc_span::source_map::SourceMap;
use rustc_stable_hash::{FromStableHash, SipHasher128Hash, StableHasher, hashers::SipHasher128};
use serde::Serialize;
use stable_mir::{CrateDef, mir::mono::Instance};
use std::{cmp::Ordering, hash::Hasher};

/// A Rust funtion with its file source, attributes, and raw function content.
#[derive(Debug, Serialize)]
pub struct SerFunction {
    hash: String,
    /// DefId in stable_mir.
    def_id: String,
    /// Every funtion must be declared in a specific file, even for those
    /// generated by macros.
    file: String,
    /// Attributes are attached the function, but it seems that attributes
    /// and function must be separated to query.
    attrs: Vec<String>,
    /// Raw function string, including name, signature, and body.
    func: String,
    /// Recursive function calls inside the proof.
    callees: Vec<Callee>,
}

impl SerFunction {
    pub fn new(fun: super::Function, tcx: TyCtxt, src_map: &SourceMap) -> Self {
        let inst = fun.instance;
        let def_id = format_def_id(&inst);
        let file = super::file_path(&inst);
        let attrs: Vec<_> = fun.attrs.iter().map(|a| a.as_str().to_owned()).collect();
        // Though this is from body span, fn name and signature are included.
        let func = super::source_code_with(fun.body.span, tcx, src_map);
        let callees: Vec<_> = fun.callees.iter().map(|x| Callee::new(x, tcx, src_map)).collect();

        // Hash
        let mut hasher = StableHasher::<SipHasher128>::new();
        hasher.write_str(&file);
        hasher.write_str(&func);
        hasher.write_length_prefix(attrs.len());
        attrs.iter().for_each(|a| hasher.write_str(a));
        hasher.write_length_prefix(callees.len());
        callees.iter().for_each(|c| {
            hasher.write_str(&c.file);
            hasher.write_str(&c.func);
        });
        let Hash128(hash) = hasher.finish();

        SerFunction { hash, def_id, file, attrs, func, callees }
    }

    /// Compare by file and func string.
    pub fn cmp_by_file_and_func(&self, other: &Self) -> Ordering {
        (&*self.file, &*self.func).cmp(&(&*other.file, &*other.func))
    }
}

// ************* hash *************
struct Hash128(String);

impl FromStableHash for Hash128 {
    type Hash = SipHasher128Hash;

    fn from(SipHasher128Hash([a, b]): SipHasher128Hash) -> Hash128 {
        Hash128(format!("{a}{b}"))
    }
}
// ************* hash *************

fn format_def_id(inst: &Instance) -> String {
    format!("{:?}", inst.def.def_id())
}

#[derive(Debug, Serialize)]
pub struct Callee {
    def_id: String,
    file: String,
    func: String,
}

impl Callee {
    fn new(inst: &Instance, tcx: TyCtxt, src_map: &SourceMap) -> Self {
        let def_id = format_def_id(inst);
        let file = super::file_path(inst);
        let func = super::source_code_of_body(inst, tcx, src_map).unwrap_or_default();
        Callee { def_id, file, func }
    }
}
