use rustc_hir::{Item, ItemKind};
use rustc_middle::ty::TyCtxt;
use rustc_span::source_map::SourceMap;
use serde::Serialize;

/// A Rust funtion with its file source, attributes, and raw function content.
#[derive(Debug, Default, Serialize)]
pub struct Function {
    /// Every funtion must be declared in a specific file, even for those
    /// generated by macros.
    file: String,
    /// Attributes are attached the function, but it seems that attributes
    /// and function must be separated to query.
    attrs: Vec<String>,
    /// Raw function string, including name, signature, and body.
    func: String,
}

impl Function {
    pub fn new(item: &Item, src_map: &SourceMap, tcx: TyCtxt) -> Option<Self> {
        if let ItemKind::Fn { has_body, .. } = &item.kind
            && *has_body
        {
            let mut func = Function {
                file: src_map
                    .span_to_filename(item.span)
                    .prefer_remapped_unconditionaly()
                    .to_string(),
                ..Default::default()
            };

            // add attributes
            for (i, attr) in tcx.get_all_attrs(item.owner_id).enumerate() {
                // FIXME: kani rewrites attributes from source to `#[allow(dead_code)]`
                // and `#[kanitool::...]`, but share the same span with the source span.
                // As a result, repeated `#[kani::proof]` are obtained from the source text,
                // but `attr: &AttrItem` contains real expanded attributes.
                let src_attr = src_map
                    .span_to_source(attr.span(), |text, x, y| {
                        let src = &text[x..y];
                        debug!("[attr {i}] [{x}:{y}]\n{src}");
                        Ok(src.to_owned())
                    })
                    .unwrap();
                func.attrs.push(src_attr);
            }

            // add function
            func.func = src_map
                .span_to_source(item.span, |text, x, y| {
                    let src = &text[x..y];
                    debug!("[{x}:{y}]\n{src}");
                    Ok(src.to_owned())
                })
                .unwrap();
            return Some(func);
        }
        None
    }
}
