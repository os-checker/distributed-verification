use indexmap::IndexSet;
use rustc_middle::ty::TyCtxt;
use rustc_smir::rustc_internal::internal;
use rustc_span::{Span, source_map::SourceMap};
use serde::Serialize;
use stable_mir::{
    CrateDef, CrateItem, DefId, ItemKind,
    mir::mono::Instance,
    ty::{FnDef, RigidTy, Ty, TyKind},
};

mod callees;

/// A Rust funtion with its file source, attributes, and raw function content.
#[derive(Debug, Default, Serialize)]
pub struct Function {
    /// Every funtion must be declared in a specific file, even for those
    /// generated by macros.
    file: String,
    /// Attributes are attached the function, but it seems that attributes
    /// and function must be separated to query.
    attrs: Vec<String>,
    /// Raw function string, including name, signature, and body.
    func: String,
    /// Recursive fnction calls inside the body.
    callees: Vec<String>,
}

impl Function {
    pub fn new(item: CrateItem, tcx: TyCtxt, src_map: &SourceMap) -> Option<Self> {
        if !matches!(item.kind(), ItemKind::Fn) {
            // skip non fn items
            return None;
        }
        // item.emit_mir(&mut std::io::stdout()).unwrap(); // MIR body
        let inst = Instance::try_from(item).inspect_err(|err| error!(?err)).ok()?;
        let fn_def = ty_to_fndef(inst.ty())?;
        let file = item.span().get_filename();
        let body = fn_def.body()?;

        let mut callees = IndexSet::new();
        // retrieve direct calls
        callees::calls_in_body(&body, &mut callees);
        // recursive calls
        let direct_calls: Vec<_> = callees.iter().copied().collect();
        for call in direct_calls {
            dbg!(call);
            callees::recursive_callees(call, tcx, &mut callees);
        }
        let callees = callees.into_iter().map(|x| format!("{x:?}")).collect();

        let func = source_code_with(body.span, tcx, src_map);
        info!(" - {:?} ({:?}): {func}", item.name(), item.span());

        // FIXME: kanitool and some other proc-macors attributes are generated by parsing,
        // and these generated attrs share with span of hand-written attrs in source code.
        // As a result, get_all_attributes through source span will emit duplicated attrs.
        // Need to fix this in the future, by analyzing Symbols of these attrs.
        let attrs = get_all_attributes(item.def_id(), tcx, src_map);

        // TODO: kanitool kind: proof, proof_for_contract, contract, ...

        Some(Function { file, attrs, func, callees })
    }
}

/// Extract FnDef from Ty.
fn ty_to_fndef(ty: Ty) -> Option<FnDef> {
    let TyKind::RigidTy(RigidTy::FnDef(fn_def, _)) = ty.kind() else {
        return None;
    };
    Some(fn_def)
}

/// Source code for a span.
fn source_code(span: Span, src_map: &SourceMap) -> String {
    src_map
        .span_to_source(span, |text, x, y| {
            let src = &text[x..y];
            debug!("[{x}:{y}]\n{src}");
            Ok(src.to_owned())
        })
        .unwrap()
}

/// Source code for a stable_mir span.
fn source_code_with(
    stable_mir_span: stable_mir::ty::Span,
    tcx: TyCtxt,
    src_map: &SourceMap,
) -> String {
    let span = internal(tcx, stable_mir_span);
    source_code(span, src_map)
}

/// Get all attributes for the item.
///
/// We don't call [`all_tool_attrs`], because it only gives tool attributes,
/// we want as raw attributes as possible.
///
/// [`all_tool_attrs`]: https://doc.rust-lang.org/nightly/nightly-rustc/stable_mir/struct.CrateItem.html#impl-CrateDef-for-CrateItem
fn get_all_attributes(stable_mir_def_id: DefId, tcx: TyCtxt, src_map: &SourceMap) -> Vec<String> {
    let def_id = internal(tcx, stable_mir_def_id);
    // dbg!(tcx.hir_body_owned_by(def_id.expect_local())); // HIR body
    tcx.get_all_attrs(def_id).map(|attr| source_code(attr.span(), src_map)).collect()
}
