use indexmap::IndexSet;
use kani::{CallGraph, KANI_TOOL_ATTRS, collect_reachable_items};
use rustc_middle::ty::TyCtxt;
use rustc_smir::rustc_internal::internal;
use rustc_span::{Span, source_map::SourceMap};
use stable_mir::{
    CrateDef, DefId,
    crate_def::Attribute,
    mir::mono::{Instance, MonoItem},
    ty::{FnDef, RigidTy, Ty, TyKind},
};
use std::cmp::Ordering;

mod kani;
mod serialization;
pub use serialization::SerFunction;

pub fn analyze(tcx: TyCtxt, src_map: &SourceMap) -> Vec<SerFunction> {
    let local_items = stable_mir::all_local_items();
    let cap = local_items.len();

    let mut entries = Vec::with_capacity(cap);

    for item in local_items {
        let _span = error_span!("all_local_items", ?item).entered();

        let Ok(inst) = Instance::try_from(item).inspect_err(|err| error!(?err)) else { continue };
        entries.push(MonoItem::from(inst));
    }

    let (mono_items, callgraph) = collect_reachable_items(tcx, &entries);

    // Filter out non kanitool functions.
    let mut proofs: Vec<_> = mono_items
        .iter()
        .filter_map(|f| Function::new(f, &callgraph, tcx, src_map, |x| !x.attrs.is_empty()))
        .collect();
    // Sort proofs by file path and source code.
    proofs.sort_by(|a, b| (&*a.file, &*a.func).cmp(&(&*b.file, &*b.func)));
    proofs.into_iter().map(|fun| SerFunction::new(fun, tcx, src_map)).collect()
}

/// A Rust funtion with its file source, attributes, and raw function content.
#[derive(Debug)]
pub struct Function {
    /// DefId in stable_mir.
    def_id: DefId,
    /// Every funtion must be declared in a specific file, even for those
    /// generated by macros.
    file: String,
    /// Attributes are attached the function, but it seems that attributes
    /// and function must be separated to query.
    attrs: Vec<Attribute>,
    /// Raw function string, including name, signature, and body.
    func: String,
    /// Recursive fnction calls inside the body.
    /// The elements are sorted by file path and fn source code to keep hash value stable.
    callees: IndexSet<Instance>,
}

impl Function {
    pub fn new(
        item: &MonoItem,
        callgraph: &CallGraph,
        tcx: TyCtxt,
        src_map: &SourceMap,
        filter: impl FnOnce(&Self) -> bool,
    ) -> Option<Self> {
        // skip non fn items
        let &MonoItem::Fn(inst) = item else {
            return None;
        };

        let inst_def = inst.def;

        // Only need kanitool attrs: proof, proof_for_contract, contract, ...
        let attrs = KANI_TOOL_ATTRS.iter().flat_map(|v| inst_def.tool_attrs(v)).collect();

        let span = inst_def.span();
        let file = file_path(&inst);

        let fn_def = ty_to_fndef(inst.ty())?;
        let body = fn_def.body()?;

        let mut callees = IndexSet::new();
        callgraph.recursive_callees(item, &mut callees);
        callees.sort_by(|a, b| cmp_callees(a, b, tcx, src_map));

        let func = source_code_with(body.span, tcx, src_map);
        info!(" - {:?} ({span:?}): {func}", inst_def.name());

        let def_id = inst_def.def_id();
        let this = Function { def_id, file, attrs, func, callees };
        filter(&this).then_some(this)
    }
}

/// Extract FnDef from Ty.
fn ty_to_fndef(ty: Ty) -> Option<FnDef> {
    let TyKind::RigidTy(RigidTy::FnDef(fn_def, _)) = ty.kind() else {
        return None;
    };
    Some(fn_def)
}

/// Source code for a span.
fn source_code(span: Span, src_map: &SourceMap) -> String {
    src_map
        .span_to_source(span, |text, x, y| {
            let src = &text[x..y];
            debug!("[{x}:{y}]\n{src}");
            Ok(src.to_owned())
        })
        .unwrap()
}

/// Source code for a stable_mir span.
fn source_code_with(
    stable_mir_span: stable_mir::ty::Span,
    tcx: TyCtxt,
    src_map: &SourceMap,
) -> String {
    let span = internal(tcx, stable_mir_span);
    source_code(span, src_map)
}

fn source_code_of_body(inst: &Instance, tcx: TyCtxt, src_map: &SourceMap) -> Option<String> {
    inst.body().map(|body| source_code_with(body.span, tcx, src_map))
}

fn cmp_callees(a: &Instance, b: &Instance, tcx: TyCtxt, src_map: &SourceMap) -> Ordering {
    let filename_a = file_path(a);
    let filename_b = file_path(b);
    match filename_a.cmp(&filename_b) {
        Ordering::Equal => (),
        ord => return ord,
    }

    let body_a = source_code_of_body(a, tcx, src_map);
    let body_b = source_code_of_body(b, tcx, src_map);
    body_a.cmp(&body_b)
}

fn file_path(inst: &Instance) -> String {
    use std::sync::LazyLock;
    static PREFIXES: LazyLock<[String; 2]> = LazyLock::new(|| {
        let mut pwd = std::env::current_dir().unwrap().into_os_string().into_string().unwrap();
        pwd.push('/');

        let out = std::process::Command::new("rustc").arg("--print=sysroot").output().unwrap();
        let sysroot = std::str::from_utf8(&out.stdout).unwrap().trim();
        let sysroot = format!("{sysroot}/lib/rustlib/src/rust/");
        [pwd, sysroot]
    });

    let file = inst.def.span().get_filename();
    for prefix in &*PREFIXES {
        if let Some(file) = file.strip_prefix(prefix) {
            return file.to_owned();
        }
    }
    file
}
