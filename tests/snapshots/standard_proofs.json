[
  {
    "def_id": "DefId { id: 1, name: \"verify::standard_proof_empty\" }",
    "file": "tests/standard_proofs.rs",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": "fn standard_proof_empty() {}",
    "callees": []
  },
  {
    "def_id": "DefId { id: 0, name: \"verify::standard_proof\" }",
    "file": "tests/standard_proofs.rs",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": "fn standard_proof() {\n        let val: u8 = kani::any();\n        assert_eq!(val, 1, \"Not eq to 1.\");\n    }",
    "callees": [
      {
        "def_id": "DefId { id: 6, name: \"kani::assert\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/lib.rs",
        "func": "pub const fn assert(cond: bool, msg: &'static str) {\n            let _ = cond;\n            let _ = msg;\n        }"
      },
      {
        "def_id": "DefId { id: 5, name: \"kani::any\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/lib.rs",
        "func": "pub fn any<T: Arbitrary>() -> T {\n            T::any()\n        }"
      },
      {
        "def_id": "DefId { id: 8, name: \"<u8 as kani::Arbitrary>::any\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/arbitrary.rs",
        "func": "fn any() -> Self {\n                        // This size_of call does not use generic_const_exprs feature. It's inside a macro, and Self isn't generic.\n                        unsafe { crate::kani::any_raw_internal::<Self>() }\n                    }"
      },
      {
        "def_id": "DefId { id: 9, name: \"kani::any_raw_internal\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/lib.rs",
        "func": "unsafe fn any_raw_internal<T: Copy>() -> T {\n            any_raw::<T>()\n        }"
      },
      {
        "def_id": "DefId { id: 10, name: \"kani::any_raw\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/lib.rs",
        "func": "fn any_raw<T: Copy>() -> T {\n            kani_intrinsic()\n        }"
      },
      {
        "def_id": "DefId { id: 11, name: \"kani::kani_intrinsic\" }",
        "file": "/home/zjp/rust/kani/library/kani_core/src/lib.rs",
        "func": "fn kani_intrinsic<T>() -> T {\n            #[allow(clippy::empty_loop)]\n            loop {}\n        }"
      }
    ]
  },
  {
    "def_id": "DefId { id: 2, name: \"verify::recursive_callees\" }",
    "file": "tests/standard_proofs.rs",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": "fn recursive_callees() {\n        crate::top_level();\n    }",
    "callees": [
      {
        "def_id": "DefId { id: 3, name: \"top_level\" }",
        "file": "tests/standard_proofs.rs",
        "func": "pub fn top_level() {\n    m::func1();\n}"
      },
      {
        "def_id": "DefId { id: 4, name: \"m::func1\" }",
        "file": "tests/standard_proofs.rs",
        "func": "pub fn func1() {\n        let _a = \"\".trim();\n    }"
      },
      {
        "def_id": "DefId { id: 12, name: \"core::str::<impl str>::trim\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub fn trim(&self) -> &str {\n        self.trim_matches(|c: char| c.is_whitespace())\n    }"
      },
      {
        "def_id": "DefId { id: 13, name: \"core::str::<impl str>::trim_matches\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub fn trim_matches<P: Pattern>(&self, pat: P) -> &str\n    where\n        for<'a> P::Searcher<'a>: DoubleEndedSearcher<'a>,\n    {\n        let mut i = 0;\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, b)) = matcher.next_reject() {\n            i = a;\n            j = b; // Remember earliest known match, correct it below if\n            // last match is different\n        }\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { self.get_unchecked(i..j) }\n    }"
      },
      {
        "def_id": "DefId { id: 18, name: \"<std::str::pattern::CharPredicateSearcher<'a, F> as std::str::pattern::Searcher<'a>>::next_reject\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next_reject(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject()\n        }"
      },
      {
        "def_id": "DefId { id: 17, name: \"std::str::pattern::Searcher::next_reject\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next_reject(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 133, name: \"<std::str::pattern::MultiCharEqSearcher<'a, C> as std::str::pattern::Searcher<'a>>::next\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }"
      },
      {
        "def_id": "DefId { id: 38, name: \"<F as std::str::pattern::MultiCharEq>::matches\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn matches(&mut self, c: char) -> bool {\n        (*self)(c)\n    }"
      },
      {
        "def_id": "DefId { id: 23, name: \"core::str::<impl str>::trim::{closure#0}\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "|c: char| c.is_whitespace()"
      },
      {
        "def_id": "DefId { id: 106, name: \"std::char::methods::<impl char>::is_whitespace\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs",
        "func": "pub const fn is_whitespace(self) -> bool {\n        match self {\n            ' ' | '\\x09'..='\\x0d' => true,\n            c => c > '\\x7f' && unicode::White_Space(c),\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 107, name: \"core::unicode::unicode_data::white_space::lookup\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/unicode/unicode_data.rs",
        "func": "pub const fn lookup(c: char) -> bool {\n        match c as u32 >> 8 {\n            0 => WHITESPACE_MAP[c as usize & 0xff] & 1 != 0,\n            22 => c as u32 == 0x1680,\n            32 => WHITESPACE_MAP[c as usize & 0xff] & 2 != 0,\n            48 => c as u32 == 0x3000,\n            _ => false,\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)"
      },
      {
        "def_id": "DefId { id: 34, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs",
        "func": "fn len(&self) -> usize {\n                len!(self)\n            }"
      },
      {
        "def_id": "DefId { id: 45, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }"
      },
      {
        "def_id": "DefId { id: 47, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }"
      },
      {
        "def_id": "DefId { id: 48, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs",
        "func": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }"
      },
      {
        "def_id": "DefId { id: 49, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }"
      },
      {
        "def_id": "DefId { id: 51, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 65, name: \"core::panicking::panic_nounwind\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs",
        "func": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}"
      },
      {
        "def_id": "DefId { id: 67, name: \"core::panicking::panic_nounwind_fmt\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs",
        "func": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}"
      },
      {
        "def_id": "DefId { id: 68, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs",
        "func": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }"
      },
      {
        "def_id": "DefId { id: 58, name: \"std::panic::Location::<'a>::caller\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic/location.rs",
        "func": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }"
      },
      {
        "def_id": "DefId { id: 59, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panic/panic_info.rs",
        "func": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }"
      },
      {
        "def_id": "DefId { id: 55, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/fmt/mod.rs",
        "func": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }"
      },
      {
        "def_id": "DefId { id: 64, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }"
      },
      {
        "def_id": "DefId { id: 66, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs",
        "func": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }"
      },
      {
        "def_id": "DefId { id: 50, name: \"core::ub_checks::check_language_ub\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}"
      },
      {
        "def_id": "DefId { id: 63, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs",
        "func": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }"
      },
      {
        "def_id": "DefId { id: 52, name: \"std::mem::size_of\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/mem/mod.rs",
        "func": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}"
      },
      {
        "def_id": "DefId { id: 54, name: \"core::panicking::panic\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs",
        "func": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}"
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_fmt\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/panicking.rs",
        "func": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}"
      },
      {
        "def_id": "DefId { id: 43, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }"
      },
      {
        "def_id": "DefId { id: 46, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }"
      },
      {
        "def_id": "DefId { id: 135, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 136, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }"
      },
      {
        "def_id": "DefId { id: 137, name: \"core::str::validations::next_code_point\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs",
        "func": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}"
      },
      {
        "def_id": "DefId { id: 83, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 85, name: \"core::str::validations::utf8_first_byte\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs",
        "func": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}"
      },
      {
        "def_id": "DefId { id: 81, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 139, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs",
        "func": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 140, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs",
        "func": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }"
      },
      {
        "def_id": "DefId { id: 142, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 143, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs",
        "func": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }"
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }"
      },
      {
        "def_id": "DefId { id: 95, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }"
      },
      {
        "def_id": "DefId { id: 96, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs",
        "func": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }"
      },
      {
        "def_id": "DefId { id: 122, name: \"std::ptr::without_provenance_mut\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}"
      },
      {
        "def_id": "DefId { id: 141, name: \"std::ptr::NonNull::<T>::add\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }"
      },
      {
        "def_id": "DefId { id: 84, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 89, name: \"std::hint::unreachable_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/hint.rs",
        "func": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}"
      },
      {
        "def_id": "DefId { id: 90, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs",
        "func": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}"
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 138, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "|ch| char::from_u32_unchecked(ch)"
      },
      {
        "def_id": "DefId { id: 72, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/methods.rs",
        "func": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }"
      },
      {
        "def_id": "DefId { id: 73, name: \"std::char::convert::from_u32_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs",
        "func": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}"
      },
      {
        "def_id": "DefId { id: 74, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 75, name: \"std::char::convert::char_try_from_u32\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/char/convert.rs",
        "func": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}"
      },
      {
        "def_id": "DefId { id: 78, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/uint_macros.rs",
        "func": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }"
      },
      {
        "def_id": "DefId { id: 76, name: \"std::result::Result::<T, E>::is_ok\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs",
        "func": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }"
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)"
      },
      {
        "def_id": "DefId { id: 21, name: \"core::str::<impl str>::get_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }"
      },
      {
        "def_id": "DefId { id: 124, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/traits.rs",
        "func": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 126, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 128, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }"
      },
      {
        "def_id": "DefId { id: 125, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub const fn len(self) -> usize {\n        metadata(self)\n    }"
      },
      {
        "def_id": "DefId { id: 131, name: \"std::ptr::metadata\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs",
        "func": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}"
      },
      {
        "def_id": "DefId { id: 127, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/const_ptr.rs",
        "func": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }"
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::slice_from_raw_parts\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}"
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::from_raw_parts\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/metadata.rs",
        "func": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}"
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)"
      },
      {
        "def_id": "DefId { id: 16, name: \"<F as std::str::pattern::Pattern>::into_searcher\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn into_searcher<$a>(self, haystack: &$a str) -> $t {\n            ($smap)(($pmap)(self).into_searcher(haystack))\n        }"
      },
      {
        "def_id": "DefId { id: 110, name: \"<std::str::pattern::MultiCharEqPattern<C> as std::str::pattern::Pattern>::into_searcher\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn into_searcher(self, haystack: &str) -> MultiCharEqSearcher<'_, C> {\n        MultiCharEqSearcher { haystack, char_eq: self.0, char_indices: haystack.char_indices() }\n    }"
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::<impl str>::char_indices\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }"
      },
      {
        "def_id": "DefId { id: 112, name: \"core::str::<impl str>::chars\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }"
      },
      {
        "def_id": "DefId { id: 113, name: \"core::str::<impl str>::as_bytes\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs",
        "func": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }"
      },
      {
        "def_id": "DefId { id: 114, name: \"core::slice::<impl [T]>::iter\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/mod.rs",
        "func": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }"
      },
      {
        "def_id": "DefId { id: 115, name: \"std::slice::Iter::<'a, T>::new\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter.rs",
        "func": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 119, name: \"std::ptr::without_provenance\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}"
      },
      {
        "def_id": "DefId { id: 118, name: \"std::ptr::NonNull::<T>::cast\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }"
      },
      {
        "def_id": "DefId { id: 47, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }"
      },
      {
        "def_id": "DefId { id: 120, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs",
        "func": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }"
      },
      {
        "def_id": "DefId { id: 117, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }"
      },
      {
        "def_id": "DefId { id: 121, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }"
      },
      {
        "def_id": "DefId { id: 20, name: \"<std::str::pattern::CharPredicateSearcher<'a, F> as std::str::pattern::ReverseSearcher<'a>>::next_reject_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject_back()\n        }"
      },
      {
        "def_id": "DefId { id: 19, name: \"std::str::pattern::ReverseSearcher::next_reject_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next_back() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 28, name: \"<std::str::pattern::MultiCharEqSearcher<'a, C> as std::str::pattern::ReverseSearcher<'a>>::next_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/pattern.rs",
        "func": "fn next_back(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next_back() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }"
      },
      {
        "def_id": "DefId { id: 36, name: \"<std::str::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "fn next_back(&mut self) -> Option<(usize, char)> {\n        self.iter.next_back().map(|ch| {\n            let index = self.front_offset + self.iter.iter.len();\n            (index, ch)\n        })\n    }"
      },
      {
        "def_id": "DefId { id: 40, name: \"<std::str::Chars<'a> as std::iter::DoubleEndedIterator>::next_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "fn next_back(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point_reverse(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }"
      },
      {
        "def_id": "DefId { id: 70, name: \"core::str::validations::next_code_point_reverse\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs",
        "func": "pub(super) unsafe fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\nwhere\n    I: DoubleEndedIterator<Item = &'a u8>,\n{\n    // Decode UTF-8\n    let w = match *bytes.next_back()? {\n        next_byte if next_byte < 128 => return Some(next_byte as u32),\n        back_byte => back_byte,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [x [y [z w]]]\n    let mut ch;\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let z = unsafe { *bytes.next_back().unwrap_unchecked() };\n    ch = utf8_first_byte(z, 2);\n    if utf8_is_cont_byte(z) {\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let y = unsafe { *bytes.next_back().unwrap_unchecked() };\n        ch = utf8_first_byte(y, 3);\n        if utf8_is_cont_byte(y) {\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let x = unsafe { *bytes.next_back().unwrap_unchecked() };\n            ch = utf8_first_byte(x, 4);\n            ch = utf8_acc_cont_byte(ch, y);\n        }\n        ch = utf8_acc_cont_byte(ch, z);\n    }\n    ch = utf8_acc_cont_byte(ch, w);\n\n    Some(ch)\n}"
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/validations.rs",
        "func": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}"
      },
      {
        "def_id": "DefId { id: 79, name: \"<std::slice::Iter<'a, T> as std::iter::DoubleEndedIterator>::next_back\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs",
        "func": "fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 93, name: \"std::slice::Iter::<'a, T>::next_back_unchecked\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs",
        "func": "unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }"
      },
      {
        "def_id": "DefId { id: 94, name: \"std::slice::Iter::<'a, T>::pre_dec_end\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/slice/iter/macros.rs",
        "func": "unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }"
      },
      {
        "def_id": "DefId { id: 97, name: \"std::ptr::mut_ptr::<impl *mut T>::cast\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs",
        "func": "pub const fn cast<U>(self) -> *mut U {\n        self as _\n    }"
      },
      {
        "def_id": "DefId { id: 97, name: \"std::ptr::mut_ptr::<impl *mut T>::cast\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mut_ptr.rs",
        "func": "pub const fn cast<U>(self) -> *mut U {\n        self as _\n    }"
      },
      {
        "def_id": "DefId { id: 98, name: \"std::ptr::NonNull::<T>::sub\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        if T::IS_ZST {\n            // Pointer arithmetic does nothing when the pointee is a ZST.\n            self\n        } else {\n            // SAFETY: the caller must uphold the safety contract for `offset`.\n            // Because the pointee is *not* a ZST, that means that `count` is\n            // at most `isize::MAX`, and thus the negation cannot overflow.\n            unsafe { self.offset((count as isize).unchecked_neg()) }\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 100, name: \"std::ptr::NonNull::<T>::offset\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/non_null.rs",
        "func": "pub const unsafe fn offset(self, count: isize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }"
      },
      {
        "def_id": "DefId { id: 99, name: \"core::num::<impl isize>::unchecked_neg\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs",
        "func": "pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }"
      },
      {
        "def_id": "DefId { id: 101, name: \"core::num::<impl isize>::unchecked_neg::precondition_check\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ub_checks.rs",
        "func": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }"
      },
      {
        "def_id": "DefId { id: 102, name: \"core::num::<impl isize>::overflowing_neg\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/num/int_macros.rs",
        "func": "pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }"
      },
      {
        "def_id": "DefId { id: 103, name: \"std::intrinsics::unlikely\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs",
        "func": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}"
      },
      {
        "def_id": "DefId { id: 104, name: \"std::intrinsics::cold_path\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/intrinsics/mod.rs",
        "func": "pub const fn cold_path() {}"
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 71, name: \"<std::str::Chars<'a> as std::iter::DoubleEndedIterator>::next_back::{closure#0}\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "|ch| char::from_u32_unchecked(ch)"
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)"
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs",
        "func": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }"
      },
      {
        "def_id": "DefId { id: 39, name: \"<std::str::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back::{closure#0}\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs",
        "func": "|ch| {\n            let index = self.front_offset + self.iter.iter.len();\n            (index, ch)\n        }"
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "file": "/home/zjp/.rustup/toolchains/nightly-2025-04-01-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ptr/mod.rs",
        "func": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)"
      }
    ]
  }
]