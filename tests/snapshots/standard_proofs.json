[
  {
    "hash": "515319289071538444516787321590567870674",
    "def_id": "DefId { id: 2, name: \"verify::recursive_callees\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "kind": "Standard",
    "func": {
      "name": "verify::recursive_callees",
      "mangled_name": "_ZN15standard_proofs6verify17recursive_callees17h27fada5ffc99c85cE",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs.rs",
      "src": "fn recursive_callees() {\n        crate::top_level();\n    }",
      "macro_backtrace_len": 0,
      "macro_backtrace": []
    },
    "callees_len": 108,
    "callees": [
      {
        "def_id": "DefId { id: 81, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h940d34350407d02fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 83, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h7d23bb636378f411E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h45ac6359154c6d47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"<std::slice::Iter<'a, T> as std::iter::DoubleEndedIterator>::next_back\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::DoubleEndedIterator>::next_back",
          "mangled_name": "_ZN106_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$9next_back17h58a9055b761165d8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 34, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17hc63bd942e7955d72E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h348589ca31b2f6e7E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 36, name: \"<std::str::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::DoubleEndedIterator>::next_back",
          "mangled_name": "_ZN102_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$9next_back17h73df79516a267cc3E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next_back(&mut self) -> Option<(usize, char)> {\n        self.iter.next_back().map(|ch| {\n            let index = self.front_offset + self.iter.iter.len();\n            (index, ch)\n        })\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 39, name: \"<std::str::CharIndices<'a> as std::iter::DoubleEndedIterator>::next_back::{closure#0}\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}",
          "mangled_name": "_ZN102_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$9next_back28_$u7b$$u7b$closure$u7d$$u7d$17h5fae0dc25c53086aE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| {\n            let index = self.front_offset + self.iter.iter.len();\n            (index, ch)\n        }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h005d425a965d075fE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 40, name: \"<std::str::Chars<'a> as std::iter::DoubleEndedIterator>::next_back\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::DoubleEndedIterator>::next_back",
          "mangled_name": "_ZN96_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$9next_back17hea4b80f41f6f20b9E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next_back(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point_reverse(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 71, name: \"<std::str::Chars<'a> as std::iter::DoubleEndedIterator>::next_back::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}",
          "mangled_name": "_ZN96_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$9next_back28_$u7b$$u7b$closure$u7d$$u7d$17h1b795076bc2a852bE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h5292a77325373f99E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hc32a8403a403fbadE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 20, name: \"<std::str::pattern::CharPredicateSearcher<'a, F> as std::str::pattern::ReverseSearcher<'a>>::next_reject_back\" }",
        "func": {
          "name": "<std::str::pattern::CharPredicateSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::ReverseSearcher<'_>>::next_reject_back",
          "mangled_name": "_ZN106_$LT$core..str..pattern..CharPredicateSearcher$LT$F$GT$$u20$as$u20$core..str..pattern..ReverseSearcher$GT$16next_reject_back17h36f9d438201cf1f3E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject_back()\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "searcher_methods!(reverse)",
              "defsite": "macro_rules! searcher_methods {\n    (forward) => {\n        #[inline]\n        fn haystack(&self) -> &'a str {\n            self.0.haystack()\n        }\n        #[inline]\n        fn next(&mut self) -> SearchStep {\n            self.0.next()\n        }\n        #[inline]\n        fn next_match(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match()\n        }\n        #[inline]\n        fn next_reject(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject()\n        }\n    };\n    (reverse) => {\n        #[inline]\n        fn next_back(&mut self) -> SearchStep {\n            self.0.next_back()\n        }\n        #[inline]\n        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match_back()\n        }\n        #[inline]\n        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject_back()\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 18, name: \"<std::str::pattern::CharPredicateSearcher<'a, F> as std::str::pattern::Searcher<'a>>::next_reject\" }",
        "func": {
          "name": "<std::str::pattern::CharPredicateSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::Searcher<'_>>::next_reject",
          "mangled_name": "_ZN99_$LT$core..str..pattern..CharPredicateSearcher$LT$F$GT$$u20$as$u20$core..str..pattern..Searcher$GT$11next_reject17h48a8f90bc43532f2E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next_reject(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject()\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "searcher_methods!(forward)",
              "defsite": "macro_rules! searcher_methods {\n    (forward) => {\n        #[inline]\n        fn haystack(&self) -> &'a str {\n            self.0.haystack()\n        }\n        #[inline]\n        fn next(&mut self) -> SearchStep {\n            self.0.next()\n        }\n        #[inline]\n        fn next_match(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match()\n        }\n        #[inline]\n        fn next_reject(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject()\n        }\n    };\n    (reverse) => {\n        #[inline]\n        fn next_back(&mut self) -> SearchStep {\n            self.0.next_back()\n        }\n        #[inline]\n        fn next_match_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_match_back()\n        }\n        #[inline]\n        fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n            self.0.next_reject_back()\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 110, name: \"<std::str::pattern::MultiCharEqPattern<C> as std::str::pattern::Pattern>::into_searcher\" }",
        "func": {
          "name": "<std::str::pattern::MultiCharEqPattern<{closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::Pattern>::into_searcher",
          "mangled_name": "_ZN95_$LT$core..str..pattern..MultiCharEqPattern$LT$C$GT$$u20$as$u20$core..str..pattern..Pattern$GT$13into_searcher17h9c2527f1ed461d81E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn into_searcher(self, haystack: &str) -> MultiCharEqSearcher<'_, C> {\n        MultiCharEqSearcher { haystack, char_eq: self.0, char_indices: haystack.char_indices() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"<std::str::pattern::MultiCharEqSearcher<'a, C> as std::str::pattern::ReverseSearcher<'a>>::next_back\" }",
        "func": {
          "name": "<std::str::pattern::MultiCharEqSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::ReverseSearcher<'_>>::next_back",
          "mangled_name": "_ZN104_$LT$core..str..pattern..MultiCharEqSearcher$LT$C$GT$$u20$as$u20$core..str..pattern..ReverseSearcher$GT$9next_back17h4e8860bb9f8feccaE",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next_back(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next_back() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 19, name: \"std::str::pattern::ReverseSearcher::next_reject_back\" }",
        "func": {
          "name": "<std::str::pattern::MultiCharEqSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::ReverseSearcher<'_>>::next_reject_back",
          "mangled_name": "_ZN4core3str7pattern15ReverseSearcher16next_reject_back17hdd0e40dfa62a8621E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next_reject_back(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next_back() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 131, name: \"<std::str::pattern::MultiCharEqSearcher<'a, C> as std::str::pattern::Searcher<'a>>::next\" }",
        "func": {
          "name": "<std::str::pattern::MultiCharEqSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::Searcher<'_>>::next",
          "mangled_name": "_ZN97_$LT$core..str..pattern..MultiCharEqSearcher$LT$C$GT$$u20$as$u20$core..str..pattern..Searcher$GT$4next17h12b6c309bef60d79E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next(&mut self) -> SearchStep {\n        let s = &mut self.char_indices;\n        // Compare lengths of the internal byte slice iterator\n        // to find length of current char\n        let pre_len = s.iter.iter.len();\n        if let Some((i, c)) = s.next() {\n            let len = s.iter.iter.len();\n            let char_len = pre_len - len;\n            if self.char_eq.matches(c) {\n                return SearchStep::Match(i, i + char_len);\n            } else {\n                return SearchStep::Reject(i, i + char_len);\n            }\n        }\n        SearchStep::Done\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 17, name: \"std::str::pattern::Searcher::next_reject\" }",
        "func": {
          "name": "<std::str::pattern::MultiCharEqSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}> as std::str::pattern::Searcher<'_>>::next_reject",
          "mangled_name": "_ZN4core3str7pattern8Searcher11next_reject17hfa7560cde6116521E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn next_reject(&mut self) -> Option<(usize, usize)> {\n        loop {\n            match self.next() {\n                SearchStep::Reject(a, b) => return Some((a, b)),\n                SearchStep::Done => return None,\n                _ => continue,\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 38, name: \"<F as std::str::pattern::MultiCharEq>::matches\" }",
        "func": {
          "name": "<{closure@core::str::<impl str>::trim::{closure#0}} as std::str::pattern::MultiCharEq>::matches",
          "mangled_name": "_ZN53_$LT$F$u20$as$u20$core..str..pattern..MultiCharEq$GT$7matches17hbe20e7ffdb7aca2dE",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn matches(&mut self, c: char) -> bool {\n        (*self)(c)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 16, name: \"<F as std::str::pattern::Pattern>::into_searcher\" }",
        "func": {
          "name": "<{closure@core::str::<impl str>::trim::{closure#0}} as std::str::pattern::Pattern>::into_searcher",
          "mangled_name": "_ZN49_$LT$F$u20$as$u20$core..str..pattern..Pattern$GT$13into_searcher17h13a0f3acc9367263E",
          "kind": "Item",
          "file": "library/core/src/str/pattern.rs",
          "src": "fn into_searcher<$a>(self, haystack: &$a str) -> $t {\n            ($smap)(($pmap)(self).into_searcher(haystack))\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "pattern_methods!('a, CharPredicateSearcher<'a, F>, MultiCharEqPattern, CharPredicateSearcher)",
              "defsite": "macro_rules! pattern_methods {\n    ($a:lifetime, $t:ty, $pmap:expr, $smap:expr) => {\n        type Searcher<$a> = $t;\n\n        #[inline]\n        fn into_searcher<$a>(self, haystack: &$a str) -> $t {\n            ($smap)(($pmap)(self).into_searcher(haystack))\n        }\n\n        #[inline]\n        fn is_contained_in<$a>(self, haystack: &$a str) -> bool {\n            ($pmap)(self).is_contained_in(haystack)\n        }\n\n        #[inline]\n        fn is_prefix_of<$a>(self, haystack: &$a str) -> bool {\n            ($pmap)(self).is_prefix_of(haystack)\n        }\n\n        #[inline]\n        fn strip_prefix_of<$a>(self, haystack: &$a str) -> Option<&$a str> {\n            ($pmap)(self).strip_prefix_of(haystack)\n        }\n\n        #[inline]\n        fn is_suffix_of<$a>(self, haystack: &$a str) -> bool\n        where\n            $t: ReverseSearcher<$a>,\n        {\n            ($pmap)(self).is_suffix_of(haystack)\n        }\n\n        #[inline]\n        fn strip_suffix_of<$a>(self, haystack: &$a str) -> Option<&$a str>\n        where\n            $t: ReverseSearcher<$a>,\n        {\n            ($pmap)(self).strip_suffix_of(haystack)\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 102, name: \"core::num::<impl isize>::overflowing_neg\" }",
        "func": {
          "name": "core::num::<impl isize>::overflowing_neg",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$isize$GT$15overflowing_neg17he11b51dce7f819bbE",
          "kind": "Item",
          "file": "library/core/src/num/int_macros.rs",
          "src": "pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "int_impl! {\n        Self = isize,\n        ActualT = i64,\n        UnsignedT = usize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        Min = -9223372036854775808,\n        Max = 9223372036854775807,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! int_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        UnsignedT = $UnsignedT:ty,\n\n        // There are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        Min = $Min:literal,\n        Max = $Max:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type\n        #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = !Self::MAX;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = <$UnsignedT>::BITS;\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b100_0000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        ///\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -4\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (self as $UnsignedT).leading_ones()\n        }\n\n        /// Returns the number of trailing ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 3\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (self as $UnsignedT).trailing_ones()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as an unsigned integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_unsigned(), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_unsigned(self) -> $UnsignedT {\n            self as $UnsignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            (self as $UnsignedT).reverse_bits() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with an unsigned integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_unsigned(2), 3);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).strict_sub(1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with an unsigned integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict subtraction with an unsigned integer. Computes `self - rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub_unsigned(2), -1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.strict_mul(1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n        /// or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// returning `None` if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div_euclid(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div_euclid(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div_euclid(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None` if\n        /// `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean remainder. Computes `self.rem_euclid(rhs)`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem_euclid(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem_euclid(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem_euclid(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Unchecked negation. Computes `-self`, assuming overflow cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self == \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_neg`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_neg`]: \", stringify!($SelfT), \"::checked_neg\")]\n        #[unstable(\n            feature = \"unchecked_neg\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }\n\n        /// Strict negation. Computes `-self`, panicking if `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_neg(), -5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x1\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(128);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, which yields `0` for a positive number,\n        /// and `-1` for a negative number.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.unbounded_shr(129), -1);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                // A shift by `Self::BITS-1` suffices for signed integers, because the sign bit is copied for each of the shifted bits.\n\n                // SAFETY:\n                // `Self::BITS-1` is guaranteed to be less than `Self::BITS`\n                unsafe { self.unchecked_shr(Self::BITS - 1) }\n            }\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Strict absolute value. Computes `self.abs()`, panicking if\n        /// `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").strict_abs(), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_abs();\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_abs(self) -> Self {\n            if self.is_negative() {\n                self.strict_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".strict_pow(2), 64);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// Returns `None` if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_isqrt(), Some(3));\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_isqrt(self) -> Option<Self> {\n            if self < 0 {\n                None\n            } else {\n                // SAFETY: Input is nonnegative in this `else` branch.\n                let result = unsafe {\n                    crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT\n                };\n\n                // Inform the optimizer what the range of outputs is. If\n                // testing `core` crashes with no panic message and a\n                // `num::int_sqrt::i*` test failed, it's because your edits\n                // caused these assertions to become false.\n                //\n                // SAFETY: Integer square root is a monotonically nondecreasing\n                // function, which means that increasing the input will never\n                // cause the output to decrease. Thus, since the input for\n                // nonnegative signed integers is bounded by\n                // `[0, <$ActualT>::MAX]`, sqrt(n) will be bounded by\n                // `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n                unsafe {\n                    // SAFETY: `<$ActualT>::MAX` is nonnegative.\n                    const MAX_RESULT: $SelfT = unsafe {\n                        crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT\n                    };\n\n                    crate::hint::assert_unchecked(result >= 0);\n                    crate::hint::assert_unchecked(result <= MAX_RESULT);\n                }\n\n                Some(result)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n        /// bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the upper bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_add_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT), \"::MIN);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating subtraction with an unsigned integer. Computes `self - rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the lower bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_sub_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MIN,\n            }\n        }\n\n        /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n        /// instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_neg(self) -> Self {\n            intrinsics::saturating_sub(0, self)\n        }\n\n        /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n        /// MIN` instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            if self.is_negative() {\n                self.saturating_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => if (self < 0) == (rhs < 0) {\n                    Self::MAX\n                } else {\n                    Self::MIN\n                }\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_div(-1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_div(-1), \", stringify!($SelfT), \"::MAX);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            match self.overflowing_div(rhs) {\n                (result, false) => result,\n                (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None if self < 0 && exp % 2 == 1 => Self::MIN,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with an unsigned integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with an unsigned integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\")]\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n        /// type. In this case, this method returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self.overflowing_div_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n        /// invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n        /// this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n        /// at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). In this case, this method returns 0.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self.overflowing_rem_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        /// The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n        /// is the negative minimal value for the type); this is a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n        /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n        /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n        /// The primitive integer types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n        /// removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n        /// to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n        /// end. The primitive integer types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\")]\n        /// assert_eq!((-128i16).wrapping_shr(64), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n        /// minimal value for the type; this is a positive value that is too large to represent in the type. In\n        /// such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT), \"::MIN);\")]\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }\n\n        /// Computes the absolute value of `self` without any wrapping\n        /// or panicking.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        /// assert_eq!((-128i8).unsigned_abs(), 128u8);\n        /// ```\n        #[stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[rustc_const_stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\")]\n        /// assert_eq!(3i8.wrapping_pow(5), -13);\n        /// assert_eq!(3i8.wrapping_pow(6), -39);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would have\n        /// occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns a tuple of the sum along with a boolean indicating\n        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n        /// value is returned.\n        ///\n        /// This allows chaining together multiple additions to create a wider\n        /// addition, and can be useful for bignum addition. This method should\n        /// only be used for the most significant word; for the less significant\n        /// words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a carry flag,\n        /// and should *not* be added to a more significant word.\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//   10  MAX    (a = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// + -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//    6    8    (sum = 6  2^\", stringify!($BITS), \" + 8)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let carry0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(overflow, false);\n        ///\n        /// assert_eq!((sum1, sum0), (6, 8));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_add(rhs);\n            let (c, d) = a.overflowing_add(carry as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` + `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_add(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n        /// overflow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns a tuple of the\n        /// difference along with a boolean indicating whether an arithmetic\n        /// overflow would occur. On overflow, the wrapped value is returned.\n        ///\n        /// This allows chaining together multiple subtractions to create a\n        /// wider subtraction, and can be useful for bignum subtraction. This\n        /// method should only be used for the most significant word; for the\n        /// less significant words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a borrow flag,\n        /// and should *not* be subtracted from a more significant word.\n        ///\n        /// If the input borrow is false, this method is equivalent to\n        /// [`overflowing_sub`](Self::overflowing_sub).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//    6    8    (a = 6  2^\", stringify!($BITS), \" + 8)\")]\n        #[doc = concat!(\"// - -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//   10  MAX    (diff = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let borrow0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(overflow, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_sub(rhs);\n            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` - `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_sub(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\")]\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.widening_mul(-2), (4294967286, -1));\n        /// assert_eq!(1_000_000_000i32.widening_mul(-10), (2884901888, -3));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul(-2, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul(-2, 10), (0, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 10), (2884901898, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX.unsigned_abs() + 1, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul_add(-2, 0, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul_add(-2, 10, 10), (10, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 0, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 10, 10), (2884901908, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($UnsignedT), \"::MAX, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> ($UnsignedT, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then `self` is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self.div_euclid(rhs), false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n\n        /// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }\n\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n        /// happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n        /// minimum value will be returned again and `true` will be returned for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\")]\n        /// assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n        /// happened. If self is the minimum value\n        #[doc = concat!(\"(e.g., \", stringify!($SelfT), \"::MIN for values of type \", stringify!($SelfT), \"),\")]\n        /// then the minimum value will be returned again and true will be returned\n        /// for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            (self.wrapping_abs(), self == Self::MIN)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\")]\n        /// assert_eq!(3i8.overflowing_pow(5), (-13, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0 {\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\")]\n        ///\n        /// assert_eq!(x.pow(5), 32);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn isqrt(self) -> Self {\n            match self.checked_isqrt() {\n                Some(sqrt) => sqrt,\n                None => crate::num::int_sqrt::panic_for_negative_argument(),\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division of `self` by `rhs`.\n        ///\n        /// This computes the integer `q` such that `self = q * rhs + r`, with\n        /// `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.\n        ///\n        /// In other words, the result is `self / rhs` rounded to the integer `q`\n        /// such that `self >= q * rhs`.\n        /// If `self > 0`, this is equal to rounding towards zero (the default in Rust);\n        /// if `self < 0`, this is equal to rounding away from zero (towards +/- infinity).\n        /// If `rhs > 0`, this is equal to rounding towards -infinity;\n        /// if `rhs < 0`, this is equal to rounding towards +infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n        /// assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n        /// assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n        /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            let q = self / rhs;\n            if self % rhs < 0 {\n                return if rhs > 0 { q - 1 } else { q + 1 }\n            }\n            q\n        }\n\n\n        /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n        ///\n        /// This is done as if by the Euclidean division algorithm -- given\n        /// `r = self.rem_euclid(rhs)`, the result satisfies\n        /// `self = rhs * self.div_euclid(rhs) + r` and `0 <= r < abs(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN` and\n        /// `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.rem_euclid(b), 3);\n        /// assert_eq!((-a).rem_euclid(b), 1);\n        /// assert_eq!(a.rem_euclid(-b), 3);\n        /// assert_eq!((-a).rem_euclid(-b), 1);\n        /// ```\n        ///\n        /// This will panic:\n        /// ```should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.rem_euclid(-1);\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_floor(b), 2);\n        /// assert_eq!(a.div_floor(-b), -3);\n        /// assert_eq!((-a).div_floor(b), -3);\n        /// assert_eq!((-a).div_floor(-b), 2);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // If the remainder is non-zero, we need to subtract one if the\n            // signs of self and rhs differ, as this means we rounded upwards\n            // instead of downwards. We do this branchlessly by creating a mask\n            // which is all-ones iff the signs differ, and 0 otherwise. Then by\n            // adding this mask (which corresponds to the signed value -1), we\n            // get our correction.\n            let correction = (self ^ rhs) >> (Self::BITS - 1);\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_ceil(b), 3);\n        /// assert_eq!(a.div_ceil(-b), -2);\n        /// assert_eq!((-a).div_ceil(b), -2);\n        /// assert_eq!((-a).div_ceil(-b), 3);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // When remainder is non-zero we have a.div_ceil(b) == 1 + a.div_floor(b),\n            // so we can re-use the algorithm from div_floor, just adding 1.\n            let correction = 1 + ((self ^ rhs) >> (Self::BITS - 1));\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return self;\n            }\n\n            let r = self % rhs;\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                self\n            } else {\n                self + (rhs - m)\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`. Returns `None` if `rhs` is zero or the operation\n        /// would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return Some(self);\n            }\n\n            let r = try_opt!(self.checked_rem(rhs));\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                // r + rhs cannot overflow because they have opposite signs\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                Some(self)\n            } else {\n                // rhs - m cannot overflow because m has the same sign as rhs\n                self.checked_add(rhs - m)\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero,\n        /// or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                // Delegate to the unsigned implementation.\n                // The condition makes sure that both casts are exact.\n                (self as $UnsignedT).checked_ilog(base as $UnsignedT)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            if self <= 0 {\n                None\n            } else {\n                // SAFETY: We just checked that this number is positive\n                let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };\n                Some(log)\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            if self > 0 {\n                Some(int_log10::$ActualT(self as $ActualT))\n            } else {\n                None\n            }\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// cannot be represented as an\n        #[doc = concat!(\"`\", stringify!($SelfT), \"`,\")]\n        /// and attempting to calculate it will cause an overflow. This means\n        /// that code in debug mode will trigger a panic on this case and\n        /// optimized code will return\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// without a panic. If you do not want this behavior, consider\n        /// using [`unsigned_abs`](Self::unsigned_abs) instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn abs(self) -> Self {\n            // Note that the #[rustc_inherit_overflow_checks] and #[inline]\n            // above mean that the overflow semantics of the subtraction\n            // depend on the crate we're being called from.\n            if self.is_negative() {\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// This function always returns the correct answer without overflow or\n        /// panics by returning an unsigned integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(80), 180\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(-120), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.abs_diff(\", stringify!($SelfT), \"::MAX), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> $UnsignedT {\n            if self < other {\n                // Converting a non-negative x from signed to unsigned by using\n                // `x as U` is left unchanged, but a negative x is converted\n                // to value x + 2^N. Thus if `s` and `o` are binary variables\n                // respectively indicating whether `self` and `other` are\n                // negative, we are computing the mathematical value:\n                //\n                //    (other + o*2^N) - (self + s*2^N)    mod  2^N\n                //    other - self + (o-s)*2^N            mod  2^N\n                //    other - self                        mod  2^N\n                //\n                // Finally, taking the mod 2^N of the mathematical value of\n                // `other - self` does not change it as it already is\n                // in the range [0, 2^N).\n                (other as $UnsignedT).wrapping_sub(self as $UnsignedT)\n            } else {\n                (self as $UnsignedT).wrapping_sub(other as $UnsignedT)\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        ///  - `0` if the number is zero\n        ///  - `1` if the number is positive\n        ///  - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n\n            crate::intrinsics::three_way_compare(self, 0) as Self\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number is zero or\n        /// negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(10\", stringify!($SelfT), \".is_positive());\")]\n        #[doc = concat!(\"assert!(!(-10\", stringify!($SelfT), \").is_positive());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number is zero or\n        /// positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!((-10\", stringify!($SelfT), \").is_negative());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_negative());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_negative(self) -> bool { self < 0 }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its memory representation as a byte\n        /// array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes)]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes)]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self {\n            Self::MIN\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self {\n            Self::MAX\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 99, name: \"core::num::<impl isize>::unchecked_neg\" }",
        "func": {
          "name": "core::num::<impl isize>::unchecked_neg",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$isize$GT$13unchecked_neg17hc7b2b12da9ac343bE",
          "kind": "Item",
          "file": "library/core/src/num/int_macros.rs",
          "src": "pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "int_impl! {\n        Self = isize,\n        ActualT = i64,\n        UnsignedT = usize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        Min = -9223372036854775808,\n        Max = 9223372036854775807,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! int_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        UnsignedT = $UnsignedT:ty,\n\n        // There are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        Min = $Min:literal,\n        Max = $Max:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type\n        #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = !Self::MAX;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = <$UnsignedT>::BITS;\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b100_0000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        ///\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -4\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (self as $UnsignedT).leading_ones()\n        }\n\n        /// Returns the number of trailing ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 3\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (self as $UnsignedT).trailing_ones()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as an unsigned integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_unsigned(), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_unsigned(self) -> $UnsignedT {\n            self as $UnsignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            (self as $UnsignedT).reverse_bits() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with an unsigned integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_unsigned(2), 3);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).strict_sub(1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with an unsigned integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict subtraction with an unsigned integer. Computes `self - rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub_unsigned(2), -1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.strict_mul(1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n        /// or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// returning `None` if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div_euclid(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div_euclid(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div_euclid(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None` if\n        /// `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean remainder. Computes `self.rem_euclid(rhs)`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem_euclid(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem_euclid(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem_euclid(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Unchecked negation. Computes `-self`, assuming overflow cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self == \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_neg`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_neg`]: \", stringify!($SelfT), \"::checked_neg\")]\n        #[unstable(\n            feature = \"unchecked_neg\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }\n\n        /// Strict negation. Computes `-self`, panicking if `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_neg(), -5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x1\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(128);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, which yields `0` for a positive number,\n        /// and `-1` for a negative number.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.unbounded_shr(129), -1);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                // A shift by `Self::BITS-1` suffices for signed integers, because the sign bit is copied for each of the shifted bits.\n\n                // SAFETY:\n                // `Self::BITS-1` is guaranteed to be less than `Self::BITS`\n                unsafe { self.unchecked_shr(Self::BITS - 1) }\n            }\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Strict absolute value. Computes `self.abs()`, panicking if\n        /// `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").strict_abs(), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_abs();\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_abs(self) -> Self {\n            if self.is_negative() {\n                self.strict_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".strict_pow(2), 64);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// Returns `None` if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_isqrt(), Some(3));\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_isqrt(self) -> Option<Self> {\n            if self < 0 {\n                None\n            } else {\n                // SAFETY: Input is nonnegative in this `else` branch.\n                let result = unsafe {\n                    crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT\n                };\n\n                // Inform the optimizer what the range of outputs is. If\n                // testing `core` crashes with no panic message and a\n                // `num::int_sqrt::i*` test failed, it's because your edits\n                // caused these assertions to become false.\n                //\n                // SAFETY: Integer square root is a monotonically nondecreasing\n                // function, which means that increasing the input will never\n                // cause the output to decrease. Thus, since the input for\n                // nonnegative signed integers is bounded by\n                // `[0, <$ActualT>::MAX]`, sqrt(n) will be bounded by\n                // `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n                unsafe {\n                    // SAFETY: `<$ActualT>::MAX` is nonnegative.\n                    const MAX_RESULT: $SelfT = unsafe {\n                        crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT\n                    };\n\n                    crate::hint::assert_unchecked(result >= 0);\n                    crate::hint::assert_unchecked(result <= MAX_RESULT);\n                }\n\n                Some(result)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n        /// bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the upper bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_add_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT), \"::MIN);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating subtraction with an unsigned integer. Computes `self - rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the lower bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_sub_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MIN,\n            }\n        }\n\n        /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n        /// instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_neg(self) -> Self {\n            intrinsics::saturating_sub(0, self)\n        }\n\n        /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n        /// MIN` instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            if self.is_negative() {\n                self.saturating_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => if (self < 0) == (rhs < 0) {\n                    Self::MAX\n                } else {\n                    Self::MIN\n                }\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_div(-1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_div(-1), \", stringify!($SelfT), \"::MAX);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            match self.overflowing_div(rhs) {\n                (result, false) => result,\n                (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None if self < 0 && exp % 2 == 1 => Self::MIN,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with an unsigned integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with an unsigned integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\")]\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n        /// type. In this case, this method returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self.overflowing_div_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n        /// invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n        /// this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n        /// at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). In this case, this method returns 0.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self.overflowing_rem_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        /// The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n        /// is the negative minimal value for the type); this is a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n        /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n        /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n        /// The primitive integer types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n        /// removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n        /// to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n        /// end. The primitive integer types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\")]\n        /// assert_eq!((-128i16).wrapping_shr(64), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n        /// minimal value for the type; this is a positive value that is too large to represent in the type. In\n        /// such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT), \"::MIN);\")]\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }\n\n        /// Computes the absolute value of `self` without any wrapping\n        /// or panicking.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        /// assert_eq!((-128i8).unsigned_abs(), 128u8);\n        /// ```\n        #[stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[rustc_const_stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\")]\n        /// assert_eq!(3i8.wrapping_pow(5), -13);\n        /// assert_eq!(3i8.wrapping_pow(6), -39);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would have\n        /// occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns a tuple of the sum along with a boolean indicating\n        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n        /// value is returned.\n        ///\n        /// This allows chaining together multiple additions to create a wider\n        /// addition, and can be useful for bignum addition. This method should\n        /// only be used for the most significant word; for the less significant\n        /// words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a carry flag,\n        /// and should *not* be added to a more significant word.\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//   10  MAX    (a = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// + -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//    6    8    (sum = 6  2^\", stringify!($BITS), \" + 8)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let carry0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(overflow, false);\n        ///\n        /// assert_eq!((sum1, sum0), (6, 8));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_add(rhs);\n            let (c, d) = a.overflowing_add(carry as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` + `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_add(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n        /// overflow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns a tuple of the\n        /// difference along with a boolean indicating whether an arithmetic\n        /// overflow would occur. On overflow, the wrapped value is returned.\n        ///\n        /// This allows chaining together multiple subtractions to create a\n        /// wider subtraction, and can be useful for bignum subtraction. This\n        /// method should only be used for the most significant word; for the\n        /// less significant words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a borrow flag,\n        /// and should *not* be subtracted from a more significant word.\n        ///\n        /// If the input borrow is false, this method is equivalent to\n        /// [`overflowing_sub`](Self::overflowing_sub).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//    6    8    (a = 6  2^\", stringify!($BITS), \" + 8)\")]\n        #[doc = concat!(\"// - -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//   10  MAX    (diff = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let borrow0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(overflow, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_sub(rhs);\n            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` - `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_sub(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\")]\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.widening_mul(-2), (4294967286, -1));\n        /// assert_eq!(1_000_000_000i32.widening_mul(-10), (2884901888, -3));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul(-2, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul(-2, 10), (0, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 10), (2884901898, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX.unsigned_abs() + 1, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul_add(-2, 0, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul_add(-2, 10, 10), (10, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 0, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 10, 10), (2884901908, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($UnsignedT), \"::MAX, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> ($UnsignedT, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then `self` is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self.div_euclid(rhs), false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n\n        /// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }\n\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n        /// happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n        /// minimum value will be returned again and `true` will be returned for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\")]\n        /// assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n        /// happened. If self is the minimum value\n        #[doc = concat!(\"(e.g., \", stringify!($SelfT), \"::MIN for values of type \", stringify!($SelfT), \"),\")]\n        /// then the minimum value will be returned again and true will be returned\n        /// for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            (self.wrapping_abs(), self == Self::MIN)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\")]\n        /// assert_eq!(3i8.overflowing_pow(5), (-13, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0 {\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\")]\n        ///\n        /// assert_eq!(x.pow(5), 32);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn isqrt(self) -> Self {\n            match self.checked_isqrt() {\n                Some(sqrt) => sqrt,\n                None => crate::num::int_sqrt::panic_for_negative_argument(),\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division of `self` by `rhs`.\n        ///\n        /// This computes the integer `q` such that `self = q * rhs + r`, with\n        /// `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.\n        ///\n        /// In other words, the result is `self / rhs` rounded to the integer `q`\n        /// such that `self >= q * rhs`.\n        /// If `self > 0`, this is equal to rounding towards zero (the default in Rust);\n        /// if `self < 0`, this is equal to rounding away from zero (towards +/- infinity).\n        /// If `rhs > 0`, this is equal to rounding towards -infinity;\n        /// if `rhs < 0`, this is equal to rounding towards +infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n        /// assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n        /// assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n        /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            let q = self / rhs;\n            if self % rhs < 0 {\n                return if rhs > 0 { q - 1 } else { q + 1 }\n            }\n            q\n        }\n\n\n        /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n        ///\n        /// This is done as if by the Euclidean division algorithm -- given\n        /// `r = self.rem_euclid(rhs)`, the result satisfies\n        /// `self = rhs * self.div_euclid(rhs) + r` and `0 <= r < abs(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN` and\n        /// `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.rem_euclid(b), 3);\n        /// assert_eq!((-a).rem_euclid(b), 1);\n        /// assert_eq!(a.rem_euclid(-b), 3);\n        /// assert_eq!((-a).rem_euclid(-b), 1);\n        /// ```\n        ///\n        /// This will panic:\n        /// ```should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.rem_euclid(-1);\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_floor(b), 2);\n        /// assert_eq!(a.div_floor(-b), -3);\n        /// assert_eq!((-a).div_floor(b), -3);\n        /// assert_eq!((-a).div_floor(-b), 2);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // If the remainder is non-zero, we need to subtract one if the\n            // signs of self and rhs differ, as this means we rounded upwards\n            // instead of downwards. We do this branchlessly by creating a mask\n            // which is all-ones iff the signs differ, and 0 otherwise. Then by\n            // adding this mask (which corresponds to the signed value -1), we\n            // get our correction.\n            let correction = (self ^ rhs) >> (Self::BITS - 1);\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_ceil(b), 3);\n        /// assert_eq!(a.div_ceil(-b), -2);\n        /// assert_eq!((-a).div_ceil(b), -2);\n        /// assert_eq!((-a).div_ceil(-b), 3);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // When remainder is non-zero we have a.div_ceil(b) == 1 + a.div_floor(b),\n            // so we can re-use the algorithm from div_floor, just adding 1.\n            let correction = 1 + ((self ^ rhs) >> (Self::BITS - 1));\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return self;\n            }\n\n            let r = self % rhs;\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                self\n            } else {\n                self + (rhs - m)\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`. Returns `None` if `rhs` is zero or the operation\n        /// would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return Some(self);\n            }\n\n            let r = try_opt!(self.checked_rem(rhs));\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                // r + rhs cannot overflow because they have opposite signs\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                Some(self)\n            } else {\n                // rhs - m cannot overflow because m has the same sign as rhs\n                self.checked_add(rhs - m)\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero,\n        /// or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                // Delegate to the unsigned implementation.\n                // The condition makes sure that both casts are exact.\n                (self as $UnsignedT).checked_ilog(base as $UnsignedT)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            if self <= 0 {\n                None\n            } else {\n                // SAFETY: We just checked that this number is positive\n                let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };\n                Some(log)\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            if self > 0 {\n                Some(int_log10::$ActualT(self as $ActualT))\n            } else {\n                None\n            }\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// cannot be represented as an\n        #[doc = concat!(\"`\", stringify!($SelfT), \"`,\")]\n        /// and attempting to calculate it will cause an overflow. This means\n        /// that code in debug mode will trigger a panic on this case and\n        /// optimized code will return\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// without a panic. If you do not want this behavior, consider\n        /// using [`unsigned_abs`](Self::unsigned_abs) instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn abs(self) -> Self {\n            // Note that the #[rustc_inherit_overflow_checks] and #[inline]\n            // above mean that the overflow semantics of the subtraction\n            // depend on the crate we're being called from.\n            if self.is_negative() {\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// This function always returns the correct answer without overflow or\n        /// panics by returning an unsigned integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(80), 180\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(-120), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.abs_diff(\", stringify!($SelfT), \"::MAX), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> $UnsignedT {\n            if self < other {\n                // Converting a non-negative x from signed to unsigned by using\n                // `x as U` is left unchanged, but a negative x is converted\n                // to value x + 2^N. Thus if `s` and `o` are binary variables\n                // respectively indicating whether `self` and `other` are\n                // negative, we are computing the mathematical value:\n                //\n                //    (other + o*2^N) - (self + s*2^N)    mod  2^N\n                //    other - self + (o-s)*2^N            mod  2^N\n                //    other - self                        mod  2^N\n                //\n                // Finally, taking the mod 2^N of the mathematical value of\n                // `other - self` does not change it as it already is\n                // in the range [0, 2^N).\n                (other as $UnsignedT).wrapping_sub(self as $UnsignedT)\n            } else {\n                (self as $UnsignedT).wrapping_sub(other as $UnsignedT)\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        ///  - `0` if the number is zero\n        ///  - `1` if the number is positive\n        ///  - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n\n            crate::intrinsics::three_way_compare(self, 0) as Self\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number is zero or\n        /// negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(10\", stringify!($SelfT), \".is_positive());\")]\n        #[doc = concat!(\"assert!(!(-10\", stringify!($SelfT), \").is_positive());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number is zero or\n        /// positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!((-10\", stringify!($SelfT), \").is_negative());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_negative());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_negative(self) -> bool { self < 0 }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its memory representation as a byte\n        /// array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes)]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes)]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self {\n            Self::MIN\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self {\n            Self::MAX\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 101, name: \"core::num::<impl isize>::unchecked_neg::precondition_check\" }",
        "func": {
          "name": "core::num::<impl isize>::unchecked_neg::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$isize$GT$13unchecked_neg18precondition_check17hf8d4f8167caedff9E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "int_impl! {\n        Self = isize,\n        ActualT = i64,\n        UnsignedT = usize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        Min = -9223372036854775808,\n        Max = 9223372036854775807,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! int_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        UnsignedT = $UnsignedT:ty,\n\n        // There are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        Min = $Min:literal,\n        Max = $Max:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type\n        #[doc = concat!(\"(&minus;2<sup>\", $BITS_MINUS_ONE, \"</sup>\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, \", stringify!($Min), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = !Self::MAX;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS_MINUS_ONE, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($Max), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = (<$UnsignedT>::MAX >> 1) as Self;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = <$UnsignedT>::BITS;\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b100_0000\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.count_ones(), 1);\n        /// ```\n        ///\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 { (self as $UnsignedT).count_ones() }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.count_zeros(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            (self as $UnsignedT).leading_zeros()\n        }\n\n        /// Returns the number of trailing zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -4\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_zeros(), 2);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            (self as $UnsignedT).trailing_zeros()\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (self as $UnsignedT).leading_ones()\n        }\n\n        /// Returns the number of trailing ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 3\", stringify!($SelfT), \";\")]\n        ///\n        /// assert_eq!(n.trailing_ones(), 2);\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (self as $UnsignedT).trailing_ones()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as an unsigned integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        ///\n        #[doc = concat!(\"let n = -1\", stringify!($SelfT), \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_unsigned(), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_unsigned(self) -> $UnsignedT {\n            self as $UnsignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_left(n) as Self\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            (self as $UnsignedT).rotate_right(n) as Self\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        ///\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            (self as $UnsignedT).swap_bytes() as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            (self as $UnsignedT).reverse_bits() as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversions\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), Some(\", stringify!($SelfT), \"::MAX - 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_add(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with an unsigned integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_unsigned(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with an unsigned integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_unsigned(2), 3);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_add_unsigned(rhs);\n            if b { overflow_panic::add() } else { a }\n        }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(1), Some(\", stringify!($SelfT), \"::MIN + 1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_sub(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).strict_sub(1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with an unsigned integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_unsigned(2), Some(-1));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).checked_sub_unsigned(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_unsigned(self, rhs: $UnsignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict subtraction with an unsigned integer. Computes `self - rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub_unsigned(2), -1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MIN + 2).strict_sub_unsigned(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            let (a, b) = self.overflowing_sub_unsigned(rhs);\n            if b { overflow_panic::sub() } else { a }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(1), Some(\", stringify!($SelfT), \"::MAX));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.strict_mul(1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n        }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None` if `rhs == 0`\n        /// or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// returning `None` if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).checked_div_euclid(-1), Some(\", stringify!($Max), \"));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_div_euclid(-1), None);\")]\n        #[doc = concat!(\"assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).strict_div_euclid(-1), \", stringify!($Max), \");\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_div_euclid(-1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_div_euclid(rhs);\n            if b { overflow_panic::div() } else { a }\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None` if\n        /// `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) && (rhs == -1))) {\n                None\n            } else {\n                // SAFETY: div by zero and by INT_MIN have been checked above\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked Euclidean remainder. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0` or the division results in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely(rhs == 0 || ((self == Self::MIN) & (rhs == -1))) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean remainder. Computes `self.rem_euclid(rhs)`, panicking if\n        /// the division results in overflow.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// The only case where such an overflow can occur is `x % y` for `MIN / -1` on a\n        /// signed type (where `MIN` is the negative minimal value), which is invalid due to implementation artifacts.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_rem_euclid(2), 1);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_rem_euclid(-1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_rem_euclid(rhs);\n            if b { overflow_panic::rem() } else { a }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` if `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_neg(), Some(-5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Unchecked negation. Computes `-self`, assuming overflow cannot occur.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self == \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_neg`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_neg`]: \", stringify!($SelfT), \"::checked_neg\")]\n        #[unstable(\n            feature = \"unchecked_neg\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_neg(self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_neg cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                ) => !lhs.overflowing_neg().1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(0, self)\n            }\n        }\n\n        /// Strict negation. Computes `-self`, panicking if `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_neg(), -5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None` if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x1\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None` if `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(128);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, which yields `0` for a positive number,\n        /// and `-1` for a negative number.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.unbounded_shr(129), -1);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                // A shift by `Self::BITS-1` suffices for signed integers, because the sign bit is copied for each of the shifted bits.\n\n                // SAFETY:\n                // `Self::BITS-1` is guaranteed to be less than `Self::BITS`\n                unsafe { self.unchecked_shr(Self::BITS - 1) }\n            }\n        }\n\n        /// Checked absolute value. Computes `self.abs()`, returning `None` if\n        /// `self == MIN`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").checked_abs(), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.checked_abs(), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_abs(self) -> Option<Self> {\n            if self.is_negative() {\n                self.checked_neg()\n            } else {\n                Some(self)\n            }\n        }\n\n        /// Strict absolute value. Computes `self.abs()`, panicking if\n        /// `self == MIN`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((-5\", stringify!($SelfT), \").strict_abs(), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.strict_abs();\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_abs(self) -> Self {\n            if self.is_negative() {\n                self.strict_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".checked_pow(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(8\", stringify!($SelfT), \".strict_pow(2), 64);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// Returns `None` if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_isqrt(), Some(3));\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_isqrt(self) -> Option<Self> {\n            if self < 0 {\n                None\n            } else {\n                // SAFETY: Input is nonnegative in this `else` branch.\n                let result = unsafe {\n                    crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT\n                };\n\n                // Inform the optimizer what the range of outputs is. If\n                // testing `core` crashes with no panic message and a\n                // `num::int_sqrt::i*` test failed, it's because your edits\n                // caused these assertions to become false.\n                //\n                // SAFETY: Integer square root is a monotonically nondecreasing\n                // function, which means that increasing the input will never\n                // cause the output to decrease. Thus, since the input for\n                // nonnegative signed integers is bounded by\n                // `[0, <$ActualT>::MAX]`, sqrt(n) will be bounded by\n                // `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n                unsafe {\n                    // SAFETY: `<$ActualT>::MAX` is nonnegative.\n                    const MAX_RESULT: $SelfT = unsafe {\n                        crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT\n                    };\n\n                    crate::hint::assert_unchecked(result >= 0);\n                    crate::hint::assert_unchecked(result <= MAX_RESULT);\n                }\n\n                Some(result)\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at the numeric\n        /// bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(100), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_add(-1), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with an unsigned integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_unsigned(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add_unsigned(100), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the upper bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_add_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub(100), \", stringify!($SelfT), \"::MIN);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_sub(-1), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating subtraction with an unsigned integer. Computes `self - rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub_unsigned(127), -27);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_sub_unsigned(100), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            // Overflow can only happen at the lower bound\n            // We cannot use `unwrap_or` here because it is not `const`\n            match self.checked_sub_unsigned(rhs) {\n                Some(x) => x,\n                None => Self::MIN,\n            }\n        }\n\n        /// Saturating integer negation. Computes `-self`, returning `MAX` if `self == MIN`\n        /// instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_neg(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_neg(), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn saturating_neg(self) -> Self {\n            intrinsics::saturating_sub(0, self)\n        }\n\n        /// Saturating absolute value. Computes `self.abs()`, returning `MAX` if `self ==\n        /// MIN` instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").saturating_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 1).saturating_abs(), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n\n        #[stable(feature = \"saturating_neg\", since = \"1.45.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_abs(self) -> Self {\n            if self.is_negative() {\n                self.saturating_neg()\n            } else {\n                self\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".saturating_mul(12), 120);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_mul(10), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => if (self < 0) == (rhs < 0) {\n                    Self::MAX\n                } else {\n                    Self::MIN\n                }\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_div(-1), \", stringify!($SelfT), \"::MIN + 1);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_div(-1), \", stringify!($SelfT), \"::MAX);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            match self.overflowing_div(rhs) {\n                (result, false) => result,\n                (_result, true) => Self::MAX, // MIN / -1 is the only possible saturating overflow\n            }\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-4\", stringify!($SelfT), \").saturating_pow(3), -64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None if self < 0 && exp % 2 == 1 => Self::MIN,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with an unsigned integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_add_unsigned(27), 127);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_add_unsigned(2), \", stringify!($SelfT), \"::MIN + 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub(\", stringify!($SelfT), \"::MAX), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with an unsigned integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".wrapping_sub_unsigned(127), -127);\")]\n        #[doc = concat!(\"assert_eq!((-2\", stringify!($SelfT), \").wrapping_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), -1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub_unsigned(self, rhs: $UnsignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self * rhs`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".wrapping_mul(12), 120);\")]\n        /// assert_eq!(11i8.wrapping_mul(12), -124);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one divides `MIN / -1` on a signed type (where\n        /// `MIN` is the negative minimal value for the type); this is equivalent to `-MIN`, a positive value\n        /// that is too large to represent in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div(-1), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self.overflowing_div(rhs).0\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN / -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). This is equivalent to `-MIN`, a positive value that is too large to represent in the\n        /// type. In this case, this method returns `MIN` itself.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self.overflowing_div_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`, wrapping around at the\n        /// boundary of the type.\n        ///\n        /// Such wrap-around never actually occurs mathematically; implementation artifacts make `x % y`\n        /// invalid for `MIN / -1` on a signed type (where `MIN` is the negative minimal value). In such a case,\n        /// this function returns `0`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem(-1), 0);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self.overflowing_rem(rhs).0\n        }\n\n        /// Wrapping Euclidean remainder. Computes `self.rem_euclid(rhs)`, wrapping around\n        /// at the boundary of the type.\n        ///\n        /// Wrapping will only occur in `MIN % -1` on a signed type (where `MIN` is the negative minimal value\n        /// for the type). In this case, this method returns 0.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self.overflowing_rem_euclid(rhs).0\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`, wrapping around at the boundary\n        /// of the type.\n        ///\n        /// The only case where such wrapping can occur is when one negates `MIN` on a signed type (where `MIN`\n        /// is the negative minimal value for the type); this is a positive value that is too large to represent\n        /// in the type. In such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_neg(), -100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_neg(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_neg(), \", stringify!($SelfT), \"::MIN);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`, where `mask` removes\n        /// any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the RHS of a wrapping shift-left is restricted to\n        /// the range of the type, rather than the bits shifted out of the LHS being returned to the other end.\n        /// The primitive integer types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(7), -128);\")]\n        #[doc = concat!(\"assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`, where `mask`\n        /// removes any high-order bits of `rhs` that would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the RHS of a wrapping shift-right is restricted\n        /// to the range of the type, rather than the bits shifted out of the LHS being returned to the other\n        /// end. The primitive integer types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!((-128\", stringify!($SelfT), \").wrapping_shr(7), -1);\")]\n        /// assert_eq!((-128i16).wrapping_shr(64), -128);\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) absolute value. Computes `self.abs()`, wrapping around at\n        /// the boundary of the type.\n        ///\n        /// The only case where such wrapping can occur is when one takes the absolute value of the negative\n        /// minimal value for the type; this is a positive value that is too large to represent in the type. In\n        /// such a case, this function returns `MIN` itself.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").wrapping_abs(), 100);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.wrapping_abs(), \", stringify!($SelfT), \"::MIN);\")]\n        /// assert_eq!((-128i8).wrapping_abs() as u8, 128);\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        #[inline]\n        pub const fn wrapping_abs(self) -> Self {\n             if self.is_negative() {\n                 self.wrapping_neg()\n             } else {\n                 self\n             }\n        }\n\n        /// Computes the absolute value of `self` without any wrapping\n        /// or panicking.\n        ///\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").unsigned_abs(), 100\", stringify!($UnsignedT), \");\")]\n        /// assert_eq!((-128i8).unsigned_abs(), 128u8);\n        /// ```\n        #[stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[rustc_const_stable(feature = \"unsigned_abs\", since = \"1.51.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unsigned_abs(self) -> $UnsignedT {\n             self.wrapping_abs() as $UnsignedT\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(4), 81);\")]\n        /// assert_eq!(3i8.wrapping_pow(5), -13);\n        /// assert_eq!(3i8.wrapping_pow(6), -39);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would have\n        /// occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and checks for overflow.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns a tuple of the sum along with a boolean indicating\n        /// whether an arithmetic overflow would occur. On overflow, the wrapped\n        /// value is returned.\n        ///\n        /// This allows chaining together multiple additions to create a wider\n        /// addition, and can be useful for bignum addition. This method should\n        /// only be used for the most significant word; for the less significant\n        /// words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::carrying_add`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a carry flag,\n        /// and should *not* be added to a more significant word.\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//   10  MAX    (a = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// + -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//    6    8    (sum = 6  2^\", stringify!($BITS), \" + 8)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (10, \", stringify!($UnsignedT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let carry0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::carrying_add for the less significant words\")]\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::carrying_add for the most significant word\")]\n        /// let (sum1, overflow) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(overflow, false);\n        ///\n        /// assert_eq!((sum1, sum0), (6, 8));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_add(rhs);\n            let (c, d) = a.overflowing_add(carry as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` + `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_unsigned(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_add_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MAX, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_unsigned(3), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_add(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and checks for\n        /// overflow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns a tuple of the\n        /// difference along with a boolean indicating whether an arithmetic\n        /// overflow would occur. On overflow, the wrapped value is returned.\n        ///\n        /// This allows chaining together multiple subtractions to create a\n        /// wider subtraction, and can be useful for bignum subtraction. This\n        /// method should only be used for the most significant word; for the\n        /// less significant words the unsigned method\n        #[doc = concat!(\"[`\", stringify!($UnsignedT), \"::borrowing_sub`]\")]\n        /// should be used.\n        ///\n        /// The output boolean returned by this method is *not* a borrow flag,\n        /// and should *not* be subtracted from a more significant word.\n        ///\n        /// If the input borrow is false, this method is equivalent to\n        /// [`overflowing_sub`](Self::overflowing_sub).\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// // Only the most significant word is signed.\n        /// //\n        #[doc = concat!(\"//    6    8    (a = 6  2^\", stringify!($BITS), \" + 8)\")]\n        #[doc = concat!(\"// - -5    9    (b = -5  2^\", stringify!($BITS), \" + 9)\")]\n        /// // ---------\n        #[doc = concat!(\"//   10  MAX    (diff = 10  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (6, 8);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($UnsignedT), \") = (-5, 9);\")]\n        /// let borrow0 = false;\n        ///\n        #[doc = concat!(\"// \", stringify!($UnsignedT), \"::borrowing_sub for the less significant words\")]\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        ///\n        #[doc = concat!(\"// \", stringify!($SelfT), \"::borrowing_sub for the most significant word\")]\n        /// let (diff1, overflow) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(overflow, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (10, \", stringify!($UnsignedT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic.\n            // note: no intermediate overflow is required (https://github.com/rust-lang/rust/issues/85532#issuecomment-1032214946).\n            let (a, b) = self.overflowing_sub(rhs);\n            let (c, d) = a.overflowing_sub(borrow as $SelfT);\n            (c, b != d)\n        }\n\n        /// Calculates `self` - `rhs` with an unsigned `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_unsigned(2), (-1, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).overflowing_sub_unsigned(\", stringify!($UnsignedT), \"::MAX), (\", stringify!($SelfT), \"::MIN, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN + 2).overflowing_sub_unsigned(3), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_unsigned(self, rhs: $UnsignedT) -> (Self, bool) {\n            let rhs = rhs as Self;\n            let (res, overflowed) = self.overflowing_sub(rhs);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean indicating whether an arithmetic overflow\n        /// would occur. If an overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_mul(2), (10, false));\")]\n        /// assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.widening_mul(-2), (4294967286, -1));\n        /// assert_eq!(1_000_000_000i32.widening_mul(-10), (2884901888, -3));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul(-2, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul(-2, 10), (0, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul(-10, 10), (2884901898, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX.unsigned_abs() + 1, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> ($UnsignedT, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `i32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5i32.carrying_mul_add(-2, 0, 0), (4294967286, -1));\n        /// assert_eq!(5i32.carrying_mul_add(-2, 10, 10), (10, 0));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 0, 0), (2884901888, -3));\n        /// assert_eq!(1_000_000_000i32.carrying_mul_add(-10, 10, 10), (2884901908, -3));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($UnsignedT), \"::MAX, \", stringify!($SelfT), \"::MAX / 2));\"\n        )]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> ($UnsignedT, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then self is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self / rhs, false)\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating whether an arithmetic overflow would\n        /// occur. If an overflow would occur then `self` is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            // Using `&` helps LLVM see that it is the same check made in division.\n            if intrinsics::unlikely((self == Self::MIN) & (rhs == -1)) {\n                (self, true)\n            } else {\n                (self.div_euclid(rhs), false)\n            }\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem(-1), (0, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self % rhs, false)\n            }\n        }\n\n\n        /// Overflowing Euclidean remainder. Calculates `self.rem_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean indicating whether an\n        /// arithmetic overflow would occur. If an overflow would occur then 0 is returned.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            if intrinsics::unlikely(rhs == -1) {\n                (0, self == Self::MIN)\n            } else {\n                (self.rem_euclid(rhs), false)\n            }\n        }\n\n\n        /// Negates self, overflowing if this is equal to the minimum value.\n        ///\n        /// Returns a tuple of the negated version of self along with a boolean indicating whether an overflow\n        /// happened. If `self` is the minimum value (e.g., `i32::MIN` for values of type `i32`), then the\n        /// minimum value will be returned again and `true` will be returned for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_neg(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[allow(unused_attributes)]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            if intrinsics::unlikely(self == Self::MIN) {\n                (Self::MIN, true)\n            } else {\n                (-self, false)\n            }\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT),\".overflowing_shl(4), (0x10, false));\")]\n        /// assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean indicating whether the shift\n        /// value was larger than or equal to the number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        /// assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// Returns a tuple of the absolute version of self along with a boolean indicating whether an overflow\n        /// happened. If self is the minimum value\n        #[doc = concat!(\"(e.g., \", stringify!($SelfT), \"::MIN for values of type \", stringify!($SelfT), \"),\")]\n        /// then the minimum value will be returned again and true will be returned\n        /// for an overflow happening.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").overflowing_abs(), (10, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MIN).overflowing_abs(), (\", stringify!($SelfT), \"::MIN, true));\")]\n        /// ```\n        #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_abs(self) -> (Self, bool) {\n            (self.wrapping_abs(), self == Self::MIN)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(4), (81, false));\")]\n        /// assert_eq!(3i8.overflowing_pow(5), (-13, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0 {\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let x: \", stringify!($SelfT), \" = 2; // or any other integer type\")]\n        ///\n        /// assert_eq!(x.pow(5), 32);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn isqrt(self) -> Self {\n            match self.checked_isqrt() {\n                Some(sqrt) => sqrt,\n                None => crate::num::int_sqrt::panic_for_negative_argument(),\n            }\n        }\n\n        /// Calculates the quotient of Euclidean division of `self` by `rhs`.\n        ///\n        /// This computes the integer `q` such that `self = q * rhs + r`, with\n        /// `r = self.rem_euclid(rhs)` and `0 <= r < abs(rhs)`.\n        ///\n        /// In other words, the result is `self / rhs` rounded to the integer `q`\n        /// such that `self >= q * rhs`.\n        /// If `self > 0`, this is equal to rounding towards zero (the default in Rust);\n        /// if `self < 0`, this is equal to rounding away from zero (towards +/- infinity).\n        /// If `rhs > 0`, this is equal to rounding towards -infinity;\n        /// if `rhs < 0`, this is equal to rounding towards +infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.div_euclid(b), 1); // 7 >= 4 * 1\n        /// assert_eq!(a.div_euclid(-b), -1); // 7 >= -4 * -1\n        /// assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n        /// assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            let q = self / rhs;\n            if self % rhs < 0 {\n                return if rhs > 0 { q - 1 } else { q + 1 }\n            }\n            q\n        }\n\n\n        /// Calculates the least nonnegative remainder of `self (mod rhs)`.\n        ///\n        /// This is done as if by the Euclidean division algorithm -- given\n        /// `r = self.rem_euclid(rhs)`, the result satisfies\n        /// `self = rhs * self.div_euclid(rhs) + r` and `0 <= r < abs(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN` and\n        /// `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let a: \", stringify!($SelfT), \" = 7; // or any other integer type\")]\n        /// let b = 4;\n        ///\n        /// assert_eq!(a.rem_euclid(b), 3);\n        /// assert_eq!((-a).rem_euclid(b), 1);\n        /// assert_eq!(a.rem_euclid(-b), 3);\n        /// assert_eq!((-a).rem_euclid(-b), 1);\n        /// ```\n        ///\n        /// This will panic:\n        /// ```should_panic\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MIN.rem_euclid(-1);\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            let r = self % rhs;\n            if r < 0 {\n                // Semantically equivalent to `if rhs < 0 { r - rhs } else { r + rhs }`.\n                // If `rhs` is not `Self::MIN`, then `r + abs(rhs)` will not overflow\n                // and is clearly equivalent, because `r` is negative.\n                // Otherwise, `rhs` is `Self::MIN`, then we have\n                // `r.wrapping_add(Self::MIN.wrapping_abs())`, which evaluates\n                // to `r.wrapping_add(Self::MIN)`, which is equivalent to\n                // `r - Self::MIN`, which is what we wanted (and will not overflow\n                // for negative `r`).\n                r.wrapping_add(rhs.wrapping_abs())\n            } else {\n                r\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_floor(b), 2);\n        /// assert_eq!(a.div_floor(-b), -3);\n        /// assert_eq!((-a).div_floor(b), -3);\n        /// assert_eq!((-a).div_floor(-b), 2);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // If the remainder is non-zero, we need to subtract one if the\n            // signs of self and rhs differ, as this means we rounded upwards\n            // instead of downwards. We do this branchlessly by creating a mask\n            // which is all-ones iff the signs differ, and 0 otherwise. Then by\n            // adding this mask (which corresponds to the signed value -1), we\n            // get our correction.\n            let correction = (self ^ rhs) >> (Self::BITS - 1);\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero or if `self` is `Self::MIN`\n        /// and `rhs` is -1. This behavior is not affected by the `overflow-checks` flag.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n        /// let b = 3;\n        ///\n        /// assert_eq!(a.div_ceil(b), 3);\n        /// assert_eq!(a.div_ceil(-b), -2);\n        /// assert_eq!((-a).div_ceil(b), -2);\n        /// assert_eq!((-a).div_ceil(-b), 3);\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n\n            // When remainder is non-zero we have a.div_ceil(b) == 1 + a.div_floor(b),\n            // so we can re-use the algorithm from div_floor, just adding 1.\n            let correction = 1 + ((self ^ rhs) >> (Self::BITS - 1));\n            if r != 0 {\n                d + correction\n            } else {\n                d\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return self;\n            }\n\n            let r = self % rhs;\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                self\n            } else {\n                self + (rhs - m)\n            }\n        }\n\n        /// If `rhs` is positive, calculates the smallest value greater than or\n        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n        /// calculates the largest value less than or equal to `self` that is a\n        /// multiple of `rhs`. Returns `None` if `rhs` is zero or the operation\n        /// would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-16));\")]\n        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            // This would otherwise fail when calculating `r` when self == T::MIN.\n            if rhs == -1 {\n                return Some(self);\n            }\n\n            let r = try_opt!(self.checked_rem(rhs));\n            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n                // r + rhs cannot overflow because they have opposite signs\n                r + rhs\n            } else {\n                r\n            };\n\n            if m == 0 {\n                Some(self)\n            } else {\n                // rhs - m cannot overflow because m has the same sign as rhs\n                self.checked_add(rhs - m)\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero,\n        /// or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is less than or equal to zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else {\n                // Delegate to the unsigned implementation.\n                // The condition makes sure that both casts are exact.\n                (self as $UnsignedT).checked_ilog(base as $UnsignedT)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            if self <= 0 {\n                None\n            } else {\n                // SAFETY: We just checked that this number is positive\n                let log = (Self::BITS - 1) - unsafe { intrinsics::ctlz_nonzero(self) as u32 };\n                Some(log)\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is negative or zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            if self > 0 {\n                Some(int_log10::$ActualT(self as $ActualT))\n            } else {\n                None\n            }\n        }\n\n        /// Computes the absolute value of `self`.\n        ///\n        /// # Overflow behavior\n        ///\n        /// The absolute value of\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// cannot be represented as an\n        #[doc = concat!(\"`\", stringify!($SelfT), \"`,\")]\n        /// and attempting to calculate it will cause an overflow. This means\n        /// that code in debug mode will trigger a panic on this case and\n        /// optimized code will return\n        #[doc = concat!(\"`\", stringify!($SelfT), \"::MIN`\")]\n        /// without a panic. If you do not want this behavior, consider\n        /// using [`unsigned_abs`](Self::unsigned_abs) instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".abs(), 10);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").abs(), 10);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[allow(unused_attributes)]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn abs(self) -> Self {\n            // Note that the #[rustc_inherit_overflow_checks] and #[inline]\n            // above mean that the overflow semantics of the subtraction\n            // depend on the crate we're being called from.\n            if self.is_negative() {\n                -self\n            } else {\n                self\n            }\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// This function always returns the correct answer without overflow or\n        /// panics by returning an unsigned integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(80), 180\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!((-100\", stringify!($SelfT), \").abs_diff(-120), 20\", stringify!($UnsignedT), \");\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN.abs_diff(\", stringify!($SelfT), \"::MAX), \", stringify!($UnsignedT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> $UnsignedT {\n            if self < other {\n                // Converting a non-negative x from signed to unsigned by using\n                // `x as U` is left unchanged, but a negative x is converted\n                // to value x + 2^N. Thus if `s` and `o` are binary variables\n                // respectively indicating whether `self` and `other` are\n                // negative, we are computing the mathematical value:\n                //\n                //    (other + o*2^N) - (self + s*2^N)    mod  2^N\n                //    other - self + (o-s)*2^N            mod  2^N\n                //    other - self                        mod  2^N\n                //\n                // Finally, taking the mod 2^N of the mathematical value of\n                // `other - self` does not change it as it already is\n                // in the range [0, 2^N).\n                (other as $UnsignedT).wrapping_sub(self as $UnsignedT)\n            } else {\n                (self as $UnsignedT).wrapping_sub(other as $UnsignedT)\n            }\n        }\n\n        /// Returns a number representing sign of `self`.\n        ///\n        ///  - `0` if the number is zero\n        ///  - `1` if the number is positive\n        ///  - `-1` if the number is negative\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".signum(), 1);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".signum(), 0);\")]\n        #[doc = concat!(\"assert_eq!((-10\", stringify!($SelfT), \").signum(), -1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_sign\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn signum(self) -> Self {\n            // Picking the right way to phrase this is complicated\n            // (<https://graphics.stanford.edu/~seander/bithacks.html#CopyIntegerSign>)\n            // so delegate it to `Ord` which is already producing -1/0/+1\n            // exactly like we need and can be the place to deal with the complexity.\n\n            crate::intrinsics::three_way_compare(self, 0) as Self\n        }\n\n        /// Returns `true` if `self` is positive and `false` if the number is zero or\n        /// negative.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(10\", stringify!($SelfT), \".is_positive());\")]\n        #[doc = concat!(\"assert!(!(-10\", stringify!($SelfT), \").is_positive());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_positive(self) -> bool { self > 0 }\n\n        /// Returns `true` if `self` is negative and `false` if the number is zero or\n        /// positive.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!((-10\", stringify!($SelfT), \").is_negative());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_negative());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_methods\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_negative(self) -> bool { self < 0 }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its representation as a byte array in\n        /// little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates an integer value from its memory representation as a byte\n        /// array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes)]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes)]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_min_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self {\n            Self::MIN\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[inline(always)]\n        #[rustc_promotable]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self {\n            Self::MAX\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 78, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h9b301baf0d8d2b9fE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some unsigned integer `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17h83ea5430137bdb2cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some unsigned integer `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 137, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h7a56a678b9d23d50E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some unsigned integer `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17he93c850b2fed0e4aE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"1.87.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"1.87.0\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some unsigned integer `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h1cb6aa6be3c20e07E",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17h5ad2ce2f9fd05d0dE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 65, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17hf35c2a7eaae566c6E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17h2486f4797b4b3392E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h6649d343de6176a5E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 114, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h7e1d66c3fc740aaaE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hdc6cf326cda984d2E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17hf0ab88a4a0a01127E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17h12f2f7042167caecE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 21, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::Range<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h20065e956411adc1E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 12, name: \"core::str::<impl str>::trim\" }",
        "func": {
          "name": "core::str::<impl str>::trim",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$4trim17h1174b053d49e3a4eE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn trim(&self) -> &str {\n        self.trim_matches(|c: char| c.is_whitespace())\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 23, name: \"core::str::<impl str>::trim::{closure#0}\" }",
        "func": {
          "name": "core::str::<impl str>::trim::{closure#0}",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$4trim28_$u7b$$u7b$closure$u7d$$u7d$17he1c82f5f109dae39E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "|c: char| c.is_whitespace()",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 13, name: \"core::str::<impl str>::trim_matches\" }",
        "func": {
          "name": "core::str::<impl str>::trim_matches::<{closure@core::str::<impl str>::trim::{closure#0}}>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12trim_matches17hebafa47392c1f645E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn trim_matches<P: Pattern>(&self, pat: P) -> &str\n    where\n        for<'a> P::Searcher<'a>: DoubleEndedSearcher<'a>,\n    {\n        let mut i = 0;\n        let mut j = 0;\n        let mut matcher = pat.into_searcher(self);\n        if let Some((a, b)) = matcher.next_reject() {\n            i = a;\n            j = b; // Remember earliest known match, correct it below if\n            // last match is different\n        }\n        if let Some((_, b)) = matcher.next_reject_back() {\n            j = b;\n        }\n        // SAFETY: `Searcher` is known to return valid indices.\n        unsafe { self.get_unchecked(i..j) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h64af56de63b99cbaE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h8c230c42a965cbccE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17hc3f81256b86ae677E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"core::str::validations::next_code_point_reverse\" }",
        "func": {
          "name": "core::str::validations::next_code_point_reverse::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations23next_code_point_reverse17h1c8ef1e0a8acb911E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) unsafe fn next_code_point_reverse<'a, I>(bytes: &mut I) -> Option<u32>\nwhere\n    I: DoubleEndedIterator<Item = &'a u8>,\n{\n    // Decode UTF-8\n    let w = match *bytes.next_back()? {\n        next_byte if next_byte < 128 => return Some(next_byte as u32),\n        back_byte => back_byte,\n    };\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [x [y [z w]]]\n    let mut ch;\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let z = unsafe { *bytes.next_back().unwrap_unchecked() };\n    ch = utf8_first_byte(z, 2);\n    if utf8_is_cont_byte(z) {\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let y = unsafe { *bytes.next_back().unwrap_unchecked() };\n        ch = utf8_first_byte(y, 3);\n        if utf8_is_cont_byte(y) {\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let x = unsafe { *bytes.next_back().unwrap_unchecked() };\n            ch = utf8_first_byte(x, 4);\n            ch = utf8_acc_cont_byte(ch, y);\n        }\n        ch = utf8_acc_cont_byte(ch, z);\n    }\n    ch = utf8_acc_cont_byte(ch, w);\n\n    Some(ch)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17h48e11289202c4df2E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17hf9cee7239c6d90ffE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17hd147bb9b6fc2b64cE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 50, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17h31f07ac0d4d26013E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 63, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17hee7a87c19b0a4c19E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"core::unicode::unicode_data::white_space::lookup\" }",
        "func": {
          "name": "core::unicode::unicode_data::white_space::lookup",
          "mangled_name": "_ZN4core7unicode12unicode_data11white_space6lookup17h371a5372d6c16adfE",
          "kind": "Item",
          "file": "library/core/src/unicode/unicode_data.rs",
          "src": "pub const fn lookup(c: char) -> bool {\n        match c as u32 >> 8 {\n            0 => WHITESPACE_MAP[c as usize & 0xff] & 1 != 0,\n            22 => c as u32 == 0x1680,\n            32 => WHITESPACE_MAP[c as usize & 0xff] & 2 != 0,\n            48 => c as u32 == 0x3000,\n            _ => false,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 4, name: \"m::func1\" }",
        "func": {
          "name": "m::func1",
          "mangled_name": "_ZN15standard_proofs1m5func117h83a81c784c41ed5cE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs.rs",
          "src": "pub fn func1() {\n        let _a = \"\".trim();\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 75, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217ha5043e44cd5e1b89E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 73, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17h2c954e33d3ad99a3E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 74, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h5b07132b2c6221fbE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 72, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h2e3fbff6dc676013E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"std::char::methods::<impl char>::is_whitespace\" }",
        "func": {
          "name": "std::char::methods::<impl char>::is_whitespace",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$13is_whitespace17hcf89b608583ab088E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const fn is_whitespace(self) -> bool {\n        match self {\n            ' ' | '\\x09'..='\\x0d' => true,\n            c => c > '\\x7f' && unicode::White_Space(c),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hfe1543da79baf703E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17h9b012fdbabba8173E",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17h5972c7fedbc083d1E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 104, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17hc7928eb45574ab19E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17headad5910036d3ceE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 52, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17h733aefe17fc06e63E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 84, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17h79ead92eb3c29ef9E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<char>::map::<(usize, char), {closure@<std::str::CharIndices<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h0cc06d0d40f0790eE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h7bbb11287850b35cE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17hfcb38145c72f9795E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17he8d6d5eec5493439E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 47, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h893199b04d4a4565E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h9e1552d0a720b6e1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h19081cd49b469faeE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h4ba61c9cf5e4f888E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 47, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7276f1ee8aa1ceddE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h18d0d46f7013c5c2E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 100, name: \"std::ptr::NonNull::<T>::offset\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6offset17hb7f91efd82ba1b7fE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset(self, count: isize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 45, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h1adf6f40e5444a04E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 98, name: \"std::ptr::NonNull::<T>::sub\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::sub",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3sub17h59a909cfb662daf8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn sub(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        if T::IS_ZST {\n            // Pointer arithmetic does nothing when the pointee is a ZST.\n            self\n        } else {\n            // SAFETY: the caller must uphold the safety contract for `offset`.\n            // Because the pointee is *not* a ZST, that means that `count` is\n            // at most `isize::MAX`, and thus the negation cannot overflow.\n            unsafe { self.offset((count as isize).unchecked_neg()) }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 51, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17habdcca0de85676c1E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 64, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h96d5a78baad90d01E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 66, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17h64fcfe50676341c7E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h5402e9cdcfe884bbE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h75d6b797b8ed7323E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h8a1d473c6a73d8feE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 43, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h78cb238aa5749e93E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 46, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17he1abebaafbf93fbcE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 49, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h780d27d28204907bE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<[u8; 256]>",
          "mangled_name": "_ZN4core3ptr46drop_in_place$LT$$u5b$u8$u3b$$u20$256$u5d$$GT$17h93789a329636a764E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::str::pattern::CharPredicateSearcher<'_, {closure@core::str::<impl str>::trim::{closure#0}}>>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$core..str..pattern..CharPredicateSearcher$LT$core..str..$LT$impl$u20$str$GT$..trim..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$17h6d94103b6fb3c9e0E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::CharIndices<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr162drop_in_place$LT$$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$..next_back..$u7b$$u7b$closure$u7d$$u7d$$GT$17hfa74c3f9b83d47b0E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::DoubleEndedIterator>::next_back::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr156drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..double_ended..DoubleEndedIterator$GT$..next_back..$u7b$$u7b$closure$u7d$$u7d$$GT$17h9f2f8eaab74ad34dE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 22, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17h3fc4f6d8dc39ccfdE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h44c29b92e7161fe5E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h47a0c6aa6ba9158dE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 97, name: \"std::ptr::mut_ptr::<impl *mut T>::cast\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut *const u8>::cast::<std::ptr::NonNull<u8>>",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$4cast17he221b4c50d93d703E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *mut U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 97, name: \"std::ptr::mut_ptr::<impl *mut T>::cast\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut *const u8>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$4cast17h2f20e9f22c4079bdE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *mut U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h86ac4e8d0f522fa2E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hc66eeca404fd7580E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 48, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17hccb2bd7394d02800E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 127, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hd0edfc37c6ef4fd0E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 118, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17hceb77eb7a4635ba3E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 120, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hef510db98dd8d5beE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 76, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h8bf7eddf335fd97aE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17hb8b24f473b0b56ebE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 115, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hbaf869cad353ab1fE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) const fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from_ref(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 93, name: \"std::slice::Iter::<'a, T>::next_back_unchecked\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::next_back_unchecked",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$19next_back_unchecked17h061682a4cba809d2E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 94, name: \"std::slice::Iter::<'a, T>::pre_dec_end\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::pre_dec_end",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$11pre_dec_end17h28af4eb221149191E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 3, name: \"top_level\" }",
        "func": {
          "name": "top_level",
          "mangled_name": "_ZN15standard_proofs9top_level17h2785e5da12967e97E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs.rs",
          "src": "pub fn top_level() {\n    m::func1();\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      }
    ]
  },
  {
    "hash": "130593389360887046121730487531425257701",
    "def_id": "DefId { id: 0, name: \"verify::standard_proof\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "kind": "Standard",
    "func": {
      "name": "verify::standard_proof",
      "mangled_name": "_ZN15standard_proofs6verify14standard_proof17h755badced94c944aE",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs.rs",
      "src": "fn standard_proof() {\n        let val: u8 = kani::any();\n        assert_eq!(val, 1, \"Not eq to 1.\");\n    }",
      "macro_backtrace_len": 0,
      "macro_backtrace": []
    },
    "callees_len": 6,
    "callees": [
      {
        "def_id": "DefId { id: 8, name: \"<u8 as kani::Arbitrary>::any\" }",
        "func": {
          "name": "<u8 as kani::Arbitrary>::any",
          "mangled_name": "_ZN38_$LT$u8$u20$as$u20$kani..Arbitrary$GT$3any17h3483b75e4834d09bE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/arbitrary.rs",
          "src": "fn any() -> Self {\n                        // This size_of call does not use generic_const_exprs feature. It's inside a macro, and Self isn't generic.\n                        unsafe { crate::kani::any_raw_internal::<Self>() }\n                    }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "trivial_arbitrary!(u8)",
              "defsite": "macro_rules! trivial_arbitrary {\n            ( $type: ty ) => {\n                impl Arbitrary for $type {\n                    #[inline(always)]\n                    fn any() -> Self {\n                        // This size_of call does not use generic_const_exprs feature. It's inside a macro, and Self isn't generic.\n                        unsafe { crate::kani::any_raw_internal::<Self>() }\n                    }\n                    fn any_array<const MAX_ARRAY_LENGTH: usize>() -> [Self; MAX_ARRAY_LENGTH] {\n                        unsafe { crate::kani::any_raw_array::<Self, MAX_ARRAY_LENGTH>() }\n                    }\n                }\n            };\n        }"
            },
            {
              "callsite": "kani_core::generate_arbitrary!(std)",
              "defsite": "macro_rules! generate_arbitrary"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 5, name: \"kani::any\" }",
        "func": {
          "name": "kani::any::<u8>",
          "mangled_name": "_ZN4kani3any17he8fd7a697599685bE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub fn any<T: Arbitrary>() -> T {\n            T::any()\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 10, name: \"kani::any_raw\" }",
        "func": {
          "name": "kani::any_raw::<u8>",
          "mangled_name": "_ZN4kani7any_raw17hcd1c3480029fc0c3E",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "fn any_raw<T: Copy>() -> T {\n            kani_intrinsic()\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 9, name: \"kani::any_raw_internal\" }",
        "func": {
          "name": "kani::any_raw_internal::<u8>",
          "mangled_name": "_ZN4kani16any_raw_internal17ha690e43c6c59c976E",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "unsafe fn any_raw_internal<T: Copy>() -> T {\n            any_raw::<T>()\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 6, name: \"kani::assert\" }",
        "func": {
          "name": "kani::assert",
          "mangled_name": "_ZN4kani6assert17h914a947307b610ddE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn assert(cond: bool, msg: &'static str) {\n            let _ = cond;\n            let _ = msg;\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 11, name: \"kani::kani_intrinsic\" }",
        "func": {
          "name": "kani::kani_intrinsic::<u8>",
          "mangled_name": "_ZN4kani14kani_intrinsic17h28162419f77453b3E",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "fn kani_intrinsic<T>() -> T {\n            #[allow(clippy::empty_loop)]\n            loop {}\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      }
    ]
  },
  {
    "hash": "14450731345693588624745887593183259349",
    "def_id": "DefId { id: 1, name: \"verify::standard_proof_empty\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "kind": "Standard",
    "func": {
      "name": "verify::standard_proof_empty",
      "mangled_name": "_ZN15standard_proofs6verify20standard_proof_empty17he1ce2465bbad64d2E",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs.rs",
      "src": "fn standard_proof_empty() {}",
      "macro_backtrace_len": 0,
      "macro_backtrace": []
    },
    "callees_len": 0,
    "callees": []
  }
]