[
  {
    "hash": "1429943746815222909810312437181214800591",
    "def_id": "DefId { id: 13, name: \"verify::f\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "kind": "Standard",
    "func": {
      "name": "verify::f",
      "mangled_name": "_ZN8contract6verify1f17hbb7ab8fa785d99dfE",
      "kind": "Item",
      "file": "tests/compare/contract.rs",
      "src": "pub fn f() {\n        contract(0);\n    }",
      "macro_backtrace_len": 0,
      "macro_backtrace": []
    },
    "callees_len": 249,
    "callees": [
      {
        "def_id": "DefId { id: 38, name: \"<&T as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<&str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h410ed86c60f5cfc3E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }",
              "defsite": "macro_rules! fmt_refs {\n    ($($tr:ident),*) => {\n        $(\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }\n        }\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T: ?Sized + $tr> $tr for &mut T {\n            fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }\n        }\n        )*\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 105, name: \"<T as std::convert::From<T>>::from\" }",
        "func": {
          "name": "<std::fmt::Error as std::convert::From<std::fmt::Error>>::from",
          "mangled_name": "_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17h1e90d8fe1f9ae95eE",
          "kind": "Item",
          "file": "library/core/src/convert/mod.rs",
          "src": "fn from(t: T) -> T {\n        t\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize17hefafed2dd7e7b23dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 143, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::{closure#0}\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize28_$u7b$$u7b$closure$u7d$$u7d$17h58b8e91647087575E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "move |x| predicate(&x) as usize",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::iter::Filter<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}> as std::iter::Iterator>::count",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h3699bd088ef32d8bE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 147, name: \"<std::iter::Map<I, F> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::fold::<usize, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN102_$LT$core..iter..adapters..map..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h6d92003bf13c783fE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, map_fold(self.f, g))\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"std::iter::Iterator::sum\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::sum::<usize>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3sum17h7d40d1f308b1005dE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn sum<S>(self) -> S\n    where\n        Self: Sized,\n        S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h7c9a54f8524b49a7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17hce7831b5e86d6af1E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h9c1f64b07716f02eE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17h2e2ab1a72ff80731E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 236, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h07c3e6fc52b3fedeE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 237, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h99f2f0e144b0be9fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[[usize; 4]]> as std::convert::From<&[[usize; 4]]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hf2bfe9aa01cc2a5cE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[u8]> as std::convert::From<&[u8]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17ha2f234dc854092f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize; 4]> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9d329a2fb5d239cdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize]> as std::convert::From<&[usize]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hda64db96e84d2849E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7c7ff8009b034788E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<usize> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h626a1d09fbfa6da4E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 69, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hc061659ac6d49be8E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 66, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hb63dc43fb3b8efe3E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 69, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hbf3169bb7998e829E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 66, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hf0fbb1a129a09e75E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h962da7a65ee8c669E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"<std::slice::Chunks<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN93_$LT$core..slice..iter..Chunks$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h28c7ddf67bd014beE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 181, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, [usize; 4]> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h0b79c4e6d4c47667E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 230, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17h0d0457c40f194ffcE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"std::iter::Iterator::filter\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::filter::<{closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator6filter17h89d9720e37de1568E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn filter<P>(self, predicate: P) -> Filter<Self, P>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        Filter::new(self, predicate)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 149, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::fold::<usize, {closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h29ba2c4b195065b9E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"std::iter::Iterator::map\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::map::<usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3map17hbfc9ceba84a749aeE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn map<B, F>(self, f: F) -> Map<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> B,\n    {\n        Map::new(self, f)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 181, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hfadf3ba7fbb0614cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 181, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hae10bd58ec770fd8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::iter::Iterator::advance_by\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::advance_by",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator10advance_by17h0040525bd95241f2E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        for i in 0..n {\n            if self.next().is_none() {\n                // SAFETY: `i` is always less than `n`.\n                return Err(unsafe { NonZero::new_unchecked(n - i) });\n            }\n        }\n        Ok(())\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 224, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hc19a3b9458606f20E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 63, name: \"<std::str::Chars<'a> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::count",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h1692b0bf9f027e4aE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn count(self) -> usize {\n        super::count::count_chars(self.as_str())\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 231, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hced3b3cf7a3ebc10E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 235, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hcd9a1b225c5bc517E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 45, name: \"<str as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h2e4773966404a9e8E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"<u16 as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<u16 as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN47_$LT$u16$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17ha7680b32029a8095E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "step_unsigned_methods!()",
              "defsite": "macro_rules! step_unsigned_methods {\n    () => {\n        #[inline]\n        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }\n\n        #[inline]\n        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n            unsafe { start.unchecked_sub(n as Self) }\n        }\n    };\n}"
            },
            {
              "callsite": "step_integer_impls! {\n    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n    wider than usize: [u128 i128];\n}",
              "defsite": "macro_rules! step_integer_impls {\n    {\n        narrower than or same width as usize:\n            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n        wider than usize:\n            $( [ $u_wider:ident $i_wider:ident ] ),+;\n    } => {\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_narrower {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $u_narrower <= usize\n                        let steps = (*end - *start) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_add(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_sub(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n                    }\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_narrower {\n                step_identical_methods!();\n                step_signed_methods!($u_narrower);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $i_narrower <= usize\n                        //\n                        // Casting to isize extends the width but preserves the sign.\n                        // Use wrapping_sub in isize space and cast to usize to compute\n                        // the difference that might not fit inside the range of isize.\n                        let steps = (*end as isize).wrapping_sub(*start as isize) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_add(n as Self);\n                            if wrapped >= start {\n                                Some(wrapped)\n                            } else {\n                                None // Addition overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 + n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_sub(n as Self);\n                            if wrapped <= start {\n                                Some(wrapped)\n                            } else {\n                                None // Subtraction overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 - n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n            }\n        )+\n\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_wider {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        if let Ok(steps) = usize::try_from(*end - *start) {\n                            (steps, Some(steps))\n                        } else {\n                            (usize::MAX, None)\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_wider {\n                step_identical_methods!();\n                step_signed_methods!($u_wider);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        match end.checked_sub(*start) {\n                            Some(result) => {\n                                if let Ok(steps) = usize::try_from(result) {\n                                    (steps, Some(steps))\n                                } else {\n                                    (usize::MAX, None)\n                                }\n                            }\n                            // If the difference is too big for e.g. i128,\n                            // it's also gonna be too big for usize with fewer bits.\n                            None => (usize::MAX, None),\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n        )+\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 218, name: \"std::cmp::Ord::min\" }",
        "func": {
          "name": "<usize as std::cmp::Ord>::min",
          "mangled_name": "_ZN4core3cmp3Ord3min17hca8e35334025e720E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        if other < self { other } else { self }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 228, name: \"<usize as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<usize as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN49_$LT$usize$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17h7959f82020603cf6E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "step_unsigned_methods!()",
              "defsite": "macro_rules! step_unsigned_methods {\n    () => {\n        #[inline]\n        unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }\n\n        #[inline]\n        unsafe fn backward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start - n` doesn't overflow.\n            unsafe { start.unchecked_sub(n as Self) }\n        }\n    };\n}"
            },
            {
              "callsite": "step_integer_impls! {\n    narrower than or same width as usize: [u8 i8], [u16 i16], [u32 i32], [u64 i64], [usize isize];\n    wider than usize: [u128 i128];\n}",
              "defsite": "macro_rules! step_integer_impls {\n    {\n        narrower than or same width as usize:\n            $( [ $u_narrower:ident $i_narrower:ident ] ),+;\n        wider than usize:\n            $( [ $u_wider:ident $i_wider:ident ] ),+;\n    } => {\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_narrower {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $u_narrower <= usize\n                        let steps = (*end - *start) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_add(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start + n` is too\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match Self::try_from(n) {\n                        Ok(n) => start.checked_sub(n),\n                        Err(_) => None, // if n is out of range, `unsigned_start - n` is too\n                    }\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_narrower {\n                step_identical_methods!();\n                step_signed_methods!($u_narrower);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        // This relies on $i_narrower <= usize\n                        //\n                        // Casting to isize extends the width but preserves the sign.\n                        // Use wrapping_sub in isize space and cast to usize to compute\n                        // the difference that might not fit inside the range of isize.\n                        let steps = (*end as isize).wrapping_sub(*start as isize) as usize;\n                        (steps, Some(steps))\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_add(n as Self);\n                            if wrapped >= start {\n                                Some(wrapped)\n                            } else {\n                                None // Addition overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 + n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    match $u_narrower::try_from(n) {\n                        Ok(n) => {\n                            // Wrapping handles cases like\n                            // `Step::forward(-120_i8, 200) == Some(80_i8)`,\n                            // even though 200 is out of range for i8.\n                            let wrapped = start.wrapping_sub(n as Self);\n                            if wrapped <= start {\n                                Some(wrapped)\n                            } else {\n                                None // Subtraction overflowed\n                            }\n                        }\n                        // If n is out of range of e.g. u8,\n                        // then it is bigger than the entire range for i8 is wide\n                        // so `any_i8 - n` necessarily overflows i8.\n                        Err(_) => None,\n                    }\n                }\n            }\n        )+\n\n        $(\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $u_wider {\n                step_identical_methods!();\n                step_unsigned_methods!();\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        if let Ok(steps) = usize::try_from(*end - *start) {\n                            (steps, Some(steps))\n                        } else {\n                            (usize::MAX, None)\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n\n            #[allow(unreachable_patterns)]\n            #[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n            impl Step for $i_wider {\n                step_identical_methods!();\n                step_signed_methods!($u_wider);\n\n                #[inline]\n                fn steps_between(start: &Self, end: &Self) -> (usize, Option<usize>) {\n                    if *start <= *end {\n                        match end.checked_sub(*start) {\n                            Some(result) => {\n                                if let Ok(steps) = usize::try_from(result) {\n                                    (steps, Some(steps))\n                                } else {\n                                    (usize::MAX, None)\n                                }\n                            }\n                            // If the difference is too big for e.g. i128,\n                            // it's also gonna be too big for usize with fewer bits.\n                            None => (usize::MAX, None),\n                        }\n                    } else {\n                        (0, None)\n                    }\n                }\n\n                #[inline]\n                fn forward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_add(n as Self)\n                }\n\n                #[inline]\n                fn backward_checked(start: Self, n: usize) -> Option<Self> {\n                    start.checked_sub(n as Self)\n                }\n            }\n        )+\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 145, name: \"<usize as std::iter::Sum>::sum\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum17hd4899a4f1283f91cE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)",
              "defsite": "macro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)*);\n    );\n}"
            },
            {
              "callsite": "integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }",
              "defsite": "macro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)*);\n    );\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"<usize as std::iter::Sum>::sum::{closure#0}\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum28_$u7b$$u7b$closure$u7d$$u7d$17hf553ffa479b229d7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "|a, b| a + b",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)",
              "defsite": "macro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)*);\n    );\n}"
            },
            {
              "callsite": "integer_sum_product! { i8 i16 i32 i64 i128 isize u8 u16 u32 u64 u128 usize }",
              "defsite": "macro_rules! integer_sum_product {\n    (@impls $zero:expr, $one:expr, #[$attr:meta], $($a:ty)*) => ($(\n        #[$attr]\n        impl Sum for $a {\n            fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl Product for $a {\n            fn product<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Sum<&'a $a> for $a {\n            fn sum<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }\n        }\n\n        #[$attr]\n        impl<'a> Product<&'a $a> for $a {\n            fn product<I: Iterator<Item=&'a Self>>(iter: I) -> Self {\n                iter.fold(\n                    $one,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a * b,\n                )\n            }\n        }\n    )*);\n    ($($a:ty)*) => (\n        integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*);\n        integer_sum_product!(@impls Wrapping(0), Wrapping(1),\n                #[stable(feature = \"wrapping_iter_arith\", since = \"1.14.0\")],\n                $(Wrapping<$a>)*);\n    );\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 83, name: \"core::fmt::PostPadding::new\" }",
        "func": {
          "name": "core::fmt::PostPadding::new",
          "mangled_name": "_ZN4core3fmt11PostPadding3new17h635173abc89c1c46E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn new(fill: char, padding: u16) -> PostPadding {\n        PostPadding { fill, padding }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"core::fmt::PostPadding::write\" }",
        "func": {
          "name": "core::fmt::PostPadding::write",
          "mangled_name": "_ZN4core3fmt11PostPadding5write17he27432ff58f0176fE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n        for _ in 0..self.padding {\n            f.buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 39, name: \"core::fmt::rt::Argument::<'_>::new\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument3new17hc43cfa4d4cc7eeb3E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "const fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'a> {\n        Argument {\n            // INVARIANT: this creates an `ArgumentType<'a>` from a `&'a T` and\n            // a `fn(&T, ...)`, so the invariant is maintained.\n            ty: ArgumentType::Placeholder {\n                value: NonNull::from_ref(x).cast(),\n                // SAFETY: function pointers always have the same layout.\n                formatter: unsafe { mem::transmute(f) },\n                _lifetime: PhantomData,\n            },\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 31, name: \"core::fmt::rt::Argument::<'_>::new_display\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new_display::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument11new_display17h2abb0f96064d56d7E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "pub fn new_display<T: Display>(x: &T) -> Argument<'_> {\n        Self::new(x, Display::fmt)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 93, name: \"core::num::<impl u16>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl u16>::overflowing_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$15overflowing_add17h711f2c8f6e02c5aaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"core::num::<impl u16>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add17hec98168318b5d827E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"core::num::<impl u16>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add18precondition_check17h2c2ceb48f2be1cf2E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h036191e61598aedaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 205, name: \"core::num::<impl usize>::count_ones\" }",
        "func": {
          "name": "core::num::<impl usize>::count_ones",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$10count_ones17h5848180a66ff35a5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 204, name: \"core::num::<impl usize>::is_power_of_two\" }",
        "func": {
          "name": "core::num::<impl usize>::is_power_of_two",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15is_power_of_two17h25612661704e08b9E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 171, name: \"core::num::<impl usize>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_add17hae858b6d0d0dc624E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 189, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17ha23631731d5dc26cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"core::num::<impl usize>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add17hc42a707166fea5e5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 170, name: \"core::num::<impl usize>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add18precondition_check17h7c3a0d627d04c0e5E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h118193beb20e1102E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 188, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17h5b716badb64486cdE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::num::<impl usize>::wrapping_mul\" }",
        "func": {
          "name": "core::num::<impl usize>::wrapping_mul",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$12wrapping_mul17h0d4deee3af61861dE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }",
              "defsite": "macro_rules! uint_impl {\n    (\n        Self = $SelfT:ty,\n        ActualT = $ActualT:ident,\n        SignedT = $SignedT:ident,\n\n        // These are all for use *only* in doc comments.\n        // As such, they're all passed as literals -- passing them as a string\n        // literal is fine if they need to be multiple code tokens.\n        // In non-comments, use the associated constants rather than these.\n        BITS = $BITS:literal,\n        BITS_MINUS_ONE = $BITS_MINUS_ONE:literal,\n        MAX = $MaxV:literal,\n        rot = $rot:literal,\n        rot_op = $rot_op:literal,\n        rot_result = $rot_result:literal,\n        swap_op = $swap_op:literal,\n        swapped = $swapped:literal,\n        reversed = $reversed:literal,\n        le_bytes = $le_bytes:literal,\n        be_bytes = $be_bytes:literal,\n        to_xe_bytes_doc = $to_xe_bytes_doc:expr,\n        from_xe_bytes_doc = $from_xe_bytes_doc:expr,\n        bound_condition = $bound_condition:literal,\n    ) => {\n        /// The smallest value that can be represented by this integer type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MIN, 0);\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MIN: Self = 0;\n\n        /// The largest value that can be represented by this integer type\n        #[doc = concat!(\"(2<sup>\", $BITS, \"</sup> &minus; 1\", $bound_condition, \").\")]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX, \", stringify!($MaxV), \");\")]\n        /// ```\n        #[stable(feature = \"assoc_int_consts\", since = \"1.43.0\")]\n        pub const MAX: Self = !0;\n\n        /// The size of this integer type in bits.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::BITS, \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"int_bits_const\", since = \"1.53.0\")]\n        pub const BITS: u32 = Self::MAX.count_ones();\n\n        /// Returns the number of ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b01001100\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.count_ones(), 3);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.count_ones(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.count_ones(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[doc(alias = \"popcount\")]\n        #[doc(alias = \"popcnt\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }\n\n        /// Returns the number of zeros in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.count_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.count_zeros(), 0);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn count_zeros(self) -> u32 {\n            (!self).count_ones()\n        }\n\n        /// Returns the number of leading zeros in the binary representation of `self`.\n        ///\n        /// Depending on what you're doing with the value, you might also be interested in the\n        /// [`ilog2`] function which returns a consistent number, even if the type widens.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX >> 2;\")]\n        /// assert_eq!(n.leading_zeros(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.leading_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        /// assert_eq!(max.leading_zeros(), 0);\n        /// ```\n        #[doc = concat!(\"[`ilog2`]: \", stringify!($SelfT), \"::ilog2\")]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_zeros(self) -> u32 {\n            return intrinsics::ctlz(self as $ActualT);\n        }\n\n        /// Returns the number of trailing zeros in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b0101000\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_zeros(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        #[doc = concat!(\"assert_eq!(zero.trailing_zeros(), \", stringify!($BITS), \");\")]\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_zeros(), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_zeros(self) -> u32 {\n            return intrinsics::cttz(self);\n        }\n\n        /// Returns the number of leading ones in the binary representation of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = !(\", stringify!($SelfT), \"::MAX >> 2);\")]\n        /// assert_eq!(n.leading_ones(), 2);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.leading_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.leading_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn leading_ones(self) -> u32 {\n            (!self).leading_zeros()\n        }\n\n        /// Returns the number of trailing ones in the binary representation\n        /// of `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0b1010111\", stringify!($SelfT), \";\")]\n        /// assert_eq!(n.trailing_ones(), 3);\n        ///\n        #[doc = concat!(\"let zero = 0\", stringify!($SelfT), \";\")]\n        /// assert_eq!(zero.trailing_ones(), 0);\n        ///\n        #[doc = concat!(\"let max = \", stringify!($SelfT),\"::MAX;\")]\n        #[doc = concat!(\"assert_eq!(max.trailing_ones(), \", stringify!($BITS), \");\")]\n        /// ```\n        #[stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[rustc_const_stable(feature = \"leading_trailing_ones\", since = \"1.46.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn trailing_ones(self) -> u32 {\n            (!self).trailing_zeros()\n        }\n\n        /// Returns `self` with only the most significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_most_significant_one(), 0b_01000000);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_most_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_most_significant_one(self) -> Self {\n            self & (((1 as $SelfT) << (<$SelfT>::BITS - 1)).wrapping_shr(self.leading_zeros()))\n        }\n\n        /// Returns `self` with only the least significant bit set, or `0` if\n        /// the input is `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(isolate_most_least_significant_one)]\n        ///\n        #[doc = concat!(\"let n: \", stringify!($SelfT), \" = 0b_01100100;\")]\n        ///\n        /// assert_eq!(n.isolate_least_significant_one(), 0b_00000100);\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".isolate_least_significant_one(), 0);\")]\n        /// ```\n        #[unstable(feature = \"isolate_most_least_significant_one\", issue = \"136909\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn isolate_least_significant_one(self) -> Self {\n            self & self.wrapping_neg()\n        }\n\n        /// Returns the bit pattern of `self` reinterpreted as a signed integer of the same size.\n        ///\n        /// This produces the same result as an `as` cast, but ensures that the bit-width remains\n        /// the same.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", stringify!($SelfT), \"::MAX;\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.cast_signed(), -1\", stringify!($SignedT), \");\")]\n        /// ```\n        #[stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"integer_sign_cast\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn cast_signed(self) -> $SignedT {\n            self as $SignedT\n        }\n\n        /// Shifts the bits to the left by a specified amount, `n`,\n        /// wrapping the truncated bits to the end of the resulting integer.\n        ///\n        /// Please note this isn't the same operation as the `<<` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_op, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_result, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_left(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_left(self, n: u32) -> Self {\n            return intrinsics::rotate_left(self, n);\n        }\n\n        /// Shifts the bits to the right by a specified amount, `n`,\n        /// wrapping the truncated bits to the beginning of the resulting\n        /// integer.\n        ///\n        /// Please note this isn't the same operation as the `>>` shifting operator!\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $rot_result, stringify!($SelfT), \";\")]\n        #[doc = concat!(\"let m = \", $rot_op, \";\")]\n        ///\n        #[doc = concat!(\"assert_eq!(n.rotate_right(\", $rot, \"), m);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn rotate_right(self, n: u32) -> Self {\n            return intrinsics::rotate_right(self, n);\n        }\n\n        /// Reverses the byte order of the integer.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.swap_bytes();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $swapped, \");\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn swap_bytes(self) -> Self {\n            intrinsics::bswap(self as $ActualT) as Self\n        }\n\n        /// Reverses the order of bits in the integer. The least significant bit becomes the most significant bit,\n        ///                 second least-significant bit becomes second most-significant bit, etc.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = \", $swap_op, stringify!($SelfT), \";\")]\n        /// let m = n.reverse_bits();\n        ///\n        #[doc = concat!(\"assert_eq!(m, \", $reversed, \");\")]\n        #[doc = concat!(\"assert_eq!(0, 0\", stringify!($SelfT), \".reverse_bits());\")]\n        /// ```\n        #[stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[rustc_const_stable(feature = \"reverse_bits\", since = \"1.37.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn reverse_bits(self) -> Self {\n            intrinsics::bitreverse(self as $ActualT) as Self\n        }\n\n        /// Converts an integer from big endian to the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_be(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_be(x: Self) -> Self {\n            #[cfg(target_endian = \"big\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts an integer from little endian to the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n)\")]\n        /// } else {\n        #[doc = concat!(\"    assert_eq!(\", stringify!($SelfT), \"::from_le(n), n.swap_bytes())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use]\n        #[inline(always)]\n        pub const fn from_le(x: Self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                x\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                x.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to big endian from the target's endianness.\n        ///\n        /// On big endian this is a no-op. On little endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"big\") {\n        ///     assert_eq!(n.to_be(), n)\n        /// } else {\n        ///     assert_eq!(n.to_be(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_be(self) -> Self { // or not to be?\n            #[cfg(target_endian = \"big\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"big\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Converts `self` to little endian from the target's endianness.\n        ///\n        /// On little endian this is a no-op. On big endian the bytes are\n        /// swapped.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"let n = 0x1A\", stringify!($SelfT), \";\")]\n        ///\n        /// if cfg!(target_endian = \"little\") {\n        ///     assert_eq!(n.to_le(), n)\n        /// } else {\n        ///     assert_eq!(n.to_le(), n.swap_bytes())\n        /// }\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn to_le(self) -> Self {\n            #[cfg(target_endian = \"little\")]\n            {\n                self\n            }\n            #[cfg(not(target_endian = \"little\"))]\n            {\n                self.swap_bytes()\n            }\n        }\n\n        /// Checked integer addition. Computes `self + rhs`, returning `None`\n        /// if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\n            \"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(1), \",\n            \"Some(\", stringify!($SelfT), \"::MAX - 1));\"\n        )]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add(3), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add(self, rhs: Self) -> Option<Self> {\n            // This used to use `overflowing_add`, but that means it ends up being\n            // a `wrapping_add`, losing some optimization opportunities. Notably,\n            // phrasing it this way helps `.checked_add(1)` optimize to a check\n            // against `MAX` and a `add nuw`.\n            // Per <https://github.com/rust-lang/rust/pull/124114#issuecomment-2066173305>,\n            // LLVM is happy to re-form the intrinsic later if useful.\n\n            if intrinsics::unlikely(intrinsics::add_with_overflow(self, rhs).1) {\n                None\n            } else {\n                // SAFETY: Just checked it doesn't overflow\n                Some(unsafe { intrinsics::unchecked_add(self, rhs) })\n            }\n        }\n\n        /// Strict integer addition. Computes `self + rhs`, panicking\n        /// if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).strict_add(1), \", stringify!($SelfT), \"::MAX - 1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_add(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Unchecked integer addition. Computes `self + rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_add(y)` is semantically equivalent to calling\n        /// `x.`[`checked_add`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_add`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self + rhs > \", stringify!($SelfT), \"::MAX` or `self + rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_add`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_add`]: \", stringify!($SelfT), \"::checked_add\")]\n        #[doc = concat!(\"[`wrapping_add`]: \", stringify!($SelfT), \"::wrapping_add\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }\n\n        /// Checked addition with a signed integer. Computes `self + rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_add_signed(-2), None);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_add_signed(3), None);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_add_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict addition with a signed integer. Computes `self + rhs`,\n        /// panicking if overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_add_signed(2), 3);\")]\n        /// ```\n        ///\n        /// The following panic because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_add_signed(-2);\")]\n        /// ```\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (\", stringify!($SelfT), \"::MAX - 2).strict_add_signed(3);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_add_signed(self, rhs: $SignedT) -> Self {\n            let (a, b) = self.overflowing_add_signed(rhs);\n            if b { overflow_panic::add() } else { a }\n         }\n\n        /// Checked integer subtraction. Computes `self - rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub(1), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub(self, rhs: Self) -> Option<Self> {\n            // Per PR#103299, there's no advantage to the `overflowing` intrinsic\n            // for *unsigned* subtraction and we just emit the manual check anyway.\n            // Thus, rather than using `overflowing_sub` that produces a wrapping\n            // subtraction, check it ourself so we can use an unchecked one.\n\n            if self < rhs {\n                None\n            } else {\n                // SAFETY: just checked this can't overflow\n                Some(unsafe { intrinsics::unchecked_sub(self, rhs) })\n            }\n        }\n\n        /// Strict integer subtraction. Computes `self - rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".strict_sub(1), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0\", stringify!($SelfT), \".strict_sub(1);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_sub(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_sub(rhs);\n            if b { overflow_panic::sub() } else { a }\n         }\n\n        /// Unchecked integer subtraction. Computes `self - rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_sub(y)` is semantically equivalent to calling\n        /// `x.`[`checked_sub`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_sub`].\n        ///\n        /// If you find yourself writing code like this:\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if foo >= bar {\n        ///     // SAFETY: just checked it will not overflow\n        ///     let diff = unsafe { foo.unchecked_sub(bar) };\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// Consider changing it to\n        ///\n        /// ```\n        /// # let foo = 30_u32;\n        /// # let bar = 20;\n        /// if let Some(diff) = foo.checked_sub(bar) {\n        ///     // ... use diff ...\n        /// }\n        /// ```\n        ///\n        /// As that does exactly the same thing -- including telling the optimizer\n        /// that the subtraction cannot overflow -- but avoids needing `unsafe`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self - rhs > \", stringify!($SelfT), \"::MAX` or `self - rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_sub`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_sub`]: \", stringify!($SelfT), \"::checked_sub\")]\n        #[doc = concat!(\"[`wrapping_sub`]: \", stringify!($SelfT), \"::wrapping_sub\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }\n\n        /// Checked subtraction with a signed integer. Computes `self - rhs`,\n        /// returning `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(2), None);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_sub_signed(-2), Some(3));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).checked_sub_signed(-4), None);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_sub_signed(self, rhs: $SignedT) -> Option<Self> {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        #[doc = concat!(\n            \"Checked integer subtraction. Computes `self - rhs` and checks if the result fits into an [`\",\n            stringify!($SignedT), \"`], returning `None` if overflow occurred.\"\n        )]\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(unsigned_signed_diff)]\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_signed_diff(2), Some(8));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_signed_diff(10), Some(-8));\")]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \"), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \").checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(\",\n            stringify!($SignedT),\n            \"::MIN));\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!((\",\n            stringify!($SignedT),\n            \"::MAX as \",\n            stringify!($SelfT),\n            \" + 1).checked_signed_diff(0), None);\"\n        )]\n        #[doc = concat!(\n            \"assert_eq!(\",\n            stringify!($SelfT),\n            \"::MAX.checked_signed_diff(\",\n            stringify!($SelfT),\n            \"::MAX), Some(0));\"\n        )]\n        /// ```\n        #[unstable(feature = \"unsigned_signed_diff\", issue = \"126041\")]\n        #[inline]\n        pub const fn checked_signed_diff(self, rhs: Self) -> Option<$SignedT> {\n            let res = self.wrapping_sub(rhs) as $SignedT;\n            let overflow = (self >= rhs) == (res < 0);\n\n            if !overflow {\n                Some(res)\n            } else {\n                None\n            }\n        }\n\n        /// Checked integer multiplication. Computes `self * rhs`, returning\n        /// `None` if overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_mul(1), Some(5));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_mul(2), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_mul(self, rhs: Self) -> Option<Self> {\n            let (a, b) = self.overflowing_mul(rhs);\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict integer multiplication. Computes `self * rhs`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".strict_mul(1), 5);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ``` should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_mul(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_mul(self, rhs: Self) -> Self {\n            let (a, b) = self.overflowing_mul(rhs);\n            if b { overflow_panic::mul() } else { a }\n         }\n\n        /// Unchecked integer multiplication. Computes `self * rhs`, assuming overflow\n        /// cannot occur.\n        ///\n        /// Calling `x.unchecked_mul(y)` is semantically equivalent to calling\n        /// `x.`[`checked_mul`]`(y).`[`unwrap_unchecked`]`()`.\n        ///\n        /// If you're just trying to avoid the panic in debug mode, then **do not**\n        /// use this.  Instead, you're looking for [`wrapping_mul`].\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior when\n        #[doc = concat!(\"`self * rhs > \", stringify!($SelfT), \"::MAX` or `self * rhs < \", stringify!($SelfT), \"::MIN`,\")]\n        /// i.e. when [`checked_mul`] would return `None`.\n        ///\n        /// [`unwrap_unchecked`]: option/enum.Option.html#method.unwrap_unchecked\n        #[doc = concat!(\"[`checked_mul`]: \", stringify!($SelfT), \"::checked_mul\")]\n        #[doc = concat!(\"[`wrapping_mul`]: \", stringify!($SelfT), \"::wrapping_mul\")]\n        #[stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[rustc_const_stable(feature = \"unchecked_math\", since = \"1.79.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_mul(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_mul cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_mul(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_mul(self, rhs)\n            }\n        }\n\n        /// Checked integer division. Computes `self / rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_div(self, rhs) })\n            }\n        }\n\n        /// Strict integer division. Computes `self / rhs`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div(10), 10);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked Euclidean division. Computes `self.div_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.div_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Strict division on unsigned types is just normal division. There's no\n        /// way overflow could ever happen. This function exists so that all\n        /// operations are accounted for in the strict operations. Since, for the\n        /// positive integers, all common definitions of division are equal, this\n        /// is exactly equal to `self.strict_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_div_euclid(10), 10);\")]\n        /// ```\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = (1\", stringify!($SelfT), \").strict_div_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Checked integer remainder. Computes `self % rhs`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_div\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                // SAFETY: div by zero has been checked above and unsigned types have no other\n                // failure modes for division\n                Some(unsafe { intrinsics::unchecked_rem(self, rhs) })\n            }\n        }\n\n        /// Strict integer remainder. Computes `self % rhs`.\n        ///\n        /// Strict remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Checked Euclidean modulo. Computes `self.rem_euclid(rhs)`, returning `None`\n        /// if `rhs == 0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\")]\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n            if intrinsics::unlikely(rhs == 0) {\n                None\n            } else {\n                Some(self.rem_euclid(rhs))\n            }\n        }\n\n        /// Strict Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Strict modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way overflow could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// strict operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.strict_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".strict_rem_euclid(10), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of division by zero:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 5\", stringify!($SelfT), \".strict_rem_euclid(0);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn strict_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Same value as `self | other`, but UB if any bit position is set in both inputs.\n        ///\n        /// This is a situational micro-optimization for places where you'd rather\n        /// use addition on some platforms and bitwise or on other platforms, based\n        /// on exactly which instructions combine better with whatever else you're\n        /// doing.  Note that there's no reason to bother using this for places\n        /// where it's clear from the operations involved that they can't overlap.\n        /// For example, if you're combining `u16`s into a `u32` with\n        /// `((a as u32) << 16) | (b as u32)`, that's fine, as the backend will\n        /// know those sides of the `|` are disjoint without needing help.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(disjoint_bitor)]\n        ///\n        /// // SAFETY: `1` and `4` have no bits in common.\n        /// unsafe {\n        #[doc = concat!(\"    assert_eq!(1_\", stringify!($SelfT), \".unchecked_disjoint_bitor(4), 5);\")]\n        /// }\n        /// ```\n        ///\n        /// # Safety\n        ///\n        /// Requires that `(self & other) == 0`, otherwise it's immediate UB.\n        ///\n        /// Equivalently, requires that `(self | other) == (self + other)`.\n        #[unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[rustc_const_unstable(feature = \"disjoint_bitor\", issue = \"135758\")]\n        #[inline]\n        pub const unsafe fn unchecked_disjoint_bitor(self, other: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_disjoint_bitor cannot have overlapping bits\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = other,\n                ) => (lhs & rhs) == 0,\n            );\n\n            // SAFETY: Same precondition\n            unsafe { intrinsics::disjoint_bitor(self, other) }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `ilog2` can produce results more efficiently for base 2, and `ilog10`\n        /// can produce results more efficiently for base 10.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero, or if `base` is less than 2.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".ilog(5), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog(self, base: Self) -> u32 {\n            assert!(base >= 2, \"base of integer logarithm must be at least 2\");\n            if let Some(log) = self.checked_ilog(base) {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".ilog2(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog2(self) -> u32 {\n            if let Some(log) = self.checked_ilog2() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `self` is zero.\n        ///\n        /// # Example\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".ilog10(), 1);\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn ilog10(self) -> u32 {\n            if let Some(log) = self.checked_ilog10() {\n                log\n            } else {\n                int_log10::panic_for_nonpositive_argument()\n            }\n        }\n\n        /// Returns the logarithm of the number with respect to an arbitrary base,\n        /// rounded down.\n        ///\n        /// Returns `None` if the number is zero, or if the base is not at least 2.\n        ///\n        /// This method might not be optimized owing to implementation details;\n        /// `checked_ilog2` can produce results more efficiently for base 2, and\n        /// `checked_ilog10` can produce results more efficiently for base 10.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".checked_ilog(5), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog(self, base: Self) -> Option<u32> {\n            if self <= 0 || base <= 1 {\n                None\n            } else if self < base {\n                Some(0)\n            } else {\n                // Since base >= self, n >= 1\n                let mut n = 1;\n                let mut r = base;\n\n                // Optimization for 128 bit wide integers.\n                if Self::BITS == 128 {\n                    // The following is a correct lower bound for log(base,self) because\n                    //\n                    // log(base,self) = log(2,self) / log(2,base)\n                    //                 log(2,self) / (log(2,base) + 1)\n                    //\n                    // hence\n                    //\n                    // log(base,self)   log(2,self) / (log(2,base) + 1)  .\n                    n = self.ilog2() / (base.ilog2() + 1);\n                    r = base.pow(n);\n                }\n\n                while r <= self / base {\n                    n += 1;\n                    r *= base;\n                }\n                Some(n)\n            }\n        }\n\n        /// Returns the base 2 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_ilog2(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog2(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog2()),\n                None => None,\n            }\n        }\n\n        /// Returns the base 10 logarithm of the number, rounded down.\n        ///\n        /// Returns `None` if the number is zero.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".checked_ilog10(), Some(1));\")]\n        /// ```\n        #[stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[rustc_const_stable(feature = \"int_log\", since = \"1.67.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_ilog10(self) -> Option<u32> {\n            match NonZero::new(self) {\n                Some(x) => Some(x.ilog10()),\n                None => None,\n            }\n        }\n\n        /// Checked negation. Computes `-self`, returning `None` unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".checked_neg(), Some(0));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".checked_neg(), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_neg(self) -> Option<Self> {\n            let (a, b) = self.overflowing_neg();\n            if intrinsics::unlikely(b) { None } else { Some(a) }\n        }\n\n        /// Strict negation. Computes `-self`, panicking unless `self ==\n        /// 0`.\n        ///\n        /// Note that negating any positive integer will overflow.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".strict_neg(), 0);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 1\", stringify!($SelfT), \".strict_neg();\")]\n        ///\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_neg(self) -> Self {\n            let (a, b) = self.overflowing_neg();\n            if b { overflow_panic::neg() } else { a }\n        }\n\n        /// Checked shift left. Computes `self << rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(4), Some(0x10));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(\", stringify!($BITS_MINUS_ONE), \"), Some(0));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shl(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shl as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shl(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift left. Computes `self << rhs`, panicking if `rhs` is larger\n        /// than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".strict_shl(4), 0x10);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shl(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shl(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shl(rhs);\n            if b { overflow_panic::shl() } else { a }\n        }\n\n        /// Unchecked shift left. Computes `self << rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shl`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shl`]: \", stringify!($SelfT), \"::checked_shl\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shl(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shl cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shl(self, rhs)\n            }\n        }\n\n        /// Unbounded shift left. Computes `self << rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(4), 0x10);\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".unbounded_shl(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shl(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shl(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked shift right. Computes `self >> rhs`, returning `None`\n        /// if `rhs` is larger than or equal to the number of bits in `self`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(4), Some(0x1));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_checked_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_shr(self, rhs: u32) -> Option<Self> {\n            // Not using overflowing_shr as that's a wrapping shift\n            if rhs < Self::BITS {\n                // SAFETY: just checked the RHS is in-range\n                Some(unsafe { self.unchecked_shr(rhs) })\n            } else {\n                None\n            }\n        }\n\n        /// Strict shift right. Computes `self >> rhs`, panicking `rhs` is\n        /// larger than or equal to the number of bits in `self`.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".strict_shr(4), 0x1);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = 0x10\", stringify!($SelfT), \".strict_shr(129);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_shr(self, rhs: u32) -> Self {\n            let (a, b) = self.overflowing_shr(rhs);\n            if b { overflow_panic::shr() } else { a }\n        }\n\n        /// Unchecked shift right. Computes `self >> rhs`, assuming that\n        /// `rhs` is less than the number of bits in `self`.\n        ///\n        /// # Safety\n        ///\n        /// This results in undefined behavior if `rhs` is larger than\n        /// or equal to the number of bits in `self`,\n        /// i.e. when [`checked_shr`] would return `None`.\n        ///\n        #[doc = concat!(\"[`checked_shr`]: \", stringify!($SelfT), \"::checked_shr\")]\n        #[unstable(\n            feature = \"unchecked_shifts\",\n            reason = \"niche optimization path\",\n            issue = \"85122\",\n        )]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[cfg_attr(miri, track_caller)] // even without panics, this helps for Miri backtraces\n        pub const unsafe fn unchecked_shr(self, rhs: u32) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_shr cannot overflow\"),\n                (\n                    rhs: u32 = rhs,\n                ) => rhs < <$ActualT>::BITS,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_shr(self, rhs)\n            }\n        }\n\n        /// Unbounded shift right. Computes `self >> rhs`, without bounding the value of `rhs`.\n        ///\n        /// If `rhs` is larger or equal to the number of bits in `self`,\n        /// the entire value is shifted out, and `0` is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(4), 0x1);\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".unbounded_shr(129), 0);\")]\n        /// ```\n        #[stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unbounded_shifts\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn unbounded_shr(self, rhs: u32) -> $SelfT{\n            if rhs < Self::BITS {\n                // SAFETY:\n                // rhs is just checked to be in-range above\n                unsafe { self.unchecked_shr(rhs) }\n            } else {\n                0\n            }\n        }\n\n        /// Checked exponentiation. Computes `self.pow(exp)`, returning `None` if\n        /// overflow occurred.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_pow(5), Some(32));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n            if exp == 0 {\n                return Some(1);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = try_opt!(acc.checked_mul(base));\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return Some(acc);\n                    }\n                }\n                exp /= 2;\n                base = try_opt!(base.checked_mul(base));\n            }\n        }\n\n        /// Strict exponentiation. Computes `self.pow(exp)`, panicking if\n        /// overflow occurred.\n        ///\n        /// # Panics\n        ///\n        /// ## Overflow behavior\n        ///\n        /// This function will always panic on overflow, regardless of whether overflow checks are enabled.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".strict_pow(5), 32);\")]\n        /// ```\n        ///\n        /// The following panics because of overflow:\n        ///\n        /// ```should_panic\n        /// #![feature(strict_overflow_ops)]\n        #[doc = concat!(\"let _ = \", stringify!($SelfT), \"::MAX.strict_pow(2);\")]\n        /// ```\n        #[unstable(feature = \"strict_overflow_ops\", issue = \"118260\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn strict_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            loop {\n                if (exp & 1) == 1 {\n                    acc = acc.strict_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        return acc;\n                    }\n                }\n                exp /= 2;\n                base = base.strict_mul(base);\n            }\n        }\n\n        /// Saturating integer addition. Computes `self + rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_add(1), 101);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_add(127), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_add(self, rhs: Self) -> Self {\n            intrinsics::saturating_add(self, rhs)\n        }\n\n        /// Saturating addition with a signed integer. Computes `self + rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_add_signed(-2), 0);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_add_signed(4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_add_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_add(rhs as Self);\n            if overflow == (rhs < 0) {\n                res\n            } else if overflow {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer subtraction. Computes `self - rhs`, saturating\n        /// at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".saturating_sub(27), 73);\")]\n        #[doc = concat!(\"assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[inline(always)]\n        pub const fn saturating_sub(self, rhs: Self) -> Self {\n            intrinsics::saturating_sub(self, rhs)\n        }\n\n        /// Saturating integer subtraction. Computes `self` - `rhs`, saturating at\n        /// the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(2), 0);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".saturating_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).saturating_sub_signed(-4), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_sub_signed(self, rhs: $SignedT) -> Self {\n            let (res, overflow) = self.overflowing_sub_signed(rhs);\n\n            if !overflow {\n                res\n            } else if rhs < 0 {\n                Self::MAX\n            } else {\n                0\n            }\n        }\n\n        /// Saturating integer multiplication. Computes `self * rhs`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".saturating_mul(10), 20);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($SelfT),\"::MAX);\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_saturating_int_methods\", since = \"1.47.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_mul(self, rhs: Self) -> Self {\n            match self.checked_mul(rhs) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Saturating integer division. Computes `self / rhs`, saturating at the\n        /// numeric bounds instead of overflowing.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".saturating_div(2), 2);\")]\n        ///\n        /// ```\n        #[stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[rustc_const_stable(feature = \"saturating_div\", since = \"1.58.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn saturating_div(self, rhs: Self) -> Self {\n            // on unsigned types, there is no overflow in integer division\n            self.wrapping_div(rhs)\n        }\n\n        /// Saturating integer exponentiation. Computes `self.pow(exp)`,\n        /// saturating at the numeric bounds instead of overflowing.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(4\", stringify!($SelfT), \".saturating_pow(3), 64);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT), \"::MAX);\")]\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn saturating_pow(self, exp: u32) -> Self {\n            match self.checked_pow(exp) {\n                Some(x) => x,\n                None => Self::MAX,\n            }\n        }\n\n        /// Wrapping (modular) addition. Computes `self + rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(55), 255);\")]\n        #[doc = concat!(\"assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::MAX), 199);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_add(self, rhs: Self) -> Self {\n            intrinsics::wrapping_add(self, rhs)\n        }\n\n        /// Wrapping (modular) addition with a signed integer. Computes\n        /// `self + rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(2), 3);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_add_signed(-2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_add_signed(4), 1);\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_add_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_add(rhs as Self)\n        }\n\n        /// Wrapping (modular) subtraction. Computes `self - rhs`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(100), 0);\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::MAX), 101);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }\n\n        /// Wrapping (modular) subtraction with a signed integer. Computes\n        /// `self - rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(2), \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_sub_signed(-2), 3);\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).wrapping_sub_signed(-4), 1);\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_sub_signed(self, rhs: $SignedT) -> Self {\n            self.wrapping_sub(rhs as Self)\n        }\n\n        /// Wrapping (modular) multiplication. Computes `self *\n        /// rhs`, wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u8` is used here.\n        ///\n        /// ```\n        /// assert_eq!(10u8.wrapping_mul(12), 120);\n        /// assert_eq!(25u8.wrapping_mul(12), 44);\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }\n\n        /// Wrapping (modular) division. Computes `self / rhs`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping Euclidean division. Computes `self.div_euclid(rhs)`.\n        ///\n        /// Wrapped division on unsigned types is just normal division. There's\n        /// no way wrapping could ever happen. This function exists so that all\n        /// operations are accounted for in the wrapping operations. Since, for\n        /// the positive integers, all common definitions of division are equal,\n        /// this is exactly equal to `self.wrapping_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Wrapping (modular) remainder. Computes `self % rhs`.\n        ///\n        /// Wrapped remainder calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping Euclidean modulo. Computes `self.rem_euclid(rhs)`.\n        ///\n        /// Wrapped modulo calculation on unsigned types is just the regular\n        /// remainder calculation. There's no way wrapping could ever happen.\n        /// This function exists so that all operations are accounted for in the\n        /// wrapping operations. Since, for the positive integers, all common\n        /// definitions of division are equal, this is exactly equal to\n        /// `self.wrapping_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Wrapping (modular) negation. Computes `-self`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// Since unsigned types do not have negative equivalents\n        /// all applications of this function will wrap (except for `-0`).\n        /// For values smaller than the corresponding signed type's maximum\n        /// the result is the same as casting the corresponding signed value.\n        /// Any larger values are equivalent to `MAX + 1 - (val - MAX - 1)` where\n        /// `MAX` is the corresponding signed type's maximum.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0_\", stringify!($SelfT), \".wrapping_neg(), 0);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_neg(), 1);\")]\n        #[doc = concat!(\"assert_eq!(13_\", stringify!($SelfT), \".wrapping_neg(), (!13) + 1);\")]\n        #[doc = concat!(\"assert_eq!(42_\", stringify!($SelfT), \".wrapping_neg(), !(42 - 1));\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_neg(self) -> Self {\n            (0 as $SelfT).wrapping_sub(self)\n        }\n\n        /// Panic-free bitwise shift-left; yields `self << mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-left; the\n        /// RHS of a wrapping shift-left is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_left`](Self::rotate_left) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(7), 128);\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shl(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shl(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Panic-free bitwise shift-right; yields `self >> mask(rhs)`,\n        /// where `mask` removes any high-order bits of `rhs` that\n        /// would cause the shift to exceed the bitwidth of the type.\n        ///\n        /// Note that this is *not* the same as a rotate-right; the\n        /// RHS of a wrapping shift-right is restricted to the range\n        /// of the type, rather than the bits shifted out of the LHS\n        /// being returned to the other end. The primitive integer\n        /// types all implement a [`rotate_right`](Self::rotate_right) function,\n        /// which may be what you want instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(7), 1);\")]\n        #[doc = concat!(\"assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\")]\n        /// ```\n        #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn wrapping_shr(self, rhs: u32) -> Self {\n            // SAFETY: the masking by the bitsize of the type ensures that we do not shift\n            // out of bounds\n            unsafe {\n                self.unchecked_shr(rhs & (Self::BITS - 1))\n            }\n        }\n\n        /// Wrapping (modular) exponentiation. Computes `self.pow(exp)`,\n        /// wrapping around at the boundary of the type.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_pow(5), 243);\")]\n        /// assert_eq!(3u8.wrapping_pow(6), 217);\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary.\n                acc.wrapping_mul(base)\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc.wrapping_mul(base);\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base.wrapping_mul(base);\n                }\n            }\n        }\n\n        /// Calculates `self` + `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` + `rhs` + `carry` and returns a tuple containing\n        /// the sum and the output carry.\n        ///\n        /// Performs \"ternary addition\" of two integer operands and a carry-in\n        /// bit, and returns an output integer and a carry-out bit. This allows\n        /// chaining together multiple additions to create a wider addition, and\n        /// can be useful for bignum addition.\n        ///\n        #[doc = concat!(\"This can be thought of as a \", stringify!($BITS), \"-bit \\\"full adder\\\", in the electronics sense.\")]\n        ///\n        /// If the input carry is false, this method is equivalent to\n        /// [`overflowing_add`](Self::overflowing_add), and the output carry is\n        /// equal to the overflow flag. Note that although carry and overflow\n        /// flags are similar for unsigned integers, they are different for\n        /// signed integers.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    3  MAX    (a = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        #[doc = concat!(\"// +  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    9    6    (sum = 9  2^\", stringify!($BITS), \" + 6)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (3, \", stringify!($SelfT), \"::MAX);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let carry0 = false;\n        ///\n        /// let (sum0, carry1) = a0.carrying_add(b0, carry0);\n        /// assert_eq!(carry1, true);\n        /// let (sum1, carry2) = a1.carrying_add(b1, carry1);\n        /// assert_eq!(carry2, false);\n        ///\n        /// assert_eq!((sum1, sum0), (9, 6));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_add(self, rhs: Self, carry: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_add(rhs);\n            let (b, c2) = a.overflowing_add(carry as $SelfT);\n            // Ideally LLVM would know this is disjoint without us telling them,\n            // but it doesn't <https://github.com/llvm/llvm-project/issues/118162>\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have overflowed, but if we did then\n            // `a` is at most `MAX-1`, which means that `c2` cannot possibly\n            // overflow because it's adding at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` + `rhs` with a signed `rhs`.\n        ///\n        /// Returns a tuple of the addition along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_add_signed(-2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_add_signed(4), (1, true));\")]\n        /// ```\n        #[stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[rustc_const_stable(feature = \"mixed_integer_ops\", since = \"1.66.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_add_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflowed) = self.overflowing_add(rhs as Self);\n            (res, overflowed ^ (rhs < 0))\n        }\n\n        /// Calculates `self` - `rhs`.\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_sub(2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT), \"::MAX, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates `self` &minus; `rhs` &minus; `borrow` and returns a tuple\n        /// containing the difference and the output borrow.\n        ///\n        /// Performs \"ternary subtraction\" by subtracting both an integer\n        /// operand and a borrow-in bit from `self`, and returns an output\n        /// integer and a borrow-out bit. This allows chaining together multiple\n        /// subtractions to create a wider subtraction, and can be useful for\n        /// bignum subtraction.\n        ///\n        /// # Examples\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        #[doc = concat!(\"//    9    6    (a = 9  2^\", stringify!($BITS), \" + 6)\")]\n        #[doc = concat!(\"// -  5    7    (b = 5  2^\", stringify!($BITS), \" + 7)\")]\n        /// // ---------\n        #[doc = concat!(\"//    3  MAX    (diff = 3  2^\", stringify!($BITS), \" + 2^\", stringify!($BITS), \" - 1)\")]\n        ///\n        #[doc = concat!(\"let (a1, a0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (9, 6);\")]\n        #[doc = concat!(\"let (b1, b0): (\", stringify!($SelfT), \", \", stringify!($SelfT), \") = (5, 7);\")]\n        /// let borrow0 = false;\n        ///\n        /// let (diff0, borrow1) = a0.borrowing_sub(b0, borrow0);\n        /// assert_eq!(borrow1, true);\n        /// let (diff1, borrow2) = a1.borrowing_sub(b1, borrow1);\n        /// assert_eq!(borrow2, false);\n        ///\n        #[doc = concat!(\"assert_eq!((diff1, diff0), (3, \", stringify!($SelfT), \"::MAX));\")]\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn borrowing_sub(self, rhs: Self, borrow: bool) -> (Self, bool) {\n            // note: longer-term this should be done via an intrinsic, but this has been shown\n            //   to generate optimal code for now, and LLVM doesn't have an equivalent intrinsic\n            let (a, c1) = self.overflowing_sub(rhs);\n            let (b, c2) = a.overflowing_sub(borrow as $SelfT);\n            // SAFETY: Only one of `c1` and `c2` can be set.\n            // For c1 to be set we need to have underflowed, but if we did then\n            // `a` is nonzero, which means that `c2` cannot possibly\n            // underflow because it's subtracting at most `1` (since it came from `bool`)\n            (b, unsafe { intrinsics::disjoint_bitor(c1, c2) })\n        }\n\n        /// Calculates `self` - `rhs` with a signed `rhs`\n        ///\n        /// Returns a tuple of the subtraction along with a boolean indicating\n        /// whether an arithmetic overflow would occur. If an overflow would\n        /// have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(mixed_integer_ops_unsigned_sub)]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(2), (\", stringify!($SelfT), \"::MAX, true));\")]\n        #[doc = concat!(\"assert_eq!(1\", stringify!($SelfT), \".overflowing_sub_signed(-2), (3, false));\")]\n        #[doc = concat!(\"assert_eq!((\", stringify!($SelfT), \"::MAX - 2).overflowing_sub_signed(-4), (1, true));\")]\n        /// ```\n        #[unstable(feature = \"mixed_integer_ops_unsigned_sub\", issue = \"126043\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_sub_signed(self, rhs: $SignedT) -> (Self, bool) {\n            let (res, overflow) = self.overflowing_sub(rhs as Self);\n\n            (res, overflow ^ (rhs < 0))\n        }\n\n        /// Computes the absolute difference between `self` and `other`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(80), 20\", stringify!($SelfT), \");\")]\n        #[doc = concat!(\"assert_eq!(100\", stringify!($SelfT), \".abs_diff(110), 10\", stringify!($SelfT), \");\")]\n        /// ```\n        #[stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[rustc_const_stable(feature = \"int_abs_diff\", since = \"1.60.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn abs_diff(self, other: Self) -> Self {\n            if size_of::<Self>() == 1 {\n                // Trick LLVM into generating the psadbw instruction when SSE2\n                // is available and this function is autovectorized for u8's.\n                (self as i32).wrapping_sub(other as i32).abs() as Self\n            } else {\n                if self < other {\n                    other - self\n                } else {\n                    self - other\n                }\n            }\n        }\n\n        /// Calculates the multiplication of `self` and `rhs`.\n        ///\n        /// Returns a tuple of the multiplication along with a boolean\n        /// indicating whether an arithmetic overflow would occur. If an\n        /// overflow would have occurred then the wrapped value is returned.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// assert_eq!(5u32.overflowing_mul(2), (10, false));\n        /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                          without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }\n\n        /// Calculates the complete product `self * rhs` without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// If you also need to add a carry to the wide result, then you want\n        /// [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.widening_mul(2), (10, 0));\n        /// assert_eq!(1_000_000_000u32.widening_mul(10), (1410065408, 2));\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn widening_mul(self, rhs: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, 0, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need the `carry`, then you can use [`Self::widening_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types.\n        /// Which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul(2, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul(2, 10), (20, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul(10, 10), (1410065418, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(0, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core operation needed for scalar multiplication when\n        /// implementing it for wider-than-native types.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// fn scalar_mul_eq(little_endian_digits: &mut Vec<u16>, multiplicand: u16) {\n        ///     let mut carry = 0;\n        ///     for d in little_endian_digits.iter_mut() {\n        ///         (*d, carry) = d.carrying_mul(multiplicand, carry);\n        ///     }\n        ///     if carry != 0 {\n        ///         little_endian_digits.push(carry);\n        ///     }\n        /// }\n        ///\n        /// let mut v = vec![10, 20];\n        /// scalar_mul_eq(&mut v, 3);\n        /// assert_eq!(v, [30, 60]);\n        ///\n        /// assert_eq!(0x87654321_u64 * 0xFEED, 0x86D3D159E38D);\n        /// let mut v = vec![0x4321, 0x8765];\n        /// scalar_mul_eq(&mut v, 0xFEED);\n        /// assert_eq!(v, [0xE38D, 0xD159, 0x86D3]);\n        /// ```\n        ///\n        /// If `carry` is zero, this is similar to [`overflowing_mul`](Self::overflowing_mul),\n        /// except that it gives the value of the overflow instead of just whether one happened:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// let r = u8::carrying_mul(7, 13, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(7, 13));\n        /// let r = u8::carrying_mul(13, 42, 0);\n        /// assert_eq!((r.0, r.1 != 0), u8::overflowing_mul(13, 42));\n        /// ```\n        ///\n        /// The value of the first field in the returned tuple matches what you'd get\n        /// by combining the [`wrapping_mul`](Self::wrapping_mul) and\n        /// [`wrapping_add`](Self::wrapping_add) methods:\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(\n        ///     789_u16.carrying_mul(456, 123).0,\n        ///     789_u16.wrapping_mul(456).wrapping_add(123),\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul(self, rhs: Self, carry: Self) -> (Self, Self) {\n            Self::carrying_mul_add(self, rhs, carry, 0)\n        }\n\n        /// Calculates the \"full multiplication\" `self * rhs + carry1 + carry2`\n        /// without the possibility to overflow.\n        ///\n        /// This returns the low-order (wrapping) bits and the high-order (overflow) bits\n        /// of the result as two separate values, in that order.\n        ///\n        /// Performs \"long multiplication\" which takes in an extra amount to add, and may return an\n        /// additional amount of overflow. This allows for chaining together multiple\n        /// multiplications to create \"big integers\" which represent larger values.\n        ///\n        /// If you don't need either `carry`, then you can use [`Self::widening_mul`] instead,\n        /// and if you only need one `carry`, then you can use [`Self::carrying_mul`] instead.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// Please note that this example is shared between integer types,\n        /// which explains why `u32` is used here.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        /// assert_eq!(5u32.carrying_mul_add(2, 0, 0), (10, 0));\n        /// assert_eq!(5u32.carrying_mul_add(2, 10, 10), (30, 0));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 0, 0), (1410065408, 2));\n        /// assert_eq!(1_000_000_000u32.carrying_mul_add(10, 10, 10), (1410065428, 2));\n        #[doc = concat!(\"assert_eq!(\",\n            stringify!($SelfT), \"::MAX.carrying_mul_add(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX), \",\n            \"(\", stringify!($SelfT), \"::MAX, \", stringify!($SelfT), \"::MAX));\"\n        )]\n        /// ```\n        ///\n        /// This is the core per-digit operation for \"grade school\" O(n) multiplication.\n        ///\n        /// Please note that this example is shared between integer types,\n        /// using `u8` for simplicity of the demonstration.\n        ///\n        /// ```\n        /// #![feature(bigint_helper_methods)]\n        ///\n        /// fn quadratic_mul<const N: usize>(a: [u8; N], b: [u8; N]) -> [u8; N] {\n        ///     let mut out = [0; N];\n        ///     for j in 0..N {\n        ///         let mut carry = 0;\n        ///         for i in 0..(N - j) {\n        ///             (out[j + i], carry) = u8::carrying_mul_add(a[i], b[j], out[j + i], carry);\n        ///         }\n        ///     }\n        ///     out\n        /// }\n        ///\n        /// // -1 * -1 == 1\n        /// assert_eq!(quadratic_mul([0xFF; 3], [0xFF; 3]), [1, 0, 0]);\n        ///\n        /// assert_eq!(u32::wrapping_mul(0x9e3779b9, 0x7f4a7c15), 0xCFFC982D);\n        /// assert_eq!(\n        ///     quadratic_mul(u32::to_le_bytes(0x9e3779b9), u32::to_le_bytes(0x7f4a7c15)),\n        ///     u32::to_le_bytes(0xCFFC982D)\n        /// );\n        /// ```\n        #[unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[rustc_const_unstable(feature = \"bigint_helper_methods\", issue = \"85532\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn carrying_mul_add(self, rhs: Self, carry: Self, add: Self) -> (Self, Self) {\n            intrinsics::carrying_mul_add(self, rhs, carry, add)\n        }\n\n        /// Calculates the divisor when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the quotient of Euclidean division `self.div_euclid(rhs)`.\n        ///\n        /// Returns a tuple of the divisor along with a boolean indicating\n        /// whether an arithmetic overflow would occur. Note that for unsigned\n        /// integers overflow never occurs, so the second value is always\n        /// `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self.overflowing_div(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n            (self / rhs, false)\n        }\n\n        /// Calculates the remainder when `self` is divided by `rhs`.\n        ///\n        /// Returns a tuple of the remainder after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_overflowing_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Calculates the remainder `self.rem_euclid(rhs)` as if by Euclidean division.\n        ///\n        /// Returns a tuple of the modulo after dividing along with a boolean\n        /// indicating whether an arithmetic overflow would occur. Note that for\n        /// unsigned integers overflow never occurs, so the second value is\n        /// always `false`.\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this operation\n        /// is exactly equal to `self.overflowing_rem(rhs)`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[track_caller]\n        pub const fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n            (self % rhs, false)\n        }\n\n        /// Negates self in an overflowing fashion.\n        ///\n        /// Returns `!self + 1` using wrapping operations to return the value\n        /// that represents the negation of this unsigned value. Note that for\n        /// positive unsigned values overflow always occurs, but negating 0 does\n        /// not overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".overflowing_neg(), (0, false));\")]\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".overflowing_neg(), (-2i32 as \", stringify!($SelfT), \", true));\")]\n        /// ```\n        #[inline(always)]\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn overflowing_neg(self) -> (Self, bool) {\n            ((!self).wrapping_add(1), self != 0)\n        }\n\n        /// Shifts self left by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(4), (0x10, false));\")]\n        #[doc = concat!(\"assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shl(\", stringify!($BITS_MINUS_ONE), \"), (0, false));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shl(rhs), rhs >= Self::BITS)\n        }\n\n        /// Shifts self right by `rhs` bits.\n        ///\n        /// Returns a tuple of the shifted version of self along with a boolean\n        /// indicating whether the shift value was larger than or equal to the\n        /// number of bits. If the shift value is too large, then value is\n        /// masked (N-1) where N is the number of bits, and this value is then\n        /// used to perform the shift.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(4), (0x1, false));\")]\n        #[doc = concat!(\"assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\")]\n        /// ```\n        #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n        #[rustc_const_stable(feature = \"const_wrapping_math\", since = \"1.32.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n            (self.wrapping_shr(rhs), rhs >= Self::BITS)\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// Returns a tuple of the exponentiation along with a bool indicating\n        /// whether an overflow happened.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".overflowing_pow(5), (243, false));\")]\n        /// assert_eq!(3u8.overflowing_pow(6), (217, true));\n        /// ```\n        #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n            if exp == 0{\n                return (1,false);\n            }\n            let mut base = self;\n            let mut acc: Self = 1;\n            let mut overflown = false;\n            // Scratch space for storing results of overflowing_mul.\n            let mut r;\n\n            loop {\n                if (exp & 1) == 1 {\n                    r = acc.overflowing_mul(base);\n                    // since exp!=0, finally the exp must be 1.\n                    if exp == 1 {\n                        r.1 |= overflown;\n                        return r;\n                    }\n                    acc = r.0;\n                    overflown |= r.1;\n                }\n                exp /= 2;\n                r = base.overflowing_mul(base);\n                base = r.0;\n                overflown |= r.1;\n            }\n        }\n\n        /// Raises self to the power of `exp`, using exponentiation by squaring.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn pow(self, mut exp: u32) -> Self {\n            if exp == 0 {\n                return 1;\n            }\n            let mut base = self;\n            let mut acc = 1;\n\n            if intrinsics::is_val_statically_known(exp) {\n                while exp > 1 {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n\n                // since exp!=0, finally the exp must be 1.\n                // Deal with the final bit of the exponent separately, since\n                // squaring the base afterwards is not necessary and may cause a\n                // needless overflow.\n                acc * base\n            } else {\n                // This is faster than the above when the exponent is not known\n                // at compile time. We can't use the same code for the constant\n                // exponent case because LLVM is currently unable to unroll\n                // this loop.\n                loop {\n                    if (exp & 1) == 1 {\n                        acc = acc * base;\n                        // since exp!=0, finally the exp must be 1.\n                        if exp == 1 {\n                            return acc;\n                        }\n                    }\n                    exp /= 2;\n                    base = base * base;\n                }\n            }\n        }\n\n        /// Returns the square root of the number, rounded down.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        /// ```\n        #[doc = concat!(\"assert_eq!(10\", stringify!($SelfT), \".isqrt(), 3);\")]\n        /// ```\n        #[stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[rustc_const_stable(feature = \"isqrt\", since = \"1.84.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn isqrt(self) -> Self {\n            let result = crate::num::int_sqrt::$ActualT(self as $ActualT) as $SelfT;\n\n            // Inform the optimizer what the range of outputs is. If testing\n            // `core` crashes with no panic message and a `num::int_sqrt::u*`\n            // test failed, it's because your edits caused these assertions or\n            // the assertions in `fn isqrt` of `nonzero.rs` to become false.\n            //\n            // SAFETY: Integer square root is a monotonically nondecreasing\n            // function, which means that increasing the input will never\n            // cause the output to decrease. Thus, since the input for unsigned\n            // integers is bounded by `[0, <$ActualT>::MAX]`, sqrt(n) will be\n            // bounded by `[sqrt(0), sqrt(<$ActualT>::MAX)]`.\n            unsafe {\n                const MAX_RESULT: $SelfT = crate::num::int_sqrt::$ActualT(<$ActualT>::MAX) as $SelfT;\n                crate::hint::assert_unchecked(result <= MAX_RESULT);\n            }\n\n            result\n        }\n\n        /// Performs Euclidean division.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self / rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\")]\n        /// ```\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_euclid(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n\n        /// Calculates the least remainder of `self (mod rhs)`.\n        ///\n        /// Since, for the positive integers, all common\n        /// definitions of division are equal, this\n        /// is exactly equal to `self % rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\")]\n        /// ```\n        #[doc(alias = \"modulo\", alias = \"mod\")]\n        #[stable(feature = \"euclidean_division\", since = \"1.38.0\")]\n        #[rustc_const_stable(feature = \"const_euclidean_int_methods\", since = \"1.52.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn rem_euclid(self, rhs: Self) -> Self {\n            self % rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n        ///\n        /// This is the same as performing `self / rhs` for all unsigned integers.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(int_roundings)]\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n        /// ```\n        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline(always)]\n        #[track_caller]\n        pub const fn div_floor(self, rhs: Self) -> Self {\n            self / rhs\n        }\n\n        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[track_caller]\n        pub const fn div_ceil(self, rhs: Self) -> Self {\n            let d = self / rhs;\n            let r = self % rhs;\n            if r > 0 {\n                d + 1\n            } else {\n                d\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`.\n        ///\n        /// # Panics\n        ///\n        /// This function will panic if `rhs` is zero.\n        ///\n        /// ## Overflow behavior\n        ///\n        /// On overflow, this function will panic if overflow checks are enabled (default in debug\n        /// mode) and wrap if overflow checks are disabled (default in release mode).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n            match self % rhs {\n                0 => self,\n                r => self + (rhs - r)\n            }\n        }\n\n        /// Calculates the smallest value greater than or equal to `self` that\n        /// is a multiple of `rhs`. Returns `None` if `rhs` is zero or the\n        /// operation would result in overflow.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n        /// ```\n        #[stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[rustc_const_stable(feature = \"int_roundings1\", since = \"1.73.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n            match try_opt!(self.checked_rem(rhs)) {\n                0 => Some(self),\n                // rhs - r cannot overflow because r is smaller than rhs\n                r => self.checked_add(rhs - r)\n            }\n        }\n\n        /// Returns `true` if `self` is an integer multiple of `rhs`, and false otherwise.\n        ///\n        /// This function is equivalent to `self % rhs == 0`, except that it will not panic\n        /// for `rhs == 0`. Instead, `0.is_multiple_of(0) == true`, and for any non-zero `n`,\n        /// `n.is_multiple_of(0) == false`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(6_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        #[doc = concat!(\"assert!(!5_\", stringify!($SelfT), \".is_multiple_of(2));\")]\n        ///\n        #[doc = concat!(\"assert!(0_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        #[doc = concat!(\"assert!(!6_\", stringify!($SelfT), \".is_multiple_of(0));\")]\n        /// ```\n        #[stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[rustc_const_stable(feature = \"unsigned_is_multiple_of\", since = \"CURRENT_RUSTC_VERSION\")]\n        #[must_use]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn is_multiple_of(self, rhs: Self) -> bool {\n            match rhs {\n                0 => self == 0,\n                _ => self % rhs == 0,\n            }\n        }\n\n        /// Returns `true` if and only if `self == 2^k` for some `k`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert!(16\", stringify!($SelfT), \".is_power_of_two());\")]\n        #[doc = concat!(\"assert!(!10\", stringify!($SelfT), \".is_power_of_two());\")]\n        /// ```\n        #[must_use]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_is_power_of_two\", since = \"1.32.0\")]\n        #[inline(always)]\n        pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }\n\n        // Returns one less than next power of two.\n        // (For 8u8 next power of two is 8u8 and for 6u8 it is 8u8)\n        //\n        // 8u8.one_less_than_next_power_of_two() == 7\n        // 6u8.one_less_than_next_power_of_two() == 7\n        //\n        // This method cannot overflow, as in the `next_power_of_two`\n        // overflow cases it instead ends up returning the maximum value\n        // of the type, and can return 0 for 0.\n        #[inline]\n        const fn one_less_than_next_power_of_two(self) -> Self {\n            if self <= 1 { return 0; }\n\n            let p = self - 1;\n            // SAFETY: Because `p > 0`, it cannot consist entirely of leading zeros.\n            // That means the shift is always in-bounds, and some processors\n            // (such as intel pre-haswell) have more efficient ctlz\n            // intrinsics when the argument is non-zero.\n            let z = unsafe { intrinsics::ctlz_nonzero(p) };\n            <$SelfT>::MAX >> z\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`.\n        ///\n        /// When return value overflows (i.e., `self > (1 << (N-1))` for type\n        /// `uN`), it panics in debug mode and the return value is wrapped to 0 in\n        /// release mode (the only situation in which this method can return 0).\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(0\", stringify!($SelfT), \".next_power_of_two(), 1);\")]\n        /// ```\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        #[rustc_inherit_overflow_checks]\n        pub const fn next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two() + 1\n        }\n\n        /// Returns the smallest power of two greater than or equal to `self`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// `None` is returned, otherwise the power of two is wrapped in `Some`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".checked_next_power_of_two(), Some(2));\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".checked_next_power_of_two(), Some(4));\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_power_of_two(), None);\")]\n        /// ```\n        #[inline]\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_const_stable(feature = \"const_int_pow\", since = \"1.50.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn checked_next_power_of_two(self) -> Option<Self> {\n            self.one_less_than_next_power_of_two().checked_add(1)\n        }\n\n        /// Returns the smallest power of two greater than or equal to `n`. If\n        /// the next power of two is greater than the type's maximum value,\n        /// the return value is wrapped to `0`.\n        ///\n        /// # Examples\n        ///\n        /// Basic usage:\n        ///\n        /// ```\n        /// #![feature(wrapping_next_power_of_two)]\n        ///\n        #[doc = concat!(\"assert_eq!(2\", stringify!($SelfT), \".wrapping_next_power_of_two(), 2);\")]\n        #[doc = concat!(\"assert_eq!(3\", stringify!($SelfT), \".wrapping_next_power_of_two(), 4);\")]\n        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.wrapping_next_power_of_two(), 0);\")]\n        /// ```\n        #[inline]\n        #[unstable(feature = \"wrapping_next_power_of_two\", issue = \"32463\",\n                   reason = \"needs decision on wrapping behavior\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        pub const fn wrapping_next_power_of_two(self) -> Self {\n            self.one_less_than_next_power_of_two().wrapping_add(1)\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// big-endian (network) byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_be_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $be_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_be_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_be().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// little-endian byte order.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_le_bytes();\")]\n        #[doc = concat!(\"assert_eq!(bytes, \", $le_bytes, \");\")]\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        #[inline]\n        pub const fn to_le_bytes(self) -> [u8; size_of::<Self>()] {\n            self.to_le().to_ne_bytes()\n        }\n\n        /// Returns the memory representation of this integer as a byte array in\n        /// native byte order.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// should use [`to_be_bytes`] or [`to_le_bytes`], as appropriate,\n        /// instead.\n        ///\n        #[doc = $to_xe_bytes_doc]\n        ///\n        /// [`to_be_bytes`]: Self::to_be_bytes\n        /// [`to_le_bytes`]: Self::to_le_bytes\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\")]\n        /// assert_eq!(\n        ///     bytes,\n        ///     if cfg!(target_endian = \"big\") {\n        #[doc = concat!(\"        \", $be_bytes)]\n        ///     } else {\n        #[doc = concat!(\"        \", $le_bytes)]\n        ///     }\n        /// );\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use = \"this returns the result of the operation, \\\n                      without modifying the original\"]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute them to arrays of bytes\n        #[inline]\n        pub const fn to_ne_bytes(self) -> [u8; size_of::<Self>()] {\n            // SAFETY: integers are plain old datatypes so we can always transmute them to\n            // arrays of bytes\n            unsafe { mem::transmute(self) }\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in big endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_be_bytes(\", $be_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_be_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_be_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_be_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_be(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its representation\n        /// as a byte array in little endian.\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_le_bytes(\", $le_bytes, \");\")]\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_le_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_le_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        #[inline]\n        pub const fn from_le_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            Self::from_le(Self::from_ne_bytes(bytes))\n        }\n\n        /// Creates a native endian integer value from its memory representation\n        /// as a byte array in native endianness.\n        ///\n        /// As the target platform's native endianness is used, portable code\n        /// likely wants to use [`from_be_bytes`] or [`from_le_bytes`], as\n        /// appropriate instead.\n        ///\n        /// [`from_be_bytes`]: Self::from_be_bytes\n        /// [`from_le_bytes`]: Self::from_le_bytes\n        ///\n        #[doc = $from_xe_bytes_doc]\n        ///\n        /// # Examples\n        ///\n        /// ```\n        #[doc = concat!(\"let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\")]\n        #[doc = concat!(\"    \", $be_bytes, \"\")]\n        /// } else {\n        #[doc = concat!(\"    \", $le_bytes, \"\")]\n        /// });\n        #[doc = concat!(\"assert_eq!(value, \", $swap_op, \");\")]\n        /// ```\n        ///\n        /// When starting from a slice rather than an array, fallible conversion APIs can be used:\n        ///\n        /// ```\n        #[doc = concat!(\"fn read_ne_\", stringify!($SelfT), \"(input: &mut &[u8]) -> \", stringify!($SelfT), \" {\")]\n        #[doc = concat!(\"    let (int_bytes, rest) = input.split_at(size_of::<\", stringify!($SelfT), \">());\")]\n        ///     *input = rest;\n        #[doc = concat!(\"    \", stringify!($SelfT), \"::from_ne_bytes(int_bytes.try_into().unwrap())\")]\n        /// }\n        /// ```\n        #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n        #[rustc_const_stable(feature = \"const_int_conversion\", since = \"1.44.0\")]\n        #[must_use]\n        // SAFETY: const sound because integers are plain old datatypes so we can always\n        // transmute to them\n        #[inline]\n        pub const fn from_ne_bytes(bytes: [u8; size_of::<Self>()]) -> Self {\n            // SAFETY: integers are plain old datatypes so we can always transmute to them\n            unsafe { mem::transmute(bytes) }\n        }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MIN\", \"`] instead.\")]\n        ///\n        /// Returns the smallest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MIN` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_min_value\")]\n        pub const fn min_value() -> Self { Self::MIN }\n\n        /// New code should prefer to use\n        #[doc = concat!(\"[`\", stringify!($SelfT), \"::MAX\", \"`] instead.\")]\n        ///\n        /// Returns the largest value that can be represented by this integer type.\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        #[rustc_promotable]\n        #[inline(always)]\n        #[rustc_const_stable(feature = \"const_max_value\", since = \"1.32.0\")]\n        #[deprecated(since = \"TBD\", note = \"replaced by the `MAX` associated constant on this type\")]\n        #[rustc_diagnostic_item = concat!(stringify!($SelfT), \"_legacy_fn_max_value\")]\n        pub const fn max_value() -> Self { Self::MAX }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 99, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h9a1b2136aaf399ceE",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 164, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17hee37ceed2bfa2394E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 94, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17h21f756518b770eccE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17ha5c466fea0230c4cE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 97, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h378fd67f26708e37E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 193, name: \"core::slice::<impl [T]>::as_chunks_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::as_chunks_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked18precondition_check17hc6b1c0191b99d1afE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 208, name: \"core::slice::<impl [T]>::split_at_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::split_at_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked18precondition_check17hde1a7c2f889b823bE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [[usize; 4]]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h1f796214e285bd05E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 174, name: \"core::slice::<impl [T]>::align_to\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8align_to17h3f2f55440dbd3412E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is  don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 213, name: \"core::slice::<impl [T]>::align_to_offsets\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to_offsets::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16align_to_offsets17h9a870748ec74d22cE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17h5b81b8ee56453ba4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9261551842730f07E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h6fde5a5a7a6da893E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h0771b4bddc48611aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h8b631703f7d638d3E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 179, name: \"core::slice::<impl [T]>::as_chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$9as_chunks17h62f5495583e80f1aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len_rounded_down = self.len() / N * N;\n        // SAFETY: The rounded-down value is always the same or smaller than the\n        // original length, and thus must be in-bounds of the slice.\n        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 192, name: \"core::slice::<impl [T]>::as_chunks_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks_unchecked::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked17h8e9f62deb4bed8e1E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        );\n        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n        let new_len = unsafe { exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17hced9934679723f28E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 177, name: \"core::slice::<impl [T]>::chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::chunks",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6chunks17ha09721e0e969e33aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert!(chunk_size != 0, \"chunk size must be non-zero\");\n        Chunks::new(self, chunk_size)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 175, name: \"core::slice::<impl [T]>::is_empty\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::is_empty",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8is_empty17ha518b9eb9d09acddE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9bded35725a0f34bE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h4760363bd3d8df7dE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h33e3be9e163f3d84E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h2ba5f3ee616a9de4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[[usize; 4]]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17hd4a47bd844608dd0E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[usize]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17h59a4497cf99cfe33E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hfe1187add6301ee6E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 53, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17h8a7a6798d7274ac2E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 61, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17hf4eef7fbc74a1befE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 60, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::RangeTo<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h949054447ff215bbE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 132, name: \"core::str::<impl str>::len\" }",
        "func": {
          "name": "core::str::<impl str>::len",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$3len17hfb2957ffd9c6ce7eE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn len(&self) -> usize {\n        self.as_bytes().len()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"core::str::count::char_count_general_case\" }",
        "func": {
          "name": "core::str::count::char_count_general_case",
          "mangled_name": "_ZN4core3str5count23char_count_general_case17h9194c83a4785e6c0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn char_count_general_case(s: &[u8]) -> usize {\n    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"core::str::count::char_count_general_case::{closure#0}\" }",
        "func": {
          "name": "core::str::count::char_count_general_case::{closure#0}",
          "mangled_name": "_ZN4core3str5count23char_count_general_case28_$u7b$$u7b$closure$u7d$$u7d$17h8c6b087357e2a8f4E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "|&&byte| !super::validations::utf8_is_cont_byte(byte)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"core::str::count::contains_non_continuation_byte\" }",
        "func": {
          "name": "core::str::count::contains_non_continuation_byte",
          "mangled_name": "_ZN4core3str5count30contains_non_continuation_byte17h8150072e604de7d0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn contains_non_continuation_byte(w: usize) -> usize {\n    const LSB: usize = usize::repeat_u8(0x01);\n    ((!w >> 7) | (w >> 6)) & LSB\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 131, name: \"core::str::count::count_chars\" }",
        "func": {
          "name": "core::str::count::count_chars",
          "mangled_name": "_ZN4core3str5count11count_chars17h0b5614dbcb4d5854E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "pub(super) fn count_chars(s: &str) -> usize {\n    if cfg!(feature = \"optimize_for_size\") || s.len() < USIZE_SIZE * UNROLL_INNER {\n        // Avoid entering the optimized implementation for strings where the\n        // difference is not likely to matter, or where it might even be slower.\n        // That said, a ton of thought was not spent on the particular threshold\n        // here, beyond \"this value seems to make sense\".\n        char_count_general_case(s.as_bytes())\n    } else {\n        do_count_chars(s)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"core::str::count::do_count_chars\" }",
        "func": {
          "name": "core::str::count::do_count_chars",
          "mangled_name": "_ZN4core3str5count14do_count_chars17h75afdc7e2f50899aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"core::str::count::sum_bytes_in_usize\" }",
        "func": {
          "name": "core::str::count::sum_bytes_in_usize",
          "mangled_name": "_ZN4core3str5count18sum_bytes_in_usize17hc03b30d90a1a0f5aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn sum_bytes_in_usize(values: usize) -> usize {\n    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n\n    let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h1284fdd8a7adc0acE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h50c6a72b9a3a9356E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 121, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits110_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..RangeTo$LT$usize$GT$$GT$13get_unchecked17h9efd459ee4ed494aE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 232, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17h49ef59a58d9bb16bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 240, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17h03004df802b34be6E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 238, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17h55891b813fb13403E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17h0975f6f46312483cE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 91, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17he2a6fec1e10ff0f2E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17h3d662b6d62900cb2E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"core::ub_checks::is_valid_allocation_size\" }",
        "func": {
          "name": "core::ub_checks::is_valid_allocation_size",
          "mangled_name": "_ZN4core9ub_checks24is_valid_allocation_size17he175ee6d2d332508E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {\n    let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };\n    len <= max_len\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 199, name: \"core::ub_checks::maybe_is_aligned_and_not_null\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null17hf7d8a735b5f451bcE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn maybe_is_aligned_and_not_null(\n    ptr: *const (),\n    align: usize,\n    is_zst: bool,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"core::ub_checks::maybe_is_aligned_and_not_null::runtime\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null::runtime",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null7runtime17ha348f106972c6a1eE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 27, name: \"kani::panic\" }",
        "func": {
          "name": "kani::panic",
          "mangled_name": "_ZN4kani5panic17h6190bada9522f78aE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn panic(message: &'static str) -> ! {\n            panic!(\"{}\", message)\n        }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 29, name: \"kani::panic::panic_cold_display\" }",
        "func": {
          "name": "kani::panic::panic_cold_display::<&str>",
          "mangled_name": "_ZN4kani5panic18panic_cold_display17h3c77492d46a89dbbE",
          "kind": "Item",
          "file": "library/core/src/panic.rs",
          "src": "const fn panic_cold_display<T: $crate::fmt::Display>(arg: &T) -> ! {\n            $crate::panicking::panic_display(arg)\n        }",
          "macro_backtrace_len": 4,
          "macro_backtrace": [
            {
              "callsite": "panic!(\"{}\", message)",
              "defsite": "pub macro panic_2021"
            },
            {
              "callsite": "panic!(\"{}\", message)",
              "defsite": "macro_rules! panic"
            },
            {
              "callsite": "kani_core::kani_intrinsics!(std)",
              "defsite": "macro_rules! kani_intrinsics"
            },
            {
              "callsite": "kani_core::kani_lib!(kani)",
              "defsite": "macro_rules! kani_lib"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"std::array::<impl std::iter::IntoIterator for &'a [T; N]>::into_iter\" }",
        "func": {
          "name": "std::array::<impl std::iter::IntoIterator for &[usize; 4]>::into_iter",
          "mangled_name": "_ZN4core5array98_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u3b$$u20$N$u5d$$GT$9into_iter17he1c19779b96d5e95E",
          "kind": "Item",
          "file": "library/core/src/array/mod.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 109, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217h09e466af457c502eE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17h3166298f1912938cE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 108, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h11b950ed06e40f3eE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h27528a2f99fa4e59E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt",
          "mangled_name": "_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u16$GT$2lt17h2e1d14712d03b1a2E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "partial_ord_methods_primitive_impl!()",
              "defsite": "macro_rules! partial_ord_methods_primitive_impl {\n        () => {\n            #[inline(always)]\n            fn lt(&self, other: &Self) -> bool { *self <  *other }\n            #[inline(always)]\n            fn le(&self, other: &Self) -> bool { *self <= *other }\n            #[inline(always)]\n            fn gt(&self, other: &Self) -> bool { *self >  *other }\n            #[inline(always)]\n            fn ge(&self, other: &Self) -> bool { *self >= *other }\n\n            // These implementations are the same for `Ord` or `PartialOrd` types\n            // because if either is NAN the `==` test will fail so we end up in\n            // the `Break` case and the comparison will correctly return `false`.\n\n            #[inline]\n            fn __chaining_lt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs < rhs) }\n            }\n            #[inline]\n            fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }\n            #[inline]\n            fn __chaining_gt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs > rhs) }\n            }\n            #[inline]\n            fn __chaining_ge(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs >= rhs) }\n            }\n        };\n    }"
            },
            {
              "callsite": "ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }",
              "defsite": "macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                    Some(crate::intrinsics::three_way_compare(*self, *other))\n                }\n\n                partial_ord_methods_primitive_impl!();\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &Self) -> Ordering {\n                    crate::intrinsics::three_way_compare(*self, *other)\n                }\n            }\n        )*)\n    }"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 219, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt",
          "mangled_name": "_ZN4core3cmp5impls57_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$usize$GT$2lt17h551740291a2e7191E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "partial_ord_methods_primitive_impl!()",
              "defsite": "macro_rules! partial_ord_methods_primitive_impl {\n        () => {\n            #[inline(always)]\n            fn lt(&self, other: &Self) -> bool { *self <  *other }\n            #[inline(always)]\n            fn le(&self, other: &Self) -> bool { *self <= *other }\n            #[inline(always)]\n            fn gt(&self, other: &Self) -> bool { *self >  *other }\n            #[inline(always)]\n            fn ge(&self, other: &Self) -> bool { *self >= *other }\n\n            // These implementations are the same for `Ord` or `PartialOrd` types\n            // because if either is NAN the `==` test will fail so we end up in\n            // the `Break` case and the comparison will correctly return `false`.\n\n            #[inline]\n            fn __chaining_lt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs < rhs) }\n            }\n            #[inline]\n            fn __chaining_le(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs <= rhs) }\n            }\n            #[inline]\n            fn __chaining_gt(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs > rhs) }\n            }\n            #[inline]\n            fn __chaining_ge(&self, other: &Self) -> ControlFlow<bool> {\n                let (lhs, rhs) = (*self, *other);\n                if lhs == rhs { Continue(()) } else { Break(lhs >= rhs) }\n            }\n        };\n    }"
            },
            {
              "callsite": "ord_impl! { char usize u8 u16 u32 u64 u128 isize i8 i16 i32 i64 i128 }",
              "defsite": "macro_rules! ord_impl {\n        ($($t:ty)*) => ($(\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl PartialOrd for $t {\n                #[inline]\n                fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n                    Some(crate::intrinsics::three_way_compare(*self, *other))\n                }\n\n                partial_ord_methods_primitive_impl!();\n            }\n\n            #[stable(feature = \"rust1\", since = \"1.0.0\")]\n            impl Ord for $t {\n                #[inline]\n                fn cmp(&self, other: &Self) -> Ordering {\n                    crate::intrinsics::three_way_compare(*self, *other)\n                }\n            }\n        )*)\n    }"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 217, name: \"std::cmp::min\" }",
        "func": {
          "name": "std::cmp::min::<usize>",
          "mangled_name": "_ZN4core3cmp3min17hdf73c061ba7372f8E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "pub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"std::convert::num::<impl std::convert::From<u16> for usize>::from\" }",
        "func": {
          "name": "std::convert::num::<impl std::convert::From<u16> for usize>::from",
          "mangled_name": "_ZN4core7convert3num66_$LT$impl$u20$core..convert..From$LT$u16$GT$$u20$for$u20$usize$GT$4from17hcff1e1e2ee4568c2E",
          "kind": "Item",
          "file": "library/core/src/convert/num.rs",
          "src": "fn from(small: $Small) -> Self {\n                small as Self\n            }",
          "macro_backtrace_len": 2,
          "macro_backtrace": [
            {
              "callsite": "impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        )",
              "defsite": "macro_rules! impl_from {\n    (bool => $Int:ty $(,)?) => {\n        impl_from!(\n            bool => $Int,\n            #[stable(feature = \"from_bool\", since = \"1.28.0\")],\n            concat!(\n                \"Converts a [`bool`] to [`\", stringify!($Int), \"`] losslessly.\\n\",\n                \"The resulting value is `0` for `false` and `1` for `true` values.\\n\",\n                \"\\n\",\n                \"# Examples\\n\",\n                \"\\n\",\n                \"```\\n\",\n                \"assert_eq!(\", stringify!($Int), \"::from(true), 1);\\n\",\n                \"assert_eq!(\", stringify!($Int), \"::from(false), 0);\\n\",\n                \"```\\n\",\n            ),\n        );\n    };\n    ($Small:ty => $Large:ty, #[$attr:meta] $(,)?) => {\n        impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        );\n    };\n    ($Small:ty => $Large:ty, #[$attr:meta], $doc:expr $(,)?) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline(always)]\n            fn from(small: $Small) -> Self {\n                small as Self\n            }\n        }\n    };\n}"
            },
            {
              "callsite": "impl_from!(u16 => usize, #[stable(feature = \"lossless_iusize_conv\", since = \"1.26.0\")])",
              "defsite": "macro_rules! impl_from {\n    (bool => $Int:ty $(,)?) => {\n        impl_from!(\n            bool => $Int,\n            #[stable(feature = \"from_bool\", since = \"1.28.0\")],\n            concat!(\n                \"Converts a [`bool`] to [`\", stringify!($Int), \"`] losslessly.\\n\",\n                \"The resulting value is `0` for `false` and `1` for `true` values.\\n\",\n                \"\\n\",\n                \"# Examples\\n\",\n                \"\\n\",\n                \"```\\n\",\n                \"assert_eq!(\", stringify!($Int), \"::from(true), 1);\\n\",\n                \"assert_eq!(\", stringify!($Int), \"::from(false), 0);\\n\",\n                \"```\\n\",\n            ),\n        );\n    };\n    ($Small:ty => $Large:ty, #[$attr:meta] $(,)?) => {\n        impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        );\n    };\n    ($Small:ty => $Large:ty, #[$attr:meta], $doc:expr $(,)?) => {\n        #[$attr]\n        impl From<$Small> for $Large {\n            // Rustdocs on the impl block show a \"[+] show undocumented items\" toggle.\n            // Rustdocs on functions do not.\n            #[doc = $doc]\n            #[inline(always)]\n            fn from(small: $Small) -> Self {\n                small as Self\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hbb45028c907195c1E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 32, name: \"std::fmt::Arguments::<'a>::new_v1\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_v1::<1, 1>",
          "mangled_name": "_ZN4core3fmt9Arguments6new_v117heaed1009cc26b388E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_v1<const P: usize, const A: usize>(\n        pieces: &'a [&'static str; P],\n        args: &'a [rt::Argument<'a>; A],\n    ) -> Arguments<'a> {\n        const { assert!(P >= A && P <= A + 1, \"invalid args\") }\n        Arguments { pieces, fmt: None, args }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 47, name: \"std::fmt::Formatter::<'a>::pad\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::pad",
          "mangled_name": "_ZN4core3fmt9Formatter3pad17he3971bd2e0830220E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front.\n        if self.options.flags & (flags::WIDTH_FLAG | flags::PRECISION_FLAG) == 0 {\n            return self.buf.write_str(s);\n        }\n\n        // The `precision` field can be interpreted as a maximum width for the\n        // string being formatted.\n        let (s, char_count) = if let Some(max_char_count) = self.options.get_precision() {\n            let mut iter = s.char_indices();\n            let remaining = match iter.advance_by(usize::from(max_char_count)) {\n                Ok(()) => 0,\n                Err(remaining) => remaining.get(),\n            };\n            // SAFETY: The offset of `.char_indices()` is guaranteed to be\n            // in-bounds and between character boundaries.\n            let truncated = unsafe { s.get_unchecked(..iter.offset()) };\n            (truncated, usize::from(max_char_count) - remaining)\n        } else {\n            // Use the optimized char counting algorithm for the full string.\n            (s, s.chars().count())\n        };\n\n        // The `width` field is more of a minimum width parameter at this point.\n        if char_count < usize::from(self.options.width) {\n            // If we're under the minimum width, then fill up the minimum width\n            // with the specified string + some alignment.\n            let post_padding =\n                self.padding(self.options.width - char_count as u16, Alignment::Left)?;\n            self.buf.write_str(s)?;\n            post_padding.write(self)\n        } else {\n            // If we're over the minimum width or there is no minimum width, we\n            // can just emit the string.\n            self.buf.write_str(s)\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 64, name: \"std::fmt::Formatter::<'a>::padding\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::padding",
          "mangled_name": "_ZN4core3fmt9Formatter7padding17h53f9e78fb4099400E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn padding(\n        &mut self,\n        padding: u16,\n        default: Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = self.options.get_align().unwrap_or(default);\n        let fill = self.options.get_fill();\n\n        let padding_left = match align {\n            Alignment::Left => 0,\n            Alignment::Right => padding,\n            Alignment::Center => padding / 2,\n        };\n\n        for _ in 0..padding_left {\n            self.buf.write_char(fill)?;\n        }\n\n        Ok(PostPadding::new(fill, padding - padding_left))\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 75, name: \"std::fmt::FormattingOptions::get_align\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_align",
          "mangled_name": "_ZN4core3fmt17FormattingOptions9get_align17h8b918746f9c015ffE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_align(&self) -> Option<Alignment> {\n        match self.flags & flags::ALIGN_BITS {\n            flags::ALIGN_LEFT => Some(Alignment::Left),\n            flags::ALIGN_RIGHT => Some(Alignment::Right),\n            flags::ALIGN_CENTER => Some(Alignment::Center),\n            _ => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 77, name: \"std::fmt::FormattingOptions::get_fill\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_fill",
          "mangled_name": "_ZN4core3fmt17FormattingOptions8get_fill17h43c04343d70b7042E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_fill(&self) -> char {\n        // SAFETY: We only ever put a valid `char` in the lower 21 bits of the flags field.\n        unsafe { char::from_u32_unchecked(self.flags & 0x1FFFFF) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 52, name: \"std::fmt::FormattingOptions::get_precision\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_precision",
          "mangled_name": "_ZN4core3fmt17FormattingOptions13get_precision17hbd80eaff3d1888beE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_precision(&self) -> Option<u16> {\n        if self.flags & flags::PRECISION_FLAG != 0 { Some(self.precision) } else { None }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 241, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17hb6106a7de1320d1cE",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 242, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17hefbcb2309e0ecbd0E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 220, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17ha3c2d65d0faea448E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 176, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17hed6aa9940a66cedcE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"std::iter::Filter::<I, P>::new\" }",
        "func": {
          "name": "std::iter::Filter::<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters6filter19Filter$LT$I$C$P$GT$3new17hc34a2f01600b7b29E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n        Filter { iter, predicate }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"std::iter::Map::<I, F>::new\" }",
        "func": {
          "name": "std::iter::Map::<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters3map16Map$LT$I$C$F$GT$3new17h53f0d55450f62c1dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n        Map { iter, f }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 148, name: \"std::iter::adapters::map::map_fold\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold17hfb84ea7d0fb8cbffE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn map_fold<T, B, Acc>(\n    mut f: impl FnMut(T) -> B,\n    mut g: impl FnMut(Acc, B) -> Acc,\n) -> impl FnMut(Acc, T) -> Acc {\n    move |acc, elt| g(acc, f(elt))\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 151, name: \"std::iter::adapters::map::map_fold::{closure#0}\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold28_$u7b$$u7b$closure$u7d$$u7d$17hb3e453f99d84d8bfE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "move |acc, elt| g(acc, f(elt))",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<u16>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17h07bdeaaf39b8685aE",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<usize>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hd27f508ace781eb9E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem8align_of17h4ae0ba411a4ac535E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<u8>",
          "mangled_name": "_ZN4core3mem8align_of17h296957f42f66a242E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<usize>",
          "mangled_name": "_ZN4core3mem8align_of17h437acbb83d6cfdbcE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem7size_of17haf0934a539654c4eE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17hcf5c6380b93756bbE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<usize>",
          "mangled_name": "_ZN4core3mem7size_of17h9ecfe25f6e1cdef4E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 244, name: \"std::num::NonZero::<T>::new_unchecked::precondition_check\" }",
        "func": {
          "name": "std::num::NonZero::<T>::new_unchecked::precondition_check",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked18precondition_check17h4cd4f9b9df23b8aeE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::num::NonZero::<T>::get\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::get",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3get17h87da58b24eb8904aE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn get(self) -> T {\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // Using the transmute `assume`s the range at runtime.\n        //\n        // Even once LLVM supports `!range` metadata for function arguments\n        // (see <https://github.com/llvm/llvm-project/issues/76628>), this can't\n        // be `.0` because MCP#807 bans field-projecting into `scalar_valid_range`\n        // types, and it arguably wouldn't want to be anyway because if this is\n        // MIR-inlined, there's no opportunity to put that argument metadata anywhere.\n        //\n        // The good answer here will eventually be pattern types, which will hopefully\n        // allow it to go back to `.0`, maybe with a cast of some sort.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 243, name: \"std::num::NonZero::<T>::new\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3new17h3cbc7a205e50ad1fE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn new(n: T) -> Option<Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        unsafe { intrinsics::transmute_unchecked(n) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 226, name: \"std::num::NonZero::<T>::new_unchecked\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new_unchecked",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked17hd3e157914eb40be4E",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 239, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17hd4ca9a9271618328E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 225, name: \"std::option::Option::<T>::is_none\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_none",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_none17hd6afafc489127163E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"std::option::Option::<T>::is_some\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_some",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_some17ha5fa074a52234010E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 76, name: \"std::option::Option::<T>::unwrap_or\" }",
        "func": {
          "name": "std::option::Option::<std::fmt::Alignment>::unwrap_or",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$9unwrap_or17h93449fbe40562582E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 233, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h4766a44e449f5bc0E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 98, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17hf02630a5ee03a007E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h6fb1ff63a43e7ebdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 42, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::cast::<()>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hdc66bbbf9ca09606E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h521f17b23745bac9E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h97561870d96da0dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 42, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h7751fb8567cbcb47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h9de03001895d0df8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h188926acc6c05b0eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 42, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h4c90e7777850aeebE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h7dafd8edeaef92caE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17ha82de6478261a4e1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7eb3d08f6569c7c1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17hcb8a38a895eec4a3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hc807fc49b1a3bc6bE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 42, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hd35b6c11a62aafd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 41, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h40068346434d50f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h50143b2c53e59b95E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hda05d0df679c02a1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h9cd43061e61ae508E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 155, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h4637137071b370dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17hc15237a6a56a10c5E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 44, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h989cc2396acbfee6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h8ea5f88e28a94b81E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 211, name: \"std::ptr::align_offset\" }",
        "func": {
          "name": "std::ptr::align_offset::<u8>",
          "mangled_name": "_ZN4core3ptr12align_offset17hc37ffd11ea4851baE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n    // 1, where the method versions of these operations are not inlined.\n    use intrinsics::{\n        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n    };\n\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for `align_offset` and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x < m`; (if `x  m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }\n\n    let stride = size_of::<T>();\n\n    let addr: usize = p.addr();\n\n    // SAFETY: `a` is a power-of-two, therefore non-zero.\n    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n\n    if stride == 0 {\n        // SPECIAL_CASE: handle 0-sized types. No matter how many times we step, the address will\n        // stay the same, so no offset will be able to align the pointer unless it is already\n        // aligned. This branch _will_ be optimized out as `stride` is known at compile-time.\n        let p_mod_a = addr & a_minus_one;\n        return if p_mod_a == 0 { 0 } else { usize::MAX };\n    }\n\n    // SAFETY: `stride == 0` case has been handled by the special case above.\n    let a_mod_stride = unsafe { unchecked_rem(a, stride) };\n    if a_mod_stride == 0 {\n        // SPECIAL_CASE: In cases where the `a` is divisible by `stride`, byte offset to align a\n        // pointer can be computed more simply through `-p (mod a)`. In the off-chance the byte\n        // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n        // offset will be able to produce a `p` aligned to the specified `a`.\n        //\n        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n        // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n        // redistributes operations around the load-bearing, but pessimizing `and` instruction\n        // sufficiently for LLVM to be able to utilize the various optimizations it knows about.\n        //\n        // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated\n        // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`\n        // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n        // computation produces.\n\n        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n        let byte_offset = wrapping_sub(aligned_address, addr);\n        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n        // the value by more than `a-1`, so even though the intermediate values might have\n        // wrapped, the byte_offset is always in `[0, a)`.\n        unsafe { assume(byte_offset < a) };\n\n        // SAFETY: `stride == 0` case has been handled by the special case above.\n        let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n\n        return if addr_mod_stride == 0 {\n            // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n            // addr has been verified to be aligned to the original types alignment requirements.\n            unsafe { exact_div(byte_offset, stride) }\n        } else {\n            usize::MAX\n        };\n    }\n\n    // GENERAL_CASE: From here on were handling the very general case where `addr` may be\n    // misaligned, there isnt an obvious relationship between `stride` and `a` that we can take an\n    // advantage of, etc. This case produces machine code that isnt particularly high quality,\n    // compared to the special cases above. The code produced here is still within the realm of\n    // miracles, given the situations this case has to deal with.\n\n    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n    // FIXME(const-hack) replace with min\n    let gcdpow = unsafe {\n        let x = cttz_nonzero(stride);\n        let y = cttz_nonzero(a);\n        if x < y { x } else { y }\n    };\n    // SAFETY: gcdpow has an upper-bound thats at most the number of bits in a `usize`.\n    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n    // SAFETY: gcd is always greater or equal to 1.\n    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the\n        // second term is \"how does incrementing `p` by `s` bytes change the relative alignment of\n        // `p`\" (again divided by `g`). Division by `g` is necessary to make the inverse well\n        // formed if `a` and `s` are not co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. This `lcm(s, a)` is the same as `a'`.\n\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n        // in `a` (of which it has exactly one).\n        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let s2 = unsafe { unchecked_shr(stride & a_minus_one, gcdpow) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n        // always be strictly greater than `(p % a) >> gcdpow`.\n        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(addr & a_minus_one, gcdpow)) };\n        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::MAX\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 215, name: \"std::ptr::align_offset::mod_inv\" }",
        "func": {
          "name": "std::ptr::align_offset::mod_inv",
          "mangled_name": "_ZN4core3ptr12align_offset7mod_inv17ha00363a47984512dE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h801e50d053bdb0deE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 169, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h0f26c5c75d692ab8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 202, name: \"std::ptr::const_ptr::<impl *const T>::is_aligned_to\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_aligned_to",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$13is_aligned_to17hbaf8f80ac8bd74b5E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn is_aligned_to(self, align: usize) -> bool {\n        if !align.is_power_of_two() {\n            panic!(\"is_aligned_to: align is not a power-of-two\");\n        }\n\n        self.addr() & (align - 1) == 0\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 203, name: \"std::ptr::const_ptr::<impl *const T>::is_null\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_null",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h39f2cba5693cfcbaE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 207, name: \"std::ptr::const_ptr::<impl *const T>::is_null::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::is_null::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null7runtime17hd755a2ab3f9a7257E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17hee674b85d8e0eaefE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 165, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h347785d8fcffea35E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 166, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17haee319aa28923404E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "macro_backtrace_len": 3,
          "macro_backtrace": [
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            },
            {
              "callsite": "const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )",
              "defsite": "pub(crate) macro const_eval_select {\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        // Use the `noinline` arm, after adding explicit `inline` attributes\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )\n    },\n    // With a leading #[noinline], we don't add inline attributes\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty = $val:expr),* $(,)? } $( -> $ret:ty )? :\n        #[noinline]\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {{\n        $(#[$runtime_attr])*\n        fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }\n\n        $(#[$compiletime_attr])*\n        const fn compiletime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            // Don't warn if one of the arguments is unused.\n            $(let _ = $arg;)*\n\n            $compiletime\n        }\n\n        const_eval_select(($($val,)*), compiletime, runtime)\n    }},\n    // We support leaving away the `val` expressions for *all* arguments\n    // (but not for *some* arguments, that's too tricky).\n    (\n        @capture$([$($binders:tt)*])? { $($arg:ident : $ty:ty),* $(,)? } $( -> $ret:ty )? :\n        if const\n            $(#[$compiletime_attr:meta])* $compiletime:block\n        else\n            $(#[$runtime_attr:meta])* $runtime:block\n    ) => {\n        $crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $arg),* } $(-> $ret)? :\n            if const\n                $(#[$compiletime_attr])* $compiletime\n            else\n                $(#[$runtime_attr])* $runtime\n        )\n    },\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h4407a3d2505e3182E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h77a9a38a2fb82cebE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h25fab610016eeca6E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 169, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h67c1047b03f9e292E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h7401bd689b86ad58E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h92ec9fe8e383ac30E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 169, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hff895de5937ae31dE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h7e1ae8494ab1b6a8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h9fdb81ba991ea93aE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h2ae9d76f96e8dd87E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 169, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h2f8efeac9b4bac69E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 169, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hf4fbc42107f2b93dE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<&u8>",
          "mangled_name": "_ZN4core3ptr27drop_in_place$LT$$RF$u8$GT$17hde76a694ab99a0ceE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::fmt::Alignment>",
          "mangled_name": "_ZN4core3ptr41drop_in_place$LT$core..fmt..Alignment$GT$17ha32e77f679dea4afE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::option::Option<(usize, char)>>",
          "mangled_name": "_ZN4core3ptr69drop_in_place$LT$core..option..Option$LT$$LP$usize$C$char$RP$$GT$$GT$17h6ff99e40e2a3dc77E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<usize>",
          "mangled_name": "_ZN4core3ptr26drop_in_place$LT$usize$GT$17hb2356817884944bcE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17h517d686e9eb26718E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr772drop_in_place$LT$core..iter..adapters..map..map_fold$LT$$RF$u8$C$usize$C$usize$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$C$$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$..sum$LT$core..iter..adapters..map..Map$LT$core..slice..iter..Iter$LT$u8$GT$$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17hcd5e9ddf1d3c3d8dE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr76drop_in_place$LT$contract..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h1b8ff4cc8687fcc3E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr76drop_in_place$LT$contract..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h316502fb0cfe21c6E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr76drop_in_place$LT$contract..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h845d7e19a119c073E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 28, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr76drop_in_place$LT$contract..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h86803bc8e07a6f2aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[[usize; 4]], [usize; 4]>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h366ed0a3a51d837eE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17hcbff0ea135f8c822E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[usize], usize>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h41eed9c7257b5a92E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h11e9b84f3b318493E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 118, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hbafa0c943931e716E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hfcaabb87217b870dE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 118, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h4e8c24d95c6ae7e6E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h6d06b2acd211f2bcE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17he8e6f7cbdd8f5e6eE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 118, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hc012792d97dee9c9E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h38c5d91c0c3e3211E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 127, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hdf15e8368e89c131E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 127, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h9b6c1ed71e4b6c54E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 127, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<usize>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h0392b72387600f22E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr18without_provenance17ha2f922cac826482bE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h9acb982cb9d740c9E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<usize>",
          "mangled_name": "_ZN4core3ptr18without_provenance17he0f0275be02287b7E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hf5d382f6173c162aE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17h671bcfdb07d1a6f7E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<usize>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hbaf35cea24a28f56E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 110, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h237867c19800b78bE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 30, name: \"std::rt::panic_display\" }",
        "func": {
          "name": "std::rt::panic_display::<&str>",
          "mangled_name": "_ZN4core9panicking13panic_display17h9965c83dbdce9711E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n    panic_fmt(format_args!(\"{}\", *x));\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 33, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17h8206d9c4fa94b0f1E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 209, name: \"std::slice::Chunks::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Chunks::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter15Chunks$LT$T$GT$3new17h61fc0016bb33d3a4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 115, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, [usize; 4]>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h7e563fa4aafeccbeE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::slice::Iter::<'a, T>::as_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::as_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$8as_slice17h5dbeb8b275b939f1E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 223, name: \"std::slice::Iter::<'a, T>::make_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::make_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$10make_slice17h0642eba69123b1daE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}",
              "defsite": "macro_rules! iterator {\n    (\n        struct $name:ident -> $ptr:ty,\n        $elem:ty,\n        $raw_mut:tt,\n        {$( $mut_:tt )?},\n        $into_ref:ident,\n        {$($extra:tt)*}\n    ) => {\n        impl<'a, T> $name<'a, T> {\n            /// Returns the last element and moves the end of the iterator backwards by 1.\n            ///\n            /// # Safety\n            ///\n            /// The iterator must not be empty\n            #[inline]\n            unsafe fn next_back_unchecked(&mut self) -> $elem {\n                // SAFETY: the caller promised it's not empty, so\n                // the offsetting is in-bounds and there's an element to return.\n                unsafe { self.pre_dec_end(1).$into_ref() }\n            }\n\n            // Helper function for creating a slice from the iterator.\n            #[inline(always)]\n            fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }\n\n            // Helper function for moving the start of the iterator forwards by `offset` elements,\n            // returning the old start.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn post_inc_start(&mut self, offset: usize) -> NonNull<T> {\n                let old = self.ptr;\n\n                // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                // so this new pointer is inside `self` and thus guaranteed to be non-null.\n                unsafe {\n                    if_zst!(mut self,\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        len => *len = crate::intrinsics::unchecked_sub(*len, offset),\n                        _end => self.ptr = self.ptr.add(offset),\n                    );\n                }\n                old\n            }\n\n            // Helper function for moving the end of the iterator backwards by `offset` elements,\n            // returning the new end.\n            // Unsafe because the offset must not exceed `self.len()`.\n            #[inline(always)]\n            unsafe fn pre_dec_end(&mut self, offset: usize) -> NonNull<T> {\n                if_zst!(mut self,\n                    // SAFETY: By our precondition, `offset` can be at most the\n                    // current length, so the subtraction can never overflow.\n                    len => unsafe {\n                        // Using the intrinsic directly avoids emitting a UbCheck\n                        *len = crate::intrinsics::unchecked_sub(*len, offset);\n                        self.ptr\n                    },\n                    // SAFETY: the caller guarantees that `offset` doesn't exceed `self.len()`,\n                    // which is guaranteed to not overflow an `isize`. Also, the resulting pointer\n                    // is in bounds of `slice`, which fulfills the other requirements for `offset`.\n                    end => unsafe {\n                        *end = end.sub(offset);\n                        *end\n                    },\n                )\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<T> ExactSizeIterator for $name<'_, T> {\n            #[inline(always)]\n            fn len(&self) -> usize {\n                len!(self)\n            }\n\n            #[inline(always)]\n            fn is_empty(&self) -> bool {\n                is_empty!(self)\n            }\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> Iterator for $name<'a, T> {\n            type Item = $elem;\n\n            #[inline]\n            fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }\n\n            #[inline]\n            fn size_hint(&self) -> (usize, Option<usize>) {\n                let exact = len!(self);\n                (exact, Some(exact))\n            }\n\n            #[inline]\n            fn count(self) -> usize {\n                len!(self)\n            }\n\n            #[inline]\n            fn nth(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => self.ptr = *end,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `post_inc_start` does the right thing even for ZSTs.\n                unsafe {\n                    self.post_inc_start(n);\n                    Some(self.next_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.post_inc_start(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n\n            #[inline]\n            fn last(mut self) -> Option<$elem> {\n                self.next_back()\n            }\n\n            #[inline]\n            fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn for_each<F>(mut self, mut f: F)\n            where\n                Self: Sized,\n                F: FnMut(Self::Item),\n            {\n                while let Some(x) = self.next() {\n                    f(x);\n                }\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn all<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if !f(x) {\n                        return false;\n                    }\n                }\n                true\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn any<F>(&mut self, mut f: F) -> bool\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if f(x) {\n                        return true;\n                    }\n                }\n                false\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find<P>(&mut self, mut predicate: P) -> Option<Self::Item>\n            where\n                Self: Sized,\n                P: FnMut(&Self::Item) -> bool,\n            {\n                while let Some(x) = self.next() {\n                    if predicate(&x) {\n                        return Some(x);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile.\n            #[inline]\n            fn find_map<B, F>(&mut self, mut f: F) -> Option<B>\n            where\n                Self: Sized,\n                F: FnMut(Self::Item) -> Option<B>,\n            {\n                while let Some(x) = self.next() {\n                    if let Some(y) = f(x) {\n                        return Some(y);\n                    }\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            #[rustc_inherit_overflow_checks]\n            fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n                Self: Sized,\n                P: FnMut(Self::Item) -> bool,\n            {\n                let n = len!(self);\n                let mut i = 0;\n                while let Some(x) = self.next() {\n                    if predicate(x) {\n                        // SAFETY: we are guaranteed to be in bounds by the loop invariant:\n                        // when `i >= n`, `self.next()` returns `None` and the loop breaks.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                    i += 1;\n                }\n                None\n            }\n\n            // We override the default implementation, which uses `try_fold`,\n            // because this simple implementation generates less LLVM IR and is\n            // faster to compile. Also, the `assume` avoids a bounds check.\n            #[inline]\n            fn rposition<P>(&mut self, mut predicate: P) -> Option<usize> where\n                P: FnMut(Self::Item) -> bool,\n                Self: Sized + ExactSizeIterator + DoubleEndedIterator\n            {\n                let n = len!(self);\n                let mut i = n;\n                while let Some(x) = self.next_back() {\n                    i -= 1;\n                    if predicate(x) {\n                        // SAFETY: `i` must be lower than `n` since it starts at `n`\n                        // and is only decreasing.\n                        unsafe { assert_unchecked(i < n) };\n                        return Some(i);\n                    }\n                }\n                None\n            }\n\n            #[inline]\n            unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n                // SAFETY: the caller must guarantee that `i` is in bounds of\n                // the underlying slice, so `i` cannot overflow an `isize`, and\n                // the returned references is guaranteed to refer to an element\n                // of the slice and thus guaranteed to be valid.\n                //\n                // Also note that the caller also guarantees that we're never\n                // called with the same index again, and that no other methods\n                // that will access this subslice are called, so it is valid\n                // for the returned reference to be mutable in the case of\n                // `IterMut`\n                unsafe { & $( $mut_ )? * self.ptr.as_ptr().add(idx) }\n            }\n\n            $($extra)*\n        }\n\n        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n        impl<'a, T> DoubleEndedIterator for $name<'a, T> {\n            #[inline]\n            fn next_back(&mut self) -> Option<$elem> {\n                // could be implemented with slices, but this avoids bounds checks\n\n                // SAFETY: The call to `next_back_unchecked`\n                // is safe since we check if the iterator is empty first.\n                unsafe {\n                    if is_empty!(self) {\n                        None\n                    } else {\n                        Some(self.next_back_unchecked())\n                    }\n                }\n            }\n\n            #[inline]\n            fn nth_back(&mut self, n: usize) -> Option<$elem> {\n                if n >= len!(self) {\n                    // This iterator is now empty.\n                    if_zst!(mut self,\n                        len => *len = 0,\n                        end => *end = self.ptr,\n                    );\n                    return None;\n                }\n                // SAFETY: We are in bounds. `pre_dec_end` does the right thing even for ZSTs.\n                unsafe {\n                    self.pre_dec_end(n);\n                    Some(self.next_back_unchecked())\n                }\n            }\n\n            #[inline]\n            fn advance_back_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n                let advance = cmp::min(len!(self), n);\n                // SAFETY: By construction, `advance` does not exceed `self.len()`.\n                unsafe { self.pre_dec_end(advance) };\n                NonZero::new(n - advance).map_or(Ok(()), Err)\n            }\n        }\n\n        #[stable(feature = \"fused\", since = \"1.26.0\")]\n        impl<T> FusedIterator for $name<'_, T> {}\n\n        #[unstable(feature = \"trusted_len\", issue = \"37572\")]\n        unsafe impl<T> TrustedLen for $name<'_, T> {}\n\n        impl<'a, T> UncheckedIterator for $name<'a, T> {\n            #[inline]\n            unsafe fn next_unchecked(&mut self) -> $elem {\n                // SAFETY: The caller promised there's at least one more item.\n                unsafe {\n                    self.post_inc_start(1).$into_ref()\n                }\n            }\n        }\n\n        #[stable(feature = \"default_iters\", since = \"1.70.0\")]\n        impl<T> Default for $name<'_, T> {\n            /// Creates an empty slice iterator.\n            ///\n            /// ```\n            #[doc = concat!(\"# use core::slice::\", stringify!($name), \";\")]\n            #[doc = concat!(\"let iter: \", stringify!($name<'_, u8>), \" = Default::default();\")]\n            /// assert_eq!(iter.len(), 0);\n            /// ```\n            fn default() -> Self {\n                (& $( $mut_ )? []).into_iter()\n            }\n        }\n    }\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 115, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h9fd511ca042ff46dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 115, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hf5d3176cdb446f8dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, [usize; 4]>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb0c08e21a67d8321E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, u8>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17h20fd2a93730b1004E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, usize>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb415c774c30ce8d9E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::slice::from_raw_parts::precondition_check\" }",
        "func": {
          "name": "std::slice::from_raw_parts::precondition_check",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts18precondition_check17h45eaf539a8e6c6d6E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        )",
              "defsite": "macro_rules! assert_unsafe_precondition {\n    ($kind:ident, $message:expr, ($($name:ident:$ty:ty = $arg:expr),*$(,)?) => $e:expr $(,)?) => {\n        {\n            // This check is inlineable, but not by the MIR inliner.\n            // The reason for this is that the MIR inliner is in an exceptionally bad position\n            // to think about whether or not to inline this. In MIR, this call is gated behind `debug_assertions`,\n            // which will codegen to `false` in release builds. Inlining the check would be wasted work in that case and\n            // would be bad for compile times.\n            //\n            // LLVM on the other hand sees the constant branch, so if it's `false`, it can immediately delete it without\n            // inlining the check. If it's `true`, it can inline it and get significantly better performance.\n            #[rustc_no_mir_inline]\n            #[inline]\n            #[rustc_nounwind]\n            const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }\n\n            if ::core::ub_checks::$kind() {\n                precondition_check($($arg,)*);\n            }\n        }\n    };\n}"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"std::str::CharIndices::<'a>::offset\" }",
        "func": {
          "name": "std::str::CharIndices::<'_>::offset",
          "mangled_name": "_ZN4core3str4iter11CharIndices6offset17h65a84c1849cae1b4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::str::Chars::<'a>::as_str\" }",
        "func": {
          "name": "std::str::Chars::<'_>::as_str",
          "mangled_name": "_ZN4core3str4iter5Chars6as_str17h1f2346f076558a92E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn as_str(&self) -> &'a str {\n        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 222, name: \"std::str::from_utf8_unchecked\" }",
        "func": {
          "name": "std::str::from_utf8_unchecked",
          "mangled_name": "_ZN4core3str8converts19from_utf8_unchecked17he3661e1b9beb2de5E",
          "kind": "Item",
          "file": "library/core/src/str/converts.rs",
          "src": "pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n    // Also relies on `&str` and `&[u8]` having the same layout.\n    unsafe { mem::transmute(v) }\n}",
          "macro_backtrace_len": 0,
          "macro_backtrace": []
        }
      },
      {
        "def_id": "DefId { id: 0, name: \"verify::contract\" }",
        "func": {
          "name": "verify::contract",
          "mangled_name": "_ZN8contract6verify8contract17hf1fba9e9dc1c539bE",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 2, name: \"verify::contract::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract::kani_contract_mode",
          "mangled_name": "_ZN8contract6verify8contract18kani_contract_mode17h9f5355f6c362d25fE",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<(), {closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN8contract6verify8contract22kani_register_contract17h0ade00dfc4b7123aE",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<(), {closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN8contract6verify8contract22kani_register_contract17h600b024ef132ee21E",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<(), {closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN8contract6verify8contract22kani_register_contract17hdbe812c3121dd1e7E",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<(), {closure@tests/compare/contract.rs:3:5: 3:29}>",
          "mangled_name": "_ZN8contract6verify8contract22kani_register_contract17he997668f17088508E",
          "kind": "Item",
          "file": "tests/compare/contract.rs",
          "src": "#[kani::requires(a > 0)]",
          "macro_backtrace_len": 1,
          "macro_backtrace": [
            {
              "callsite": "#[kani::requires(a > 0)]",
              "defsite": "pub fn requires(attr: TokenStream, item: TokenStream) -> TokenStream"
            }
          ]
        }
      }
    ]
  }
]