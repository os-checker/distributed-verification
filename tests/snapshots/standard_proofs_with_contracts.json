[
  {
    "hash": "561867074596258581010404110766731420614",
    "def_id": "DefId { id: 52, name: \"verify::single_contract\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": {
      "name": "verify::single_contract",
      "mangled_name": "_ZN30standard_proofs_with_contracts6verify15single_contract17h3ace85d88f1820a3E",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs_with_contracts.rs",
      "src": "fn single_contract() {\n        let val = contract(1);\n        assert!(val > 0);\n    }",
      "before_expansion": null
    },
    "callees_len": 250,
    "callees": [
      {
        "def_id": "DefId { id: 64, name: \"<&T as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<&str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h410ed86c60f5cfc3E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }",
          "before_expansion": "fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }"
        }
      },
      {
        "def_id": "DefId { id: 254, name: \"<T as std::convert::From<T>>::from\" }",
        "func": {
          "name": "<std::fmt::Error as std::convert::From<std::fmt::Error>>::from",
          "mangled_name": "_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17he83ac1a1ecfe098bE",
          "kind": "Item",
          "file": "library/core/src/convert/mod.rs",
          "src": "fn from(t: T) -> T {\n        t\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize17hefafed2dd7e7b23dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::{closure#0}\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize28_$u7b$$u7b$closure$u7d$$u7d$17h58b8e91647087575E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "move |x| predicate(&x) as usize",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 108, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::iter::Filter<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}> as std::iter::Iterator>::count",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h3699bd088ef32d8bE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 121, name: \"<std::iter::Map<I, F> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::fold::<usize, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN102_$LT$core..iter..adapters..map..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h6d92003bf13c783fE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, map_fold(self.f, g))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 114, name: \"std::iter::Iterator::sum\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::sum::<usize>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3sum17h7d40d1f308b1005dE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn sum<S>(self) -> S\n    where\n        Self: Sized,\n        S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h7c9a54f8524b49a7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17hce7831b5e86d6af1E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h9c1f64b07716f02eE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17h2e2ab1a72ff80731E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 245, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h07c3e6fc52b3fedeE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 246, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h99f2f0e144b0be9fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[[usize; 4]]> as std::convert::From<&[[usize; 4]]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hf2bfe9aa01cc2a5cE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[u8]> as std::convert::From<&[u8]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17ha2f234dc854092f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize; 4]> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9d329a2fb5d239cdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize]> as std::convert::From<&[usize]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hda64db96e84d2849E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7c7ff8009b034788E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<usize> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h626a1d09fbfa6da4E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hc061659ac6d49be8E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hb63dc43fb3b8efe3E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hbf3169bb7998e829E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hf0fbb1a129a09e75E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h962da7a65ee8c669E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 170, name: \"<std::slice::Chunks<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN93_$LT$core..slice..iter..Chunks$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h28c7ddf67bd014beE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, [usize; 4]> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h0b79c4e6d4c47667E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 233, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17hcb764b037493d54cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"std::iter::Iterator::filter\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::filter::<{closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator6filter17h89d9720e37de1568E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn filter<P>(self, predicate: P) -> Filter<Self, P>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        Filter::new(self, predicate)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::fold::<usize, {closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h29ba2c4b195065b9E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"std::iter::Iterator::map\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::map::<usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3map17hbfc9ceba84a749aeE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn map<B, F>(self, f: F) -> Map<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> B,\n    {\n        Map::new(self, f)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hfadf3ba7fbb0614cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hae10bd58ec770fd8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 82, name: \"std::iter::Iterator::advance_by\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::advance_by",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator10advance_by17h0040525bd95241f2E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        for i in 0..n {\n            if self.next().is_none() {\n                // SAFETY: `i` is always less than `n`.\n                return Err(unsafe { NonZero::new_unchecked(n - i) });\n            }\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 222, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h86991728206f71e4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"<std::str::Chars<'a> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::count",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17hd17d710ff4eee22cE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn count(self) -> usize {\n        super::count::count_chars(self.as_str())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 234, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h5b0d866ec2d0f5f4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 238, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hcd9a1b225c5bc517E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 71, name: \"<str as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h2e4773966404a9e8E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 256, name: \"<u16 as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<u16 as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN47_$LT$u16$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17hf1a4da89e7daa5f0E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"std::cmp::Ord::min\" }",
        "func": {
          "name": "<usize as std::cmp::Ord>::min",
          "mangled_name": "_ZN4core3cmp3Ord3min17hca8e35334025e720E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        if other < self { other } else { self }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 229, name: \"<usize as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<usize as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN49_$LT$usize$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17ha98665aa01e86e87E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"<usize as std::iter::Sum>::sum\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum17hd4899a4f1283f91cE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"<usize as std::iter::Sum>::sum::{closure#0}\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum28_$u7b$$u7b$closure$u7d$$u7d$17hf553ffa479b229d7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "|a, b| a + b",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 263, name: \"core::fmt::PostPadding::new\" }",
        "func": {
          "name": "core::fmt::PostPadding::new",
          "mangled_name": "_ZN4core3fmt11PostPadding3new17h635173abc89c1c46E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn new(fill: char, padding: u16) -> PostPadding {\n        PostPadding { fill, padding }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"core::fmt::PostPadding::write\" }",
        "func": {
          "name": "core::fmt::PostPadding::write",
          "mangled_name": "_ZN4core3fmt11PostPadding5write17he27432ff58f0176fE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n        for _ in 0..self.padding {\n            f.buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 65, name: \"core::fmt::rt::Argument::<'_>::new\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument3new17hc43cfa4d4cc7eeb3E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "const fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'a> {\n        Argument {\n            // INVARIANT: this creates an `ArgumentType<'a>` from a `&'a T` and\n            // a `fn(&T, ...)`, so the invariant is maintained.\n            ty: ArgumentType::Placeholder {\n                value: NonNull::from_ref(x).cast(),\n                // SAFETY: function pointers always have the same layout.\n                formatter: unsafe { mem::transmute(f) },\n                _lifetime: PhantomData,\n            },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 57, name: \"core::fmt::rt::Argument::<'_>::new_display\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new_display::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument11new_display17h2abb0f96064d56d7E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "pub fn new_display<T: Display>(x: &T) -> Argument<'_> {\n        Self::new(x, Display::fmt)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 259, name: \"core::num::<impl u16>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl u16>::overflowing_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$15overflowing_add17h711f2c8f6e02c5aaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 257, name: \"core::num::<impl u16>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add17hec98168318b5d827E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 258, name: \"core::num::<impl u16>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add18precondition_check17h9d272714b118328cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 244, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h036191e61598aedaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 193, name: \"core::num::<impl usize>::count_ones\" }",
        "func": {
          "name": "core::num::<impl usize>::count_ones",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$10count_ones17h5848180a66ff35a5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 192, name: \"core::num::<impl usize>::is_power_of_two\" }",
        "func": {
          "name": "core::num::<impl usize>::is_power_of_two",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15is_power_of_two17h25612661704e08b9E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"core::num::<impl usize>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_add17hae858b6d0d0dc624E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 203, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17ha23631731d5dc26cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 132, name: \"core::num::<impl usize>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add17hc42a707166fea5e5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"core::num::<impl usize>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add18precondition_check17h463cf773999eaa82E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 199, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h118193beb20e1102E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 202, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17hc50a9a68f99e942bE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 215, name: \"core::num::<impl usize>::wrapping_mul\" }",
        "func": {
          "name": "core::num::<impl usize>::wrapping_mul",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$12wrapping_mul17h0d4deee3af61861dE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 142, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h8572d23834841ad0E",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17hee37ceed2bfa2394E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 137, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17h21f756518b770eccE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17ha5c466fea0230c4cE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h077fbeb784973dc1E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::<impl [T]>::as_chunks_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::as_chunks_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked18precondition_check17hae985b6008ba8febE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"core::slice::<impl [T]>::split_at_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::split_at_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked18precondition_check17h036498ebedbca62dE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [[usize; 4]]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h1f796214e285bd05E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 163, name: \"core::slice::<impl [T]>::align_to\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8align_to17h3f2f55440dbd3412E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is  don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 207, name: \"core::slice::<impl [T]>::align_to_offsets\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to_offsets::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16align_to_offsets17h9a870748ec74d22cE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17h78ea551bdbf9c409E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9261551842730f07E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h6fde5a5a7a6da893E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h0771b4bddc48611aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h8b631703f7d638d3E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 171, name: \"core::slice::<impl [T]>::as_chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$9as_chunks17h62f5495583e80f1aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len_rounded_down = self.len() / N * N;\n        // SAFETY: The rounded-down value is always the same or smaller than the\n        // original length, and thus must be in-bounds of the slice.\n        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 179, name: \"core::slice::<impl [T]>::as_chunks_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks_unchecked::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked17h8e9f62deb4bed8e1E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        );\n        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n        let new_len = unsafe { exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17hb16374a047362e58E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 166, name: \"core::slice::<impl [T]>::chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::chunks",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6chunks17ha09721e0e969e33aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert!(chunk_size != 0, \"chunk size must be non-zero\");\n        Chunks::new(self, chunk_size)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 164, name: \"core::slice::<impl [T]>::is_empty\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::is_empty",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8is_empty17ha518b9eb9d09acddE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9bded35725a0f34bE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h4760363bd3d8df7dE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h33e3be9e163f3d84E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h2ba5f3ee616a9de4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[[usize; 4]]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17hd4a47bd844608dd0E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[usize]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17h59a4497cf99cfe33E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hfe1187add6301ee6E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17h2ef4bb22e84c1a37E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17h8fcb935f0f5f0c0bE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::RangeTo<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h949054447ff215bbE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 102, name: \"core::str::<impl str>::len\" }",
        "func": {
          "name": "core::str::<impl str>::len",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$3len17h0efa33433be36319E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn len(&self) -> usize {\n        self.as_bytes().len()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 104, name: \"core::str::count::char_count_general_case\" }",
        "func": {
          "name": "core::str::count::char_count_general_case",
          "mangled_name": "_ZN4core3str5count23char_count_general_case17h9194c83a4785e6c0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn char_count_general_case(s: &[u8]) -> usize {\n    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::count::char_count_general_case::{closure#0}\" }",
        "func": {
          "name": "core::str::count::char_count_general_case::{closure#0}",
          "mangled_name": "_ZN4core3str5count23char_count_general_case28_$u7b$$u7b$closure$u7d$$u7d$17h394284915c90711eE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "|&&byte| !super::validations::utf8_is_cont_byte(byte)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 176, name: \"core::str::count::contains_non_continuation_byte\" }",
        "func": {
          "name": "core::str::count::contains_non_continuation_byte",
          "mangled_name": "_ZN4core3str5count30contains_non_continuation_byte17hde3d14fc61658f17E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn contains_non_continuation_byte(w: usize) -> usize {\n    const LSB: usize = usize::repeat_u8(0x01);\n    ((!w >> 7) | (w >> 6)) & LSB\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 101, name: \"core::str::count::count_chars\" }",
        "func": {
          "name": "core::str::count::count_chars",
          "mangled_name": "_ZN4core3str5count11count_chars17h438fe512170f6882E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "pub(super) fn count_chars(s: &str) -> usize {\n    if cfg!(feature = \"optimize_for_size\") || s.len() < USIZE_SIZE * UNROLL_INNER {\n        // Avoid entering the optimized implementation for strings where the\n        // difference is not likely to matter, or where it might even be slower.\n        // That said, a ton of thought was not spent on the particular threshold\n        // here, beyond \"this value seems to make sense\".\n        char_count_general_case(s.as_bytes())\n    } else {\n        do_count_chars(s)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 105, name: \"core::str::count::do_count_chars\" }",
        "func": {
          "name": "core::str::count::do_count_chars",
          "mangled_name": "_ZN4core3str5count14do_count_chars17h75afdc7e2f50899aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 175, name: \"core::str::count::sum_bytes_in_usize\" }",
        "func": {
          "name": "core::str::count::sum_bytes_in_usize",
          "mangled_name": "_ZN4core3str5count18sum_bytes_in_usize17h0fe82d38e63b1ff2E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn sum_bytes_in_usize(values: usize) -> usize {\n    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n\n    let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 266, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h3e681accfd37035aE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 268, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h9bf8221b9faf40cbE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 265, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits110_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..RangeTo$LT$usize$GT$$GT$13get_unchecked17h926389fc19e40548E",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 235, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17h49ef59a58d9bb16bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 249, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17hc891eb537972639bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 247, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17hb45ca0db55f7758bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17hd8ea0d008709b6b4E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17h6827fd98917f2969E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 146, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17h105d247d9515ffcdE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 188, name: \"core::ub_checks::is_valid_allocation_size\" }",
        "func": {
          "name": "core::ub_checks::is_valid_allocation_size",
          "mangled_name": "_ZN4core9ub_checks24is_valid_allocation_size17h90616824e065af89E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {\n    let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };\n    len <= max_len\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"core::ub_checks::maybe_is_aligned_and_not_null\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null17h1c617f69f5e4fe01E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn maybe_is_aligned_and_not_null(\n    ptr: *const (),\n    align: usize,\n    is_zst: bool,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 189, name: \"core::ub_checks::maybe_is_aligned_and_not_null::runtime\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null::runtime",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null7runtime17hc3925ab73c46a78aE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 271, name: \"kani::assert\" }",
        "func": {
          "name": "kani::assert",
          "mangled_name": "_ZN4kani6assert17hcc89e8c2e0f13823E",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn assert(cond: bool, msg: &'static str) {\n            let _ = cond;\n            let _ = msg;\n        }",
          "before_expansion": "kani_core::kani_intrinsics!(std)"
        }
      },
      {
        "def_id": "DefId { id: 53, name: \"kani::panic\" }",
        "func": {
          "name": "kani::panic",
          "mangled_name": "_ZN4kani5panic17h6190bada9522f78aE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn panic(message: &'static str) -> ! {\n            panic!(\"{}\", message)\n        }",
          "before_expansion": "kani_core::kani_intrinsics!(std)"
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"kani::panic::panic_cold_display\" }",
        "func": {
          "name": "kani::panic::panic_cold_display::<&str>",
          "mangled_name": "_ZN4kani5panic18panic_cold_display17h3c77492d46a89dbbE",
          "kind": "Item",
          "file": "library/core/src/panic.rs",
          "src": "const fn panic_cold_display<T: $crate::fmt::Display>(arg: &T) -> ! {\n            $crate::panicking::panic_display(arg)\n        }",
          "before_expansion": "panic!(\"{}\", message)"
        }
      },
      {
        "def_id": "DefId { id: 174, name: \"std::array::<impl std::iter::IntoIterator for &'a [T; N]>::into_iter\" }",
        "func": {
          "name": "std::array::<impl std::iter::IntoIterator for &[usize; 4]>::into_iter",
          "mangled_name": "_ZN4core5array98_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u3b$$u20$N$u5d$$GT$9into_iter17he1c19779b96d5e95E",
          "kind": "Item",
          "file": "library/core/src/array/mod.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 242, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217h79452afed33d8afaE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 240, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17hd069e3b6813f4d52E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 241, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h8dade502d8f04feeE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )"
        }
      },
      {
        "def_id": "DefId { id: 239, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h2c8c127ff9716582E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 255, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt",
          "mangled_name": "_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u16$GT$2lt17h2e1d14712d03b1a2E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 214, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt",
          "mangled_name": "_ZN4core3cmp5impls57_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$usize$GT$2lt17h551740291a2e7191E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 211, name: \"std::cmp::min\" }",
        "func": {
          "name": "std::cmp::min::<usize>",
          "mangled_name": "_ZN4core3cmp3min17hdf73c061ba7372f8E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "pub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::convert::num::<impl std::convert::From<u16> for usize>::from\" }",
        "func": {
          "name": "std::convert::num::<impl std::convert::From<u16> for usize>::from",
          "mangled_name": "_ZN4core7convert3num66_$LT$impl$u20$core..convert..From$LT$u16$GT$$u20$for$u20$usize$GT$4from17hcff1e1e2ee4568c2E",
          "kind": "Item",
          "file": "library/core/src/convert/num.rs",
          "src": "fn from(small: $Small) -> Self {\n                small as Self\n            }",
          "before_expansion": "impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        )"
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hbb45028c907195c1E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::fmt::Arguments::<'a>::new_v1\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_v1::<1, 1>",
          "mangled_name": "_ZN4core3fmt9Arguments6new_v117heaed1009cc26b388E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_v1<const P: usize, const A: usize>(\n        pieces: &'a [&'static str; P],\n        args: &'a [rt::Argument<'a>; A],\n    ) -> Arguments<'a> {\n        const { assert!(P >= A && P <= A + 1, \"invalid args\") }\n        Arguments { pieces, fmt: None, args }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 73, name: \"std::fmt::Formatter::<'a>::pad\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::pad",
          "mangled_name": "_ZN4core3fmt9Formatter3pad17he3971bd2e0830220E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front.\n        if self.options.flags & (flags::WIDTH_FLAG | flags::PRECISION_FLAG) == 0 {\n            return self.buf.write_str(s);\n        }\n\n        // The `precision` field can be interpreted as a maximum width for the\n        // string being formatted.\n        let (s, char_count) = if let Some(max_char_count) = self.options.get_precision() {\n            let mut iter = s.char_indices();\n            let remaining = match iter.advance_by(usize::from(max_char_count)) {\n                Ok(()) => 0,\n                Err(remaining) => remaining.get(),\n            };\n            // SAFETY: The offset of `.char_indices()` is guaranteed to be\n            // in-bounds and between character boundaries.\n            let truncated = unsafe { s.get_unchecked(..iter.offset()) };\n            (truncated, usize::from(max_char_count) - remaining)\n        } else {\n            // Use the optimized char counting algorithm for the full string.\n            (s, s.chars().count())\n        };\n\n        // The `width` field is more of a minimum width parameter at this point.\n        if char_count < usize::from(self.options.width) {\n            // If we're under the minimum width, then fill up the minimum width\n            // with the specified string + some alignment.\n            let post_padding =\n                self.padding(self.options.width - char_count as u16, Alignment::Left)?;\n            self.buf.write_str(s)?;\n            post_padding.write(self)\n        } else {\n            // If we're over the minimum width or there is no minimum width, we\n            // can just emit the string.\n            self.buf.write_str(s)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"std::fmt::Formatter::<'a>::padding\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::padding",
          "mangled_name": "_ZN4core3fmt9Formatter7padding17h53f9e78fb4099400E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn padding(\n        &mut self,\n        padding: u16,\n        default: Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = self.options.get_align().unwrap_or(default);\n        let fill = self.options.get_fill();\n\n        let padding_left = match align {\n            Alignment::Left => 0,\n            Alignment::Right => padding,\n            Alignment::Center => padding / 2,\n        };\n\n        for _ in 0..padding_left {\n            self.buf.write_char(fill)?;\n        }\n\n        Ok(PostPadding::new(fill, padding - padding_left))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 260, name: \"std::fmt::FormattingOptions::get_align\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_align",
          "mangled_name": "_ZN4core3fmt17FormattingOptions9get_align17h8b918746f9c015ffE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_align(&self) -> Option<Alignment> {\n        match self.flags & flags::ALIGN_BITS {\n            flags::ALIGN_LEFT => Some(Alignment::Left),\n            flags::ALIGN_RIGHT => Some(Alignment::Right),\n            flags::ALIGN_CENTER => Some(Alignment::Center),\n            _ => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 262, name: \"std::fmt::FormattingOptions::get_fill\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_fill",
          "mangled_name": "_ZN4core3fmt17FormattingOptions8get_fill17h43c04343d70b7042E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_fill(&self) -> char {\n        // SAFETY: We only ever put a valid `char` in the lower 21 bits of the flags field.\n        unsafe { char::from_u32_unchecked(self.flags & 0x1FFFFF) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 78, name: \"std::fmt::FormattingOptions::get_precision\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_precision",
          "mangled_name": "_ZN4core3fmt17FormattingOptions13get_precision17hbd80eaff3d1888beE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_precision(&self) -> Option<u16> {\n        if self.flags & flags::PRECISION_FLAG != 0 { Some(self.precision) } else { None }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 250, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17hb85c714223239900E",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 251, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17haa76a7dc7c6e5497E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )"
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17he733dcfdc3261fb2E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 165, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17hed6aa9940a66cedcE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 157, name: \"std::iter::Filter::<I, P>::new\" }",
        "func": {
          "name": "std::iter::Filter::<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters6filter19Filter$LT$I$C$P$GT$3new17hc34a2f01600b7b29E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n        Filter { iter, predicate }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::iter::Map::<I, F>::new\" }",
        "func": {
          "name": "std::iter::Map::<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters3map16Map$LT$I$C$F$GT$3new17h53f0d55450f62c1dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n        Map { iter, f }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"std::iter::adapters::map::map_fold\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold17hfb84ea7d0fb8cbffE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn map_fold<T, B, Acc>(\n    mut f: impl FnMut(T) -> B,\n    mut g: impl FnMut(Acc, B) -> Acc,\n) -> impl FnMut(Acc, T) -> Acc {\n    move |acc, elt| g(acc, f(elt))\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::iter::adapters::map::map_fold::{closure#0}\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold28_$u7b$$u7b$closure$u7d$$u7d$17hb3e453f99d84d8bfE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "move |acc, elt| g(acc, f(elt))",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<u16>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17h07bdeaaf39b8685aE",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<usize>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hd27f508ace781eb9E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem8align_of17h4ccf9d5c0139d079E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<u8>",
          "mangled_name": "_ZN4core3mem8align_of17hcf7fa5208d41c27fE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<usize>",
          "mangled_name": "_ZN4core3mem8align_of17h512cbae0980bb36dE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem7size_of17h0553276df7ba24c2E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17hd68b5fd240b661c5E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<usize>",
          "mangled_name": "_ZN4core3mem7size_of17hd5b2a7cccbb61ceeE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 231, name: \"std::num::NonZero::<T>::new_unchecked::precondition_check\" }",
        "func": {
          "name": "std::num::NonZero::<T>::new_unchecked::precondition_check",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked18precondition_check17h0116c509d606ce2cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    )"
        }
      },
      {
        "def_id": "DefId { id: 84, name: \"std::num::NonZero::<T>::get\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::get",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3get17h87da58b24eb8904aE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn get(self) -> T {\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // Using the transmute `assume`s the range at runtime.\n        //\n        // Even once LLVM supports `!range` metadata for function arguments\n        // (see <https://github.com/llvm/llvm-project/issues/76628>), this can't\n        // be `.0` because MCP#807 bans field-projecting into `scalar_valid_range`\n        // types, and it arguably wouldn't want to be anyway because if this is\n        // MIR-inlined, there's no opportunity to put that argument metadata anywhere.\n        //\n        // The good answer here will eventually be pattern types, which will hopefully\n        // allow it to go back to `.0`, maybe with a cast of some sort.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 230, name: \"std::num::NonZero::<T>::new\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3new17h3cbc7a205e50ad1fE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn new(n: T) -> Option<Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        unsafe { intrinsics::transmute_unchecked(n) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 224, name: \"std::num::NonZero::<T>::new_unchecked\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new_unchecked",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked17hd3e157914eb40be4E",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 248, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17hd4ca9a9271618328E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 223, name: \"std::option::Option::<T>::is_none\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_none",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_none17hd6afafc489127163E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 225, name: \"std::option::Option::<T>::is_some\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_some",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_some17ha5fa074a52234010E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 261, name: \"std::option::Option::<T>::unwrap_or\" }",
        "func": {
          "name": "std::option::Option::<std::fmt::Alignment>::unwrap_or",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$9unwrap_or17h93449fbe40562582E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 236, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h4766a44e449f5bc0E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17h7028f0eba4c7a6f8E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he78cf8b05978fd0dE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::cast::<()>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hdc66bbbf9ca09606E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h521f17b23745bac9E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h8842d827e238f628E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h7751fb8567cbcb47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h9de03001895d0df8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h79cc454782b590c1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h4c90e7777850aeebE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h7dafd8edeaef92caE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17hc9f5a770b3d720c7E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hbab76e706044fa2eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h7c6d9cb10df2c094E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h04f77dd0bbba90e3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hd35b6c11a62aafd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h40068346434d50f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h8e78528254286707E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7757583d8ce29180E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h54ad99e807176d15E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h4637137071b370dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h157e6a6f791a927eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he7774680d992b871E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17he3b1371588b0fd61E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 205, name: \"std::ptr::align_offset\" }",
        "func": {
          "name": "std::ptr::align_offset::<u8>",
          "mangled_name": "_ZN4core3ptr12align_offset17hc37ffd11ea4851baE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n    // 1, where the method versions of these operations are not inlined.\n    use intrinsics::{\n        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n    };\n\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for `align_offset` and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x < m`; (if `x  m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }\n\n    let stride = size_of::<T>();\n\n    let addr: usize = p.addr();\n\n    // SAFETY: `a` is a power-of-two, therefore non-zero.\n    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n\n    if stride == 0 {\n        // SPECIAL_CASE: handle 0-sized types. No matter how many times we step, the address will\n        // stay the same, so no offset will be able to align the pointer unless it is already\n        // aligned. This branch _will_ be optimized out as `stride` is known at compile-time.\n        let p_mod_a = addr & a_minus_one;\n        return if p_mod_a == 0 { 0 } else { usize::MAX };\n    }\n\n    // SAFETY: `stride == 0` case has been handled by the special case above.\n    let a_mod_stride = unsafe { unchecked_rem(a, stride) };\n    if a_mod_stride == 0 {\n        // SPECIAL_CASE: In cases where the `a` is divisible by `stride`, byte offset to align a\n        // pointer can be computed more simply through `-p (mod a)`. In the off-chance the byte\n        // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n        // offset will be able to produce a `p` aligned to the specified `a`.\n        //\n        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n        // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n        // redistributes operations around the load-bearing, but pessimizing `and` instruction\n        // sufficiently for LLVM to be able to utilize the various optimizations it knows about.\n        //\n        // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated\n        // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`\n        // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n        // computation produces.\n\n        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n        let byte_offset = wrapping_sub(aligned_address, addr);\n        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n        // the value by more than `a-1`, so even though the intermediate values might have\n        // wrapped, the byte_offset is always in `[0, a)`.\n        unsafe { assume(byte_offset < a) };\n\n        // SAFETY: `stride == 0` case has been handled by the special case above.\n        let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n\n        return if addr_mod_stride == 0 {\n            // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n            // addr has been verified to be aligned to the original types alignment requirements.\n            unsafe { exact_div(byte_offset, stride) }\n        } else {\n            usize::MAX\n        };\n    }\n\n    // GENERAL_CASE: From here on were handling the very general case where `addr` may be\n    // misaligned, there isnt an obvious relationship between `stride` and `a` that we can take an\n    // advantage of, etc. This case produces machine code that isnt particularly high quality,\n    // compared to the special cases above. The code produced here is still within the realm of\n    // miracles, given the situations this case has to deal with.\n\n    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n    // FIXME(const-hack) replace with min\n    let gcdpow = unsafe {\n        let x = cttz_nonzero(stride);\n        let y = cttz_nonzero(a);\n        if x < y { x } else { y }\n    };\n    // SAFETY: gcdpow has an upper-bound thats at most the number of bits in a `usize`.\n    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n    // SAFETY: gcd is always greater or equal to 1.\n    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the\n        // second term is \"how does incrementing `p` by `s` bytes change the relative alignment of\n        // `p`\" (again divided by `g`). Division by `g` is necessary to make the inverse well\n        // formed if `a` and `s` are not co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. This `lcm(s, a)` is the same as `a'`.\n\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n        // in `a` (of which it has exactly one).\n        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let s2 = unsafe { unchecked_shr(stride & a_minus_one, gcdpow) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n        // always be strictly greater than `(p % a) >> gcdpow`.\n        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(addr & a_minus_one, gcdpow)) };\n        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::MAX\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 209, name: \"std::ptr::align_offset::mod_inv\" }",
        "func": {
          "name": "std::ptr::align_offset::mod_inv",
          "mangled_name": "_ZN4core3ptr12align_offset7mod_inv17h4226b9d4d3d5c672E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3e62dd7746f386b1E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h94920da9c4e41356E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::const_ptr::<impl *const T>::is_aligned_to\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_aligned_to",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$13is_aligned_to17hbaf8f80ac8bd74b5E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn is_aligned_to(self, align: usize) -> bool {\n        if !align.is_power_of_two() {\n            panic!(\"is_aligned_to: align is not a power-of-two\");\n        }\n\n        self.addr() & (align - 1) == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"std::ptr::const_ptr::<impl *const T>::is_null\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_null",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h39f2cba5693cfcbaE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"std::ptr::const_ptr::<impl *const T>::is_null::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::is_null::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null7runtime17h7dfd407882faecc4E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 149, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17h576dc75a826a2d0cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 153, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h347785d8fcffea35E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17h2d71e26de06a9244E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 269, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h4407a3d2505e3182E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 267, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h77a9a38a2fb82cebE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3a596104eca7202bE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h95babdad2d0fc1f3E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h0a576779c2a5921cE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h9d8ea600d403e2a7E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hea3399653658e906E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 148, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h7e1ae8494ab1b6a8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17hcedf28e570bccab6E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17hee8e32507ad62195E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb6d9630c236e0667E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hd7d033da755485feE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<&u8>",
          "mangled_name": "_ZN4core3ptr27drop_in_place$LT$$RF$u8$GT$17hc860db9297e59a65E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::fmt::Alignment>",
          "mangled_name": "_ZN4core3ptr41drop_in_place$LT$core..fmt..Alignment$GT$17h7053c6d7e77848ceE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::option::Option<(usize, char)>>",
          "mangled_name": "_ZN4core3ptr69drop_in_place$LT$core..option..Option$LT$$LP$usize$C$char$RP$$GT$$GT$17hc4a9cf5ac18a109aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<usize>",
          "mangled_name": "_ZN4core3ptr26drop_in_place$LT$usize$GT$17hc9921d2585312b1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17he2f3566df11993a9E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr772drop_in_place$LT$core..iter..adapters..map..map_fold$LT$$RF$u8$C$usize$C$usize$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$C$$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$..sum$LT$core..iter..adapters..map..Map$LT$core..slice..iter..Iter$LT$u8$GT$$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h6e7832b57095f296E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN4core3ptr98drop_in_place$LT$standard_proofs_with_contracts..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h4679a0277a176f46E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN4core3ptr98drop_in_place$LT$standard_proofs_with_contracts..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h518ff391ef125311E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN4core3ptr98drop_in_place$LT$standard_proofs_with_contracts..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17h624c0acb80c1ca2fE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN4core3ptr98drop_in_place$LT$standard_proofs_with_contracts..verify..contract..$u7b$$u7b$closure$u7d$$u7d$$GT$17hd3db5ee144c8ee27E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[[usize; 4]], [usize; 4]>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h366ed0a3a51d837eE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17hcbff0ea135f8c822E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[usize], usize>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h41eed9c7257b5a92E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 270, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h11e9b84f3b318493E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h9e0e2cfdf0904a7fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hf944f5073ef59a74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hce2dbc0a8530746fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h8a05fb28e37fbdd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 147, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17he8e6f7cbdd8f5e6eE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h058663281978a159E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h950a6db1729acb74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hdf15e8368e89c131E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h9b6c1ed71e4b6c54E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<usize>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h0392b72387600f22E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h6ba60a2281e8a542E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h7b2fb807837541dbE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<usize>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h953360cfbc2e7273E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17he0272cf1811aedffE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hc02bc4ce2e57232fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<usize>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17h3353948db1931310E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 243, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h237867c19800b78bE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_display\" }",
        "func": {
          "name": "std::rt::panic_display::<&str>",
          "mangled_name": "_ZN4core9panicking13panic_display17h9965c83dbdce9711E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n    panic_fmt(format_args!(\"{}\", *x));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17h8206d9c4fa94b0f1E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 204, name: \"std::slice::Chunks::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Chunks::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter15Chunks$LT$T$GT$3new17h61fc0016bb33d3a4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, [usize; 4]>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h7e563fa4aafeccbeE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 217, name: \"std::slice::Iter::<'a, T>::as_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::as_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$8as_slice17h5dbeb8b275b939f1E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 219, name: \"std::slice::Iter::<'a, T>::make_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::make_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$10make_slice17h65c3cdc1b15790e4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h9fd511ca042ff46dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hf5d3176cdb446f8dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, [usize; 4]>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb0c08e21a67d8321E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, u8>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17h20fd2a93730b1004E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, usize>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb415c774c30ce8d9E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 185, name: \"std::slice::from_raw_parts::precondition_check\" }",
        "func": {
          "name": "std::slice::from_raw_parts::precondition_check",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts18precondition_check17hf1448faea35264c6E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"std::str::CharIndices::<'a>::offset\" }",
        "func": {
          "name": "std::str::CharIndices::<'_>::offset",
          "mangled_name": "_ZN4core3str4iter11CharIndices6offset17h55d0a25e76f5da95E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 100, name: \"std::str::Chars::<'a>::as_str\" }",
        "func": {
          "name": "std::str::Chars::<'_>::as_str",
          "mangled_name": "_ZN4core3str4iter5Chars6as_str17hf072d8c9a8bc6de2E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn as_str(&self) -> &'a str {\n        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 218, name: \"std::str::from_utf8_unchecked\" }",
        "func": {
          "name": "std::str::from_utf8_unchecked",
          "mangled_name": "_ZN4core3str8converts19from_utf8_unchecked17hd68ebd84e1b684d4E",
          "kind": "Item",
          "file": "library/core/src/str/converts.rs",
          "src": "pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n    // Also relies on `&str` and `&[u8]` having the same layout.\n    unsafe { mem::transmute(v) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 34, name: \"verify::contract\" }",
        "func": {
          "name": "verify::contract",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract17h0c3d80ebc90a7e39E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 36, name: \"verify::contract::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract::kani_contract_mode",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract18kani_contract_mode17h4467e41803be7fc2E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 35, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract22kani_register_contract17h45b54adc63080c7fE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 35, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract22kani_register_contract17he73953af20a96d02E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 35, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract22kani_register_contract17he85e78dd22cbce91E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 35, name: \"verify::contract::kani_register_contract\" }",
        "func": {
          "name": "verify::contract::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:27:5: 27:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify8contract22kani_register_contract17hf9c6e4bddefef5bbE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      }
    ]
  },
  {
    "hash": "727098620446679346013924715404316869628",
    "def_id": "DefId { id: 13, name: \"verify::single_contract_requires\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": {
      "name": "verify::single_contract_requires",
      "mangled_name": "_ZN30standard_proofs_with_contracts6verify24single_contract_requires17h0d64c94d46269423E",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs_with_contracts.rs",
      "src": "fn single_contract_requires() {\n        contract_requires(0);\n    }",
      "before_expansion": null
    },
    "callees_len": 249,
    "callees": [
      {
        "def_id": "DefId { id: 64, name: \"<&T as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<&str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h410ed86c60f5cfc3E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }",
          "before_expansion": "fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }"
        }
      },
      {
        "def_id": "DefId { id: 254, name: \"<T as std::convert::From<T>>::from\" }",
        "func": {
          "name": "<std::fmt::Error as std::convert::From<std::fmt::Error>>::from",
          "mangled_name": "_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17he83ac1a1ecfe098bE",
          "kind": "Item",
          "file": "library/core/src/convert/mod.rs",
          "src": "fn from(t: T) -> T {\n        t\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize17hefafed2dd7e7b23dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::{closure#0}\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize28_$u7b$$u7b$closure$u7d$$u7d$17h58b8e91647087575E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "move |x| predicate(&x) as usize",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 108, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::iter::Filter<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}> as std::iter::Iterator>::count",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h3699bd088ef32d8bE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 121, name: \"<std::iter::Map<I, F> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::fold::<usize, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN102_$LT$core..iter..adapters..map..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h6d92003bf13c783fE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, map_fold(self.f, g))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 114, name: \"std::iter::Iterator::sum\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::sum::<usize>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3sum17h7d40d1f308b1005dE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn sum<S>(self) -> S\n    where\n        Self: Sized,\n        S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h7c9a54f8524b49a7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17hce7831b5e86d6af1E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h9c1f64b07716f02eE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17h2e2ab1a72ff80731E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 245, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h07c3e6fc52b3fedeE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 246, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h99f2f0e144b0be9fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[[usize; 4]]> as std::convert::From<&[[usize; 4]]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hf2bfe9aa01cc2a5cE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[u8]> as std::convert::From<&[u8]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17ha2f234dc854092f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize; 4]> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9d329a2fb5d239cdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize]> as std::convert::From<&[usize]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hda64db96e84d2849E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7c7ff8009b034788E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<usize> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h626a1d09fbfa6da4E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hc061659ac6d49be8E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hb63dc43fb3b8efe3E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hbf3169bb7998e829E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hf0fbb1a129a09e75E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h962da7a65ee8c669E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 170, name: \"<std::slice::Chunks<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN93_$LT$core..slice..iter..Chunks$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h28c7ddf67bd014beE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, [usize; 4]> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h0b79c4e6d4c47667E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 233, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17hcb764b037493d54cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"std::iter::Iterator::filter\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::filter::<{closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator6filter17h89d9720e37de1568E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn filter<P>(self, predicate: P) -> Filter<Self, P>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        Filter::new(self, predicate)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::fold::<usize, {closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h29ba2c4b195065b9E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"std::iter::Iterator::map\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::map::<usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3map17hbfc9ceba84a749aeE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn map<B, F>(self, f: F) -> Map<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> B,\n    {\n        Map::new(self, f)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hfadf3ba7fbb0614cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hae10bd58ec770fd8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 82, name: \"std::iter::Iterator::advance_by\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::advance_by",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator10advance_by17h0040525bd95241f2E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        for i in 0..n {\n            if self.next().is_none() {\n                // SAFETY: `i` is always less than `n`.\n                return Err(unsafe { NonZero::new_unchecked(n - i) });\n            }\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 222, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h86991728206f71e4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"<std::str::Chars<'a> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::count",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17hd17d710ff4eee22cE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn count(self) -> usize {\n        super::count::count_chars(self.as_str())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 234, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h5b0d866ec2d0f5f4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 238, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hcd9a1b225c5bc517E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 71, name: \"<str as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h2e4773966404a9e8E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 256, name: \"<u16 as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<u16 as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN47_$LT$u16$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17hf1a4da89e7daa5f0E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"std::cmp::Ord::min\" }",
        "func": {
          "name": "<usize as std::cmp::Ord>::min",
          "mangled_name": "_ZN4core3cmp3Ord3min17hca8e35334025e720E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        if other < self { other } else { self }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 229, name: \"<usize as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<usize as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN49_$LT$usize$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17ha98665aa01e86e87E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"<usize as std::iter::Sum>::sum\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum17hd4899a4f1283f91cE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"<usize as std::iter::Sum>::sum::{closure#0}\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum28_$u7b$$u7b$closure$u7d$$u7d$17hf553ffa479b229d7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "|a, b| a + b",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 263, name: \"core::fmt::PostPadding::new\" }",
        "func": {
          "name": "core::fmt::PostPadding::new",
          "mangled_name": "_ZN4core3fmt11PostPadding3new17h635173abc89c1c46E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn new(fill: char, padding: u16) -> PostPadding {\n        PostPadding { fill, padding }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"core::fmt::PostPadding::write\" }",
        "func": {
          "name": "core::fmt::PostPadding::write",
          "mangled_name": "_ZN4core3fmt11PostPadding5write17he27432ff58f0176fE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n        for _ in 0..self.padding {\n            f.buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 65, name: \"core::fmt::rt::Argument::<'_>::new\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument3new17hc43cfa4d4cc7eeb3E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "const fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'a> {\n        Argument {\n            // INVARIANT: this creates an `ArgumentType<'a>` from a `&'a T` and\n            // a `fn(&T, ...)`, so the invariant is maintained.\n            ty: ArgumentType::Placeholder {\n                value: NonNull::from_ref(x).cast(),\n                // SAFETY: function pointers always have the same layout.\n                formatter: unsafe { mem::transmute(f) },\n                _lifetime: PhantomData,\n            },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 57, name: \"core::fmt::rt::Argument::<'_>::new_display\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new_display::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument11new_display17h2abb0f96064d56d7E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "pub fn new_display<T: Display>(x: &T) -> Argument<'_> {\n        Self::new(x, Display::fmt)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 259, name: \"core::num::<impl u16>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl u16>::overflowing_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$15overflowing_add17h711f2c8f6e02c5aaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 257, name: \"core::num::<impl u16>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add17hec98168318b5d827E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 258, name: \"core::num::<impl u16>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add18precondition_check17h9d272714b118328cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 244, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h036191e61598aedaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 193, name: \"core::num::<impl usize>::count_ones\" }",
        "func": {
          "name": "core::num::<impl usize>::count_ones",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$10count_ones17h5848180a66ff35a5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 192, name: \"core::num::<impl usize>::is_power_of_two\" }",
        "func": {
          "name": "core::num::<impl usize>::is_power_of_two",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15is_power_of_two17h25612661704e08b9E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"core::num::<impl usize>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_add17hae858b6d0d0dc624E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 203, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17ha23631731d5dc26cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 132, name: \"core::num::<impl usize>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add17hc42a707166fea5e5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"core::num::<impl usize>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add18precondition_check17h463cf773999eaa82E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 199, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h118193beb20e1102E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 202, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17hc50a9a68f99e942bE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 215, name: \"core::num::<impl usize>::wrapping_mul\" }",
        "func": {
          "name": "core::num::<impl usize>::wrapping_mul",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$12wrapping_mul17h0d4deee3af61861dE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 142, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h8572d23834841ad0E",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17hee37ceed2bfa2394E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 137, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17h21f756518b770eccE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17ha5c466fea0230c4cE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h077fbeb784973dc1E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::<impl [T]>::as_chunks_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::as_chunks_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked18precondition_check17hae985b6008ba8febE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"core::slice::<impl [T]>::split_at_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::split_at_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked18precondition_check17h036498ebedbca62dE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [[usize; 4]]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h1f796214e285bd05E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 163, name: \"core::slice::<impl [T]>::align_to\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8align_to17h3f2f55440dbd3412E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is  don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 207, name: \"core::slice::<impl [T]>::align_to_offsets\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to_offsets::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16align_to_offsets17h9a870748ec74d22cE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17h78ea551bdbf9c409E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9261551842730f07E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h6fde5a5a7a6da893E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h0771b4bddc48611aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h8b631703f7d638d3E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 171, name: \"core::slice::<impl [T]>::as_chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$9as_chunks17h62f5495583e80f1aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len_rounded_down = self.len() / N * N;\n        // SAFETY: The rounded-down value is always the same or smaller than the\n        // original length, and thus must be in-bounds of the slice.\n        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 179, name: \"core::slice::<impl [T]>::as_chunks_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks_unchecked::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked17h8e9f62deb4bed8e1E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        );\n        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n        let new_len = unsafe { exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17hb16374a047362e58E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 166, name: \"core::slice::<impl [T]>::chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::chunks",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6chunks17ha09721e0e969e33aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert!(chunk_size != 0, \"chunk size must be non-zero\");\n        Chunks::new(self, chunk_size)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 164, name: \"core::slice::<impl [T]>::is_empty\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::is_empty",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8is_empty17ha518b9eb9d09acddE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9bded35725a0f34bE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h4760363bd3d8df7dE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h33e3be9e163f3d84E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h2ba5f3ee616a9de4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[[usize; 4]]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17hd4a47bd844608dd0E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[usize]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17h59a4497cf99cfe33E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hfe1187add6301ee6E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17h2ef4bb22e84c1a37E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17h8fcb935f0f5f0c0bE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::RangeTo<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h949054447ff215bbE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 102, name: \"core::str::<impl str>::len\" }",
        "func": {
          "name": "core::str::<impl str>::len",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$3len17h0efa33433be36319E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn len(&self) -> usize {\n        self.as_bytes().len()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 104, name: \"core::str::count::char_count_general_case\" }",
        "func": {
          "name": "core::str::count::char_count_general_case",
          "mangled_name": "_ZN4core3str5count23char_count_general_case17h9194c83a4785e6c0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn char_count_general_case(s: &[u8]) -> usize {\n    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::count::char_count_general_case::{closure#0}\" }",
        "func": {
          "name": "core::str::count::char_count_general_case::{closure#0}",
          "mangled_name": "_ZN4core3str5count23char_count_general_case28_$u7b$$u7b$closure$u7d$$u7d$17h394284915c90711eE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "|&&byte| !super::validations::utf8_is_cont_byte(byte)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 176, name: \"core::str::count::contains_non_continuation_byte\" }",
        "func": {
          "name": "core::str::count::contains_non_continuation_byte",
          "mangled_name": "_ZN4core3str5count30contains_non_continuation_byte17hde3d14fc61658f17E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn contains_non_continuation_byte(w: usize) -> usize {\n    const LSB: usize = usize::repeat_u8(0x01);\n    ((!w >> 7) | (w >> 6)) & LSB\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 101, name: \"core::str::count::count_chars\" }",
        "func": {
          "name": "core::str::count::count_chars",
          "mangled_name": "_ZN4core3str5count11count_chars17h438fe512170f6882E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "pub(super) fn count_chars(s: &str) -> usize {\n    if cfg!(feature = \"optimize_for_size\") || s.len() < USIZE_SIZE * UNROLL_INNER {\n        // Avoid entering the optimized implementation for strings where the\n        // difference is not likely to matter, or where it might even be slower.\n        // That said, a ton of thought was not spent on the particular threshold\n        // here, beyond \"this value seems to make sense\".\n        char_count_general_case(s.as_bytes())\n    } else {\n        do_count_chars(s)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 105, name: \"core::str::count::do_count_chars\" }",
        "func": {
          "name": "core::str::count::do_count_chars",
          "mangled_name": "_ZN4core3str5count14do_count_chars17h75afdc7e2f50899aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 175, name: \"core::str::count::sum_bytes_in_usize\" }",
        "func": {
          "name": "core::str::count::sum_bytes_in_usize",
          "mangled_name": "_ZN4core3str5count18sum_bytes_in_usize17h0fe82d38e63b1ff2E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn sum_bytes_in_usize(values: usize) -> usize {\n    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n\n    let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 266, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h3e681accfd37035aE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 268, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h9bf8221b9faf40cbE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 265, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits110_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..RangeTo$LT$usize$GT$$GT$13get_unchecked17h926389fc19e40548E",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 235, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17h49ef59a58d9bb16bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 249, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17hc891eb537972639bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 247, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17hb45ca0db55f7758bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17hd8ea0d008709b6b4E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17h6827fd98917f2969E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 146, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17h105d247d9515ffcdE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 188, name: \"core::ub_checks::is_valid_allocation_size\" }",
        "func": {
          "name": "core::ub_checks::is_valid_allocation_size",
          "mangled_name": "_ZN4core9ub_checks24is_valid_allocation_size17h90616824e065af89E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {\n    let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };\n    len <= max_len\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"core::ub_checks::maybe_is_aligned_and_not_null\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null17h1c617f69f5e4fe01E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn maybe_is_aligned_and_not_null(\n    ptr: *const (),\n    align: usize,\n    is_zst: bool,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 189, name: \"core::ub_checks::maybe_is_aligned_and_not_null::runtime\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null::runtime",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null7runtime17hc3925ab73c46a78aE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 53, name: \"kani::panic\" }",
        "func": {
          "name": "kani::panic",
          "mangled_name": "_ZN4kani5panic17h6190bada9522f78aE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn panic(message: &'static str) -> ! {\n            panic!(\"{}\", message)\n        }",
          "before_expansion": "kani_core::kani_intrinsics!(std)"
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"kani::panic::panic_cold_display\" }",
        "func": {
          "name": "kani::panic::panic_cold_display::<&str>",
          "mangled_name": "_ZN4kani5panic18panic_cold_display17h3c77492d46a89dbbE",
          "kind": "Item",
          "file": "library/core/src/panic.rs",
          "src": "const fn panic_cold_display<T: $crate::fmt::Display>(arg: &T) -> ! {\n            $crate::panicking::panic_display(arg)\n        }",
          "before_expansion": "panic!(\"{}\", message)"
        }
      },
      {
        "def_id": "DefId { id: 174, name: \"std::array::<impl std::iter::IntoIterator for &'a [T; N]>::into_iter\" }",
        "func": {
          "name": "std::array::<impl std::iter::IntoIterator for &[usize; 4]>::into_iter",
          "mangled_name": "_ZN4core5array98_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u3b$$u20$N$u5d$$GT$9into_iter17he1c19779b96d5e95E",
          "kind": "Item",
          "file": "library/core/src/array/mod.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 242, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217h79452afed33d8afaE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 240, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17hd069e3b6813f4d52E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 241, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h8dade502d8f04feeE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )"
        }
      },
      {
        "def_id": "DefId { id: 239, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h2c8c127ff9716582E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 255, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt",
          "mangled_name": "_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u16$GT$2lt17h2e1d14712d03b1a2E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 214, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt",
          "mangled_name": "_ZN4core3cmp5impls57_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$usize$GT$2lt17h551740291a2e7191E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 211, name: \"std::cmp::min\" }",
        "func": {
          "name": "std::cmp::min::<usize>",
          "mangled_name": "_ZN4core3cmp3min17hdf73c061ba7372f8E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "pub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::convert::num::<impl std::convert::From<u16> for usize>::from\" }",
        "func": {
          "name": "std::convert::num::<impl std::convert::From<u16> for usize>::from",
          "mangled_name": "_ZN4core7convert3num66_$LT$impl$u20$core..convert..From$LT$u16$GT$$u20$for$u20$usize$GT$4from17hcff1e1e2ee4568c2E",
          "kind": "Item",
          "file": "library/core/src/convert/num.rs",
          "src": "fn from(small: $Small) -> Self {\n                small as Self\n            }",
          "before_expansion": "impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        )"
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hbb45028c907195c1E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::fmt::Arguments::<'a>::new_v1\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_v1::<1, 1>",
          "mangled_name": "_ZN4core3fmt9Arguments6new_v117heaed1009cc26b388E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_v1<const P: usize, const A: usize>(\n        pieces: &'a [&'static str; P],\n        args: &'a [rt::Argument<'a>; A],\n    ) -> Arguments<'a> {\n        const { assert!(P >= A && P <= A + 1, \"invalid args\") }\n        Arguments { pieces, fmt: None, args }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 73, name: \"std::fmt::Formatter::<'a>::pad\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::pad",
          "mangled_name": "_ZN4core3fmt9Formatter3pad17he3971bd2e0830220E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front.\n        if self.options.flags & (flags::WIDTH_FLAG | flags::PRECISION_FLAG) == 0 {\n            return self.buf.write_str(s);\n        }\n\n        // The `precision` field can be interpreted as a maximum width for the\n        // string being formatted.\n        let (s, char_count) = if let Some(max_char_count) = self.options.get_precision() {\n            let mut iter = s.char_indices();\n            let remaining = match iter.advance_by(usize::from(max_char_count)) {\n                Ok(()) => 0,\n                Err(remaining) => remaining.get(),\n            };\n            // SAFETY: The offset of `.char_indices()` is guaranteed to be\n            // in-bounds and between character boundaries.\n            let truncated = unsafe { s.get_unchecked(..iter.offset()) };\n            (truncated, usize::from(max_char_count) - remaining)\n        } else {\n            // Use the optimized char counting algorithm for the full string.\n            (s, s.chars().count())\n        };\n\n        // The `width` field is more of a minimum width parameter at this point.\n        if char_count < usize::from(self.options.width) {\n            // If we're under the minimum width, then fill up the minimum width\n            // with the specified string + some alignment.\n            let post_padding =\n                self.padding(self.options.width - char_count as u16, Alignment::Left)?;\n            self.buf.write_str(s)?;\n            post_padding.write(self)\n        } else {\n            // If we're over the minimum width or there is no minimum width, we\n            // can just emit the string.\n            self.buf.write_str(s)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"std::fmt::Formatter::<'a>::padding\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::padding",
          "mangled_name": "_ZN4core3fmt9Formatter7padding17h53f9e78fb4099400E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn padding(\n        &mut self,\n        padding: u16,\n        default: Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = self.options.get_align().unwrap_or(default);\n        let fill = self.options.get_fill();\n\n        let padding_left = match align {\n            Alignment::Left => 0,\n            Alignment::Right => padding,\n            Alignment::Center => padding / 2,\n        };\n\n        for _ in 0..padding_left {\n            self.buf.write_char(fill)?;\n        }\n\n        Ok(PostPadding::new(fill, padding - padding_left))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 260, name: \"std::fmt::FormattingOptions::get_align\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_align",
          "mangled_name": "_ZN4core3fmt17FormattingOptions9get_align17h8b918746f9c015ffE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_align(&self) -> Option<Alignment> {\n        match self.flags & flags::ALIGN_BITS {\n            flags::ALIGN_LEFT => Some(Alignment::Left),\n            flags::ALIGN_RIGHT => Some(Alignment::Right),\n            flags::ALIGN_CENTER => Some(Alignment::Center),\n            _ => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 262, name: \"std::fmt::FormattingOptions::get_fill\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_fill",
          "mangled_name": "_ZN4core3fmt17FormattingOptions8get_fill17h43c04343d70b7042E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_fill(&self) -> char {\n        // SAFETY: We only ever put a valid `char` in the lower 21 bits of the flags field.\n        unsafe { char::from_u32_unchecked(self.flags & 0x1FFFFF) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 78, name: \"std::fmt::FormattingOptions::get_precision\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_precision",
          "mangled_name": "_ZN4core3fmt17FormattingOptions13get_precision17hbd80eaff3d1888beE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_precision(&self) -> Option<u16> {\n        if self.flags & flags::PRECISION_FLAG != 0 { Some(self.precision) } else { None }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 250, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17hb85c714223239900E",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 251, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17haa76a7dc7c6e5497E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )"
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17he733dcfdc3261fb2E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 165, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17hed6aa9940a66cedcE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 157, name: \"std::iter::Filter::<I, P>::new\" }",
        "func": {
          "name": "std::iter::Filter::<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters6filter19Filter$LT$I$C$P$GT$3new17hc34a2f01600b7b29E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n        Filter { iter, predicate }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::iter::Map::<I, F>::new\" }",
        "func": {
          "name": "std::iter::Map::<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters3map16Map$LT$I$C$F$GT$3new17h53f0d55450f62c1dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n        Map { iter, f }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"std::iter::adapters::map::map_fold\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold17hfb84ea7d0fb8cbffE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn map_fold<T, B, Acc>(\n    mut f: impl FnMut(T) -> B,\n    mut g: impl FnMut(Acc, B) -> Acc,\n) -> impl FnMut(Acc, T) -> Acc {\n    move |acc, elt| g(acc, f(elt))\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::iter::adapters::map::map_fold::{closure#0}\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold28_$u7b$$u7b$closure$u7d$$u7d$17hb3e453f99d84d8bfE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "move |acc, elt| g(acc, f(elt))",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<u16>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17h07bdeaaf39b8685aE",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<usize>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hd27f508ace781eb9E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem8align_of17h4ccf9d5c0139d079E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<u8>",
          "mangled_name": "_ZN4core3mem8align_of17hcf7fa5208d41c27fE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<usize>",
          "mangled_name": "_ZN4core3mem8align_of17h512cbae0980bb36dE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem7size_of17h0553276df7ba24c2E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17hd68b5fd240b661c5E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<usize>",
          "mangled_name": "_ZN4core3mem7size_of17hd5b2a7cccbb61ceeE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 231, name: \"std::num::NonZero::<T>::new_unchecked::precondition_check\" }",
        "func": {
          "name": "std::num::NonZero::<T>::new_unchecked::precondition_check",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked18precondition_check17h0116c509d606ce2cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    )"
        }
      },
      {
        "def_id": "DefId { id: 84, name: \"std::num::NonZero::<T>::get\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::get",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3get17h87da58b24eb8904aE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn get(self) -> T {\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // Using the transmute `assume`s the range at runtime.\n        //\n        // Even once LLVM supports `!range` metadata for function arguments\n        // (see <https://github.com/llvm/llvm-project/issues/76628>), this can't\n        // be `.0` because MCP#807 bans field-projecting into `scalar_valid_range`\n        // types, and it arguably wouldn't want to be anyway because if this is\n        // MIR-inlined, there's no opportunity to put that argument metadata anywhere.\n        //\n        // The good answer here will eventually be pattern types, which will hopefully\n        // allow it to go back to `.0`, maybe with a cast of some sort.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 230, name: \"std::num::NonZero::<T>::new\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3new17h3cbc7a205e50ad1fE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn new(n: T) -> Option<Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        unsafe { intrinsics::transmute_unchecked(n) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 224, name: \"std::num::NonZero::<T>::new_unchecked\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new_unchecked",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked17hd3e157914eb40be4E",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 248, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17hd4ca9a9271618328E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 223, name: \"std::option::Option::<T>::is_none\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_none",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_none17hd6afafc489127163E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 225, name: \"std::option::Option::<T>::is_some\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_some",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_some17ha5fa074a52234010E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 261, name: \"std::option::Option::<T>::unwrap_or\" }",
        "func": {
          "name": "std::option::Option::<std::fmt::Alignment>::unwrap_or",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$9unwrap_or17h93449fbe40562582E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 236, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h4766a44e449f5bc0E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17h7028f0eba4c7a6f8E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he78cf8b05978fd0dE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::cast::<()>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hdc66bbbf9ca09606E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h521f17b23745bac9E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h8842d827e238f628E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h7751fb8567cbcb47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h9de03001895d0df8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h79cc454782b590c1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h4c90e7777850aeebE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h7dafd8edeaef92caE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17hc9f5a770b3d720c7E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hbab76e706044fa2eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h7c6d9cb10df2c094E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h04f77dd0bbba90e3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hd35b6c11a62aafd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h40068346434d50f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h8e78528254286707E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7757583d8ce29180E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h54ad99e807176d15E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h4637137071b370dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h157e6a6f791a927eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he7774680d992b871E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17he3b1371588b0fd61E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 205, name: \"std::ptr::align_offset\" }",
        "func": {
          "name": "std::ptr::align_offset::<u8>",
          "mangled_name": "_ZN4core3ptr12align_offset17hc37ffd11ea4851baE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n    // 1, where the method versions of these operations are not inlined.\n    use intrinsics::{\n        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n    };\n\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for `align_offset` and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x < m`; (if `x  m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }\n\n    let stride = size_of::<T>();\n\n    let addr: usize = p.addr();\n\n    // SAFETY: `a` is a power-of-two, therefore non-zero.\n    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n\n    if stride == 0 {\n        // SPECIAL_CASE: handle 0-sized types. No matter how many times we step, the address will\n        // stay the same, so no offset will be able to align the pointer unless it is already\n        // aligned. This branch _will_ be optimized out as `stride` is known at compile-time.\n        let p_mod_a = addr & a_minus_one;\n        return if p_mod_a == 0 { 0 } else { usize::MAX };\n    }\n\n    // SAFETY: `stride == 0` case has been handled by the special case above.\n    let a_mod_stride = unsafe { unchecked_rem(a, stride) };\n    if a_mod_stride == 0 {\n        // SPECIAL_CASE: In cases where the `a` is divisible by `stride`, byte offset to align a\n        // pointer can be computed more simply through `-p (mod a)`. In the off-chance the byte\n        // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n        // offset will be able to produce a `p` aligned to the specified `a`.\n        //\n        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n        // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n        // redistributes operations around the load-bearing, but pessimizing `and` instruction\n        // sufficiently for LLVM to be able to utilize the various optimizations it knows about.\n        //\n        // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated\n        // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`\n        // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n        // computation produces.\n\n        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n        let byte_offset = wrapping_sub(aligned_address, addr);\n        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n        // the value by more than `a-1`, so even though the intermediate values might have\n        // wrapped, the byte_offset is always in `[0, a)`.\n        unsafe { assume(byte_offset < a) };\n\n        // SAFETY: `stride == 0` case has been handled by the special case above.\n        let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n\n        return if addr_mod_stride == 0 {\n            // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n            // addr has been verified to be aligned to the original types alignment requirements.\n            unsafe { exact_div(byte_offset, stride) }\n        } else {\n            usize::MAX\n        };\n    }\n\n    // GENERAL_CASE: From here on were handling the very general case where `addr` may be\n    // misaligned, there isnt an obvious relationship between `stride` and `a` that we can take an\n    // advantage of, etc. This case produces machine code that isnt particularly high quality,\n    // compared to the special cases above. The code produced here is still within the realm of\n    // miracles, given the situations this case has to deal with.\n\n    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n    // FIXME(const-hack) replace with min\n    let gcdpow = unsafe {\n        let x = cttz_nonzero(stride);\n        let y = cttz_nonzero(a);\n        if x < y { x } else { y }\n    };\n    // SAFETY: gcdpow has an upper-bound thats at most the number of bits in a `usize`.\n    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n    // SAFETY: gcd is always greater or equal to 1.\n    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the\n        // second term is \"how does incrementing `p` by `s` bytes change the relative alignment of\n        // `p`\" (again divided by `g`). Division by `g` is necessary to make the inverse well\n        // formed if `a` and `s` are not co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. This `lcm(s, a)` is the same as `a'`.\n\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n        // in `a` (of which it has exactly one).\n        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let s2 = unsafe { unchecked_shr(stride & a_minus_one, gcdpow) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n        // always be strictly greater than `(p % a) >> gcdpow`.\n        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(addr & a_minus_one, gcdpow)) };\n        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::MAX\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 209, name: \"std::ptr::align_offset::mod_inv\" }",
        "func": {
          "name": "std::ptr::align_offset::mod_inv",
          "mangled_name": "_ZN4core3ptr12align_offset7mod_inv17h4226b9d4d3d5c672E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3e62dd7746f386b1E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h94920da9c4e41356E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::const_ptr::<impl *const T>::is_aligned_to\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_aligned_to",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$13is_aligned_to17hbaf8f80ac8bd74b5E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn is_aligned_to(self, align: usize) -> bool {\n        if !align.is_power_of_two() {\n            panic!(\"is_aligned_to: align is not a power-of-two\");\n        }\n\n        self.addr() & (align - 1) == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"std::ptr::const_ptr::<impl *const T>::is_null\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_null",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h39f2cba5693cfcbaE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"std::ptr::const_ptr::<impl *const T>::is_null::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::is_null::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null7runtime17h7dfd407882faecc4E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 149, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17h576dc75a826a2d0cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 153, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h347785d8fcffea35E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17h2d71e26de06a9244E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 269, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h4407a3d2505e3182E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 267, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h77a9a38a2fb82cebE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3a596104eca7202bE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h95babdad2d0fc1f3E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h0a576779c2a5921cE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h9d8ea600d403e2a7E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hea3399653658e906E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 148, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h7e1ae8494ab1b6a8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17hcedf28e570bccab6E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17hee8e32507ad62195E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb6d9630c236e0667E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hd7d033da755485feE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<&u8>",
          "mangled_name": "_ZN4core3ptr27drop_in_place$LT$$RF$u8$GT$17hc860db9297e59a65E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::fmt::Alignment>",
          "mangled_name": "_ZN4core3ptr41drop_in_place$LT$core..fmt..Alignment$GT$17h7053c6d7e77848ceE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::option::Option<(usize, char)>>",
          "mangled_name": "_ZN4core3ptr69drop_in_place$LT$core..option..Option$LT$$LP$usize$C$char$RP$$GT$$GT$17hc4a9cf5ac18a109aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<usize>",
          "mangled_name": "_ZN4core3ptr26drop_in_place$LT$usize$GT$17hc9921d2585312b1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17he2f3566df11993a9E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr772drop_in_place$LT$core..iter..adapters..map..map_fold$LT$$RF$u8$C$usize$C$usize$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$C$$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$..sum$LT$core..iter..adapters..map..Map$LT$core..slice..iter..Iter$LT$u8$GT$$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h6e7832b57095f296E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17h17b5b31bf44d2b41E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17h4d53b215fb76b000E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17hb7b2e8dda93db67eE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17hce6ba17a777dd83fE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[[usize; 4]], [usize; 4]>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h366ed0a3a51d837eE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17hcbff0ea135f8c822E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[usize], usize>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h41eed9c7257b5a92E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 270, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h11e9b84f3b318493E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h9e0e2cfdf0904a7fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hf944f5073ef59a74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hce2dbc0a8530746fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h8a05fb28e37fbdd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 147, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17he8e6f7cbdd8f5e6eE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h058663281978a159E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h950a6db1729acb74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hdf15e8368e89c131E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h9b6c1ed71e4b6c54E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<usize>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h0392b72387600f22E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h6ba60a2281e8a542E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h7b2fb807837541dbE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<usize>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h953360cfbc2e7273E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17he0272cf1811aedffE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hc02bc4ce2e57232fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<usize>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17h3353948db1931310E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 243, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h237867c19800b78bE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_display\" }",
        "func": {
          "name": "std::rt::panic_display::<&str>",
          "mangled_name": "_ZN4core9panicking13panic_display17h9965c83dbdce9711E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n    panic_fmt(format_args!(\"{}\", *x));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17h8206d9c4fa94b0f1E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 204, name: \"std::slice::Chunks::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Chunks::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter15Chunks$LT$T$GT$3new17h61fc0016bb33d3a4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, [usize; 4]>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h7e563fa4aafeccbeE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 217, name: \"std::slice::Iter::<'a, T>::as_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::as_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$8as_slice17h5dbeb8b275b939f1E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 219, name: \"std::slice::Iter::<'a, T>::make_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::make_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$10make_slice17h65c3cdc1b15790e4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h9fd511ca042ff46dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hf5d3176cdb446f8dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, [usize; 4]>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb0c08e21a67d8321E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, u8>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17h20fd2a93730b1004E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, usize>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb415c774c30ce8d9E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 185, name: \"std::slice::from_raw_parts::precondition_check\" }",
        "func": {
          "name": "std::slice::from_raw_parts::precondition_check",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts18precondition_check17hf1448faea35264c6E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"std::str::CharIndices::<'a>::offset\" }",
        "func": {
          "name": "std::str::CharIndices::<'_>::offset",
          "mangled_name": "_ZN4core3str4iter11CharIndices6offset17h55d0a25e76f5da95E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 100, name: \"std::str::Chars::<'a>::as_str\" }",
        "func": {
          "name": "std::str::Chars::<'_>::as_str",
          "mangled_name": "_ZN4core3str4iter5Chars6as_str17hf072d8c9a8bc6de2E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn as_str(&self) -> &'a str {\n        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 218, name: \"std::str::from_utf8_unchecked\" }",
        "func": {
          "name": "std::str::from_utf8_unchecked",
          "mangled_name": "_ZN4core3str8converts19from_utf8_unchecked17hd68ebd84e1b684d4E",
          "kind": "Item",
          "file": "library/core/src/str/converts.rs",
          "src": "pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n    // Also relies on `&str` and `&[u8]` having the same layout.\n    unsafe { mem::transmute(v) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 0, name: \"verify::contract_requires\" }",
        "func": {
          "name": "verify::contract_requires",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires17h8ea4e103f55510c3E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 2, name: \"verify::contract_requires::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract_requires::kani_contract_mode",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires18kani_contract_mode17h095815dd71e1bf74E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17h35512546ce26d64aE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17h7cd3005d1148b7d7E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17hacdf4063781e55ccE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17hbf238611e5467868E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      }
    ]
  },
  {
    "hash": "1268332559511546744811832901437696030765",
    "def_id": "DefId { id: 32, name: \"verify::single_with_contract_ensures\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": {
      "name": "verify::single_with_contract_ensures",
      "mangled_name": "_ZN30standard_proofs_with_contracts6verify28single_with_contract_ensures17h20b53bc2b62de06bE",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs_with_contracts.rs",
      "src": "fn single_with_contract_ensures() {\n        contract_ensures(0);\n    }",
      "before_expansion": null
    },
    "callees_len": 249,
    "callees": [
      {
        "def_id": "DefId { id: 64, name: \"<&T as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<&str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h410ed86c60f5cfc3E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }",
          "before_expansion": "fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }"
        }
      },
      {
        "def_id": "DefId { id: 254, name: \"<T as std::convert::From<T>>::from\" }",
        "func": {
          "name": "<std::fmt::Error as std::convert::From<std::fmt::Error>>::from",
          "mangled_name": "_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17he83ac1a1ecfe098bE",
          "kind": "Item",
          "file": "library/core/src/convert/mod.rs",
          "src": "fn from(t: T) -> T {\n        t\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize17hefafed2dd7e7b23dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::{closure#0}\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize28_$u7b$$u7b$closure$u7d$$u7d$17h58b8e91647087575E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "move |x| predicate(&x) as usize",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 108, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::iter::Filter<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}> as std::iter::Iterator>::count",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h3699bd088ef32d8bE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 121, name: \"<std::iter::Map<I, F> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::fold::<usize, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN102_$LT$core..iter..adapters..map..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h6d92003bf13c783fE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, map_fold(self.f, g))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 114, name: \"std::iter::Iterator::sum\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::sum::<usize>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3sum17h7d40d1f308b1005dE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn sum<S>(self) -> S\n    where\n        Self: Sized,\n        S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h7c9a54f8524b49a7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17hce7831b5e86d6af1E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h9c1f64b07716f02eE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17h2e2ab1a72ff80731E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 245, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h07c3e6fc52b3fedeE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 246, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h99f2f0e144b0be9fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[[usize; 4]]> as std::convert::From<&[[usize; 4]]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hf2bfe9aa01cc2a5cE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[u8]> as std::convert::From<&[u8]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17ha2f234dc854092f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize; 4]> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9d329a2fb5d239cdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize]> as std::convert::From<&[usize]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hda64db96e84d2849E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7c7ff8009b034788E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<usize> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h626a1d09fbfa6da4E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hc061659ac6d49be8E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hb63dc43fb3b8efe3E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hbf3169bb7998e829E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hf0fbb1a129a09e75E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h962da7a65ee8c669E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 170, name: \"<std::slice::Chunks<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN93_$LT$core..slice..iter..Chunks$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h28c7ddf67bd014beE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, [usize; 4]> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h0b79c4e6d4c47667E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 233, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17hcb764b037493d54cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"std::iter::Iterator::filter\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::filter::<{closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator6filter17h89d9720e37de1568E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn filter<P>(self, predicate: P) -> Filter<Self, P>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        Filter::new(self, predicate)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::fold::<usize, {closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h29ba2c4b195065b9E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"std::iter::Iterator::map\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::map::<usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3map17hbfc9ceba84a749aeE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn map<B, F>(self, f: F) -> Map<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> B,\n    {\n        Map::new(self, f)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hfadf3ba7fbb0614cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hae10bd58ec770fd8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 82, name: \"std::iter::Iterator::advance_by\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::advance_by",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator10advance_by17h0040525bd95241f2E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        for i in 0..n {\n            if self.next().is_none() {\n                // SAFETY: `i` is always less than `n`.\n                return Err(unsafe { NonZero::new_unchecked(n - i) });\n            }\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 222, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h86991728206f71e4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"<std::str::Chars<'a> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::count",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17hd17d710ff4eee22cE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn count(self) -> usize {\n        super::count::count_chars(self.as_str())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 234, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h5b0d866ec2d0f5f4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 238, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hcd9a1b225c5bc517E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 71, name: \"<str as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h2e4773966404a9e8E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 256, name: \"<u16 as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<u16 as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN47_$LT$u16$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17hf1a4da89e7daa5f0E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"std::cmp::Ord::min\" }",
        "func": {
          "name": "<usize as std::cmp::Ord>::min",
          "mangled_name": "_ZN4core3cmp3Ord3min17hca8e35334025e720E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        if other < self { other } else { self }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 229, name: \"<usize as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<usize as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN49_$LT$usize$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17ha98665aa01e86e87E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"<usize as std::iter::Sum>::sum\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum17hd4899a4f1283f91cE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"<usize as std::iter::Sum>::sum::{closure#0}\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum28_$u7b$$u7b$closure$u7d$$u7d$17hf553ffa479b229d7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "|a, b| a + b",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 263, name: \"core::fmt::PostPadding::new\" }",
        "func": {
          "name": "core::fmt::PostPadding::new",
          "mangled_name": "_ZN4core3fmt11PostPadding3new17h635173abc89c1c46E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn new(fill: char, padding: u16) -> PostPadding {\n        PostPadding { fill, padding }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"core::fmt::PostPadding::write\" }",
        "func": {
          "name": "core::fmt::PostPadding::write",
          "mangled_name": "_ZN4core3fmt11PostPadding5write17he27432ff58f0176fE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n        for _ in 0..self.padding {\n            f.buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 65, name: \"core::fmt::rt::Argument::<'_>::new\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument3new17hc43cfa4d4cc7eeb3E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "const fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'a> {\n        Argument {\n            // INVARIANT: this creates an `ArgumentType<'a>` from a `&'a T` and\n            // a `fn(&T, ...)`, so the invariant is maintained.\n            ty: ArgumentType::Placeholder {\n                value: NonNull::from_ref(x).cast(),\n                // SAFETY: function pointers always have the same layout.\n                formatter: unsafe { mem::transmute(f) },\n                _lifetime: PhantomData,\n            },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 57, name: \"core::fmt::rt::Argument::<'_>::new_display\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new_display::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument11new_display17h2abb0f96064d56d7E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "pub fn new_display<T: Display>(x: &T) -> Argument<'_> {\n        Self::new(x, Display::fmt)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 259, name: \"core::num::<impl u16>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl u16>::overflowing_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$15overflowing_add17h711f2c8f6e02c5aaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 257, name: \"core::num::<impl u16>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add17hec98168318b5d827E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 258, name: \"core::num::<impl u16>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add18precondition_check17h9d272714b118328cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 244, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h036191e61598aedaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 193, name: \"core::num::<impl usize>::count_ones\" }",
        "func": {
          "name": "core::num::<impl usize>::count_ones",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$10count_ones17h5848180a66ff35a5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 192, name: \"core::num::<impl usize>::is_power_of_two\" }",
        "func": {
          "name": "core::num::<impl usize>::is_power_of_two",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15is_power_of_two17h25612661704e08b9E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"core::num::<impl usize>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_add17hae858b6d0d0dc624E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 203, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17ha23631731d5dc26cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 132, name: \"core::num::<impl usize>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add17hc42a707166fea5e5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"core::num::<impl usize>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add18precondition_check17h463cf773999eaa82E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 199, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h118193beb20e1102E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 202, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17hc50a9a68f99e942bE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 215, name: \"core::num::<impl usize>::wrapping_mul\" }",
        "func": {
          "name": "core::num::<impl usize>::wrapping_mul",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$12wrapping_mul17h0d4deee3af61861dE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 142, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h8572d23834841ad0E",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17hee37ceed2bfa2394E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 137, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17h21f756518b770eccE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17ha5c466fea0230c4cE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h077fbeb784973dc1E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::<impl [T]>::as_chunks_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::as_chunks_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked18precondition_check17hae985b6008ba8febE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"core::slice::<impl [T]>::split_at_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::split_at_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked18precondition_check17h036498ebedbca62dE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [[usize; 4]]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h1f796214e285bd05E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 163, name: \"core::slice::<impl [T]>::align_to\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8align_to17h3f2f55440dbd3412E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is  don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 207, name: \"core::slice::<impl [T]>::align_to_offsets\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to_offsets::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16align_to_offsets17h9a870748ec74d22cE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17h78ea551bdbf9c409E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9261551842730f07E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h6fde5a5a7a6da893E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h0771b4bddc48611aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h8b631703f7d638d3E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 171, name: \"core::slice::<impl [T]>::as_chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$9as_chunks17h62f5495583e80f1aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len_rounded_down = self.len() / N * N;\n        // SAFETY: The rounded-down value is always the same or smaller than the\n        // original length, and thus must be in-bounds of the slice.\n        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 179, name: \"core::slice::<impl [T]>::as_chunks_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks_unchecked::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked17h8e9f62deb4bed8e1E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        );\n        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n        let new_len = unsafe { exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17hb16374a047362e58E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 166, name: \"core::slice::<impl [T]>::chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::chunks",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6chunks17ha09721e0e969e33aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert!(chunk_size != 0, \"chunk size must be non-zero\");\n        Chunks::new(self, chunk_size)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 164, name: \"core::slice::<impl [T]>::is_empty\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::is_empty",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8is_empty17ha518b9eb9d09acddE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9bded35725a0f34bE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h4760363bd3d8df7dE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h33e3be9e163f3d84E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h2ba5f3ee616a9de4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[[usize; 4]]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17hd4a47bd844608dd0E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[usize]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17h59a4497cf99cfe33E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hfe1187add6301ee6E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17h2ef4bb22e84c1a37E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17h8fcb935f0f5f0c0bE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::RangeTo<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h949054447ff215bbE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 102, name: \"core::str::<impl str>::len\" }",
        "func": {
          "name": "core::str::<impl str>::len",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$3len17h0efa33433be36319E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn len(&self) -> usize {\n        self.as_bytes().len()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 104, name: \"core::str::count::char_count_general_case\" }",
        "func": {
          "name": "core::str::count::char_count_general_case",
          "mangled_name": "_ZN4core3str5count23char_count_general_case17h9194c83a4785e6c0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn char_count_general_case(s: &[u8]) -> usize {\n    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::count::char_count_general_case::{closure#0}\" }",
        "func": {
          "name": "core::str::count::char_count_general_case::{closure#0}",
          "mangled_name": "_ZN4core3str5count23char_count_general_case28_$u7b$$u7b$closure$u7d$$u7d$17h394284915c90711eE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "|&&byte| !super::validations::utf8_is_cont_byte(byte)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 176, name: \"core::str::count::contains_non_continuation_byte\" }",
        "func": {
          "name": "core::str::count::contains_non_continuation_byte",
          "mangled_name": "_ZN4core3str5count30contains_non_continuation_byte17hde3d14fc61658f17E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn contains_non_continuation_byte(w: usize) -> usize {\n    const LSB: usize = usize::repeat_u8(0x01);\n    ((!w >> 7) | (w >> 6)) & LSB\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 101, name: \"core::str::count::count_chars\" }",
        "func": {
          "name": "core::str::count::count_chars",
          "mangled_name": "_ZN4core3str5count11count_chars17h438fe512170f6882E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "pub(super) fn count_chars(s: &str) -> usize {\n    if cfg!(feature = \"optimize_for_size\") || s.len() < USIZE_SIZE * UNROLL_INNER {\n        // Avoid entering the optimized implementation for strings where the\n        // difference is not likely to matter, or where it might even be slower.\n        // That said, a ton of thought was not spent on the particular threshold\n        // here, beyond \"this value seems to make sense\".\n        char_count_general_case(s.as_bytes())\n    } else {\n        do_count_chars(s)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 105, name: \"core::str::count::do_count_chars\" }",
        "func": {
          "name": "core::str::count::do_count_chars",
          "mangled_name": "_ZN4core3str5count14do_count_chars17h75afdc7e2f50899aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 175, name: \"core::str::count::sum_bytes_in_usize\" }",
        "func": {
          "name": "core::str::count::sum_bytes_in_usize",
          "mangled_name": "_ZN4core3str5count18sum_bytes_in_usize17h0fe82d38e63b1ff2E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn sum_bytes_in_usize(values: usize) -> usize {\n    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n\n    let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 266, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h3e681accfd37035aE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 268, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h9bf8221b9faf40cbE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 265, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits110_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..RangeTo$LT$usize$GT$$GT$13get_unchecked17h926389fc19e40548E",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 235, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17h49ef59a58d9bb16bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 249, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17hc891eb537972639bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 247, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17hb45ca0db55f7758bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17hd8ea0d008709b6b4E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17h6827fd98917f2969E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 146, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17h105d247d9515ffcdE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 188, name: \"core::ub_checks::is_valid_allocation_size\" }",
        "func": {
          "name": "core::ub_checks::is_valid_allocation_size",
          "mangled_name": "_ZN4core9ub_checks24is_valid_allocation_size17h90616824e065af89E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {\n    let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };\n    len <= max_len\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"core::ub_checks::maybe_is_aligned_and_not_null\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null17h1c617f69f5e4fe01E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn maybe_is_aligned_and_not_null(\n    ptr: *const (),\n    align: usize,\n    is_zst: bool,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 189, name: \"core::ub_checks::maybe_is_aligned_and_not_null::runtime\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null::runtime",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null7runtime17hc3925ab73c46a78aE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 53, name: \"kani::panic\" }",
        "func": {
          "name": "kani::panic",
          "mangled_name": "_ZN4kani5panic17h6190bada9522f78aE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn panic(message: &'static str) -> ! {\n            panic!(\"{}\", message)\n        }",
          "before_expansion": "kani_core::kani_intrinsics!(std)"
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"kani::panic::panic_cold_display\" }",
        "func": {
          "name": "kani::panic::panic_cold_display::<&str>",
          "mangled_name": "_ZN4kani5panic18panic_cold_display17h3c77492d46a89dbbE",
          "kind": "Item",
          "file": "library/core/src/panic.rs",
          "src": "const fn panic_cold_display<T: $crate::fmt::Display>(arg: &T) -> ! {\n            $crate::panicking::panic_display(arg)\n        }",
          "before_expansion": "panic!(\"{}\", message)"
        }
      },
      {
        "def_id": "DefId { id: 174, name: \"std::array::<impl std::iter::IntoIterator for &'a [T; N]>::into_iter\" }",
        "func": {
          "name": "std::array::<impl std::iter::IntoIterator for &[usize; 4]>::into_iter",
          "mangled_name": "_ZN4core5array98_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u3b$$u20$N$u5d$$GT$9into_iter17he1c19779b96d5e95E",
          "kind": "Item",
          "file": "library/core/src/array/mod.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 242, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217h79452afed33d8afaE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 240, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17hd069e3b6813f4d52E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 241, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h8dade502d8f04feeE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )"
        }
      },
      {
        "def_id": "DefId { id: 239, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h2c8c127ff9716582E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 255, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt",
          "mangled_name": "_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u16$GT$2lt17h2e1d14712d03b1a2E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 214, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt",
          "mangled_name": "_ZN4core3cmp5impls57_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$usize$GT$2lt17h551740291a2e7191E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 211, name: \"std::cmp::min\" }",
        "func": {
          "name": "std::cmp::min::<usize>",
          "mangled_name": "_ZN4core3cmp3min17hdf73c061ba7372f8E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "pub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::convert::num::<impl std::convert::From<u16> for usize>::from\" }",
        "func": {
          "name": "std::convert::num::<impl std::convert::From<u16> for usize>::from",
          "mangled_name": "_ZN4core7convert3num66_$LT$impl$u20$core..convert..From$LT$u16$GT$$u20$for$u20$usize$GT$4from17hcff1e1e2ee4568c2E",
          "kind": "Item",
          "file": "library/core/src/convert/num.rs",
          "src": "fn from(small: $Small) -> Self {\n                small as Self\n            }",
          "before_expansion": "impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        )"
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hbb45028c907195c1E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::fmt::Arguments::<'a>::new_v1\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_v1::<1, 1>",
          "mangled_name": "_ZN4core3fmt9Arguments6new_v117heaed1009cc26b388E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_v1<const P: usize, const A: usize>(\n        pieces: &'a [&'static str; P],\n        args: &'a [rt::Argument<'a>; A],\n    ) -> Arguments<'a> {\n        const { assert!(P >= A && P <= A + 1, \"invalid args\") }\n        Arguments { pieces, fmt: None, args }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 73, name: \"std::fmt::Formatter::<'a>::pad\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::pad",
          "mangled_name": "_ZN4core3fmt9Formatter3pad17he3971bd2e0830220E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front.\n        if self.options.flags & (flags::WIDTH_FLAG | flags::PRECISION_FLAG) == 0 {\n            return self.buf.write_str(s);\n        }\n\n        // The `precision` field can be interpreted as a maximum width for the\n        // string being formatted.\n        let (s, char_count) = if let Some(max_char_count) = self.options.get_precision() {\n            let mut iter = s.char_indices();\n            let remaining = match iter.advance_by(usize::from(max_char_count)) {\n                Ok(()) => 0,\n                Err(remaining) => remaining.get(),\n            };\n            // SAFETY: The offset of `.char_indices()` is guaranteed to be\n            // in-bounds and between character boundaries.\n            let truncated = unsafe { s.get_unchecked(..iter.offset()) };\n            (truncated, usize::from(max_char_count) - remaining)\n        } else {\n            // Use the optimized char counting algorithm for the full string.\n            (s, s.chars().count())\n        };\n\n        // The `width` field is more of a minimum width parameter at this point.\n        if char_count < usize::from(self.options.width) {\n            // If we're under the minimum width, then fill up the minimum width\n            // with the specified string + some alignment.\n            let post_padding =\n                self.padding(self.options.width - char_count as u16, Alignment::Left)?;\n            self.buf.write_str(s)?;\n            post_padding.write(self)\n        } else {\n            // If we're over the minimum width or there is no minimum width, we\n            // can just emit the string.\n            self.buf.write_str(s)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"std::fmt::Formatter::<'a>::padding\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::padding",
          "mangled_name": "_ZN4core3fmt9Formatter7padding17h53f9e78fb4099400E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn padding(\n        &mut self,\n        padding: u16,\n        default: Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = self.options.get_align().unwrap_or(default);\n        let fill = self.options.get_fill();\n\n        let padding_left = match align {\n            Alignment::Left => 0,\n            Alignment::Right => padding,\n            Alignment::Center => padding / 2,\n        };\n\n        for _ in 0..padding_left {\n            self.buf.write_char(fill)?;\n        }\n\n        Ok(PostPadding::new(fill, padding - padding_left))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 260, name: \"std::fmt::FormattingOptions::get_align\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_align",
          "mangled_name": "_ZN4core3fmt17FormattingOptions9get_align17h8b918746f9c015ffE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_align(&self) -> Option<Alignment> {\n        match self.flags & flags::ALIGN_BITS {\n            flags::ALIGN_LEFT => Some(Alignment::Left),\n            flags::ALIGN_RIGHT => Some(Alignment::Right),\n            flags::ALIGN_CENTER => Some(Alignment::Center),\n            _ => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 262, name: \"std::fmt::FormattingOptions::get_fill\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_fill",
          "mangled_name": "_ZN4core3fmt17FormattingOptions8get_fill17h43c04343d70b7042E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_fill(&self) -> char {\n        // SAFETY: We only ever put a valid `char` in the lower 21 bits of the flags field.\n        unsafe { char::from_u32_unchecked(self.flags & 0x1FFFFF) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 78, name: \"std::fmt::FormattingOptions::get_precision\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_precision",
          "mangled_name": "_ZN4core3fmt17FormattingOptions13get_precision17hbd80eaff3d1888beE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_precision(&self) -> Option<u16> {\n        if self.flags & flags::PRECISION_FLAG != 0 { Some(self.precision) } else { None }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 250, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17hb85c714223239900E",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 251, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17haa76a7dc7c6e5497E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )"
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17he733dcfdc3261fb2E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 165, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17hed6aa9940a66cedcE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 157, name: \"std::iter::Filter::<I, P>::new\" }",
        "func": {
          "name": "std::iter::Filter::<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters6filter19Filter$LT$I$C$P$GT$3new17hc34a2f01600b7b29E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n        Filter { iter, predicate }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::iter::Map::<I, F>::new\" }",
        "func": {
          "name": "std::iter::Map::<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters3map16Map$LT$I$C$F$GT$3new17h53f0d55450f62c1dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n        Map { iter, f }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"std::iter::adapters::map::map_fold\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold17hfb84ea7d0fb8cbffE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn map_fold<T, B, Acc>(\n    mut f: impl FnMut(T) -> B,\n    mut g: impl FnMut(Acc, B) -> Acc,\n) -> impl FnMut(Acc, T) -> Acc {\n    move |acc, elt| g(acc, f(elt))\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::iter::adapters::map::map_fold::{closure#0}\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold28_$u7b$$u7b$closure$u7d$$u7d$17hb3e453f99d84d8bfE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "move |acc, elt| g(acc, f(elt))",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<u16>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17h07bdeaaf39b8685aE",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<usize>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hd27f508ace781eb9E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem8align_of17h4ccf9d5c0139d079E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<u8>",
          "mangled_name": "_ZN4core3mem8align_of17hcf7fa5208d41c27fE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<usize>",
          "mangled_name": "_ZN4core3mem8align_of17h512cbae0980bb36dE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem7size_of17h0553276df7ba24c2E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17hd68b5fd240b661c5E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<usize>",
          "mangled_name": "_ZN4core3mem7size_of17hd5b2a7cccbb61ceeE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 231, name: \"std::num::NonZero::<T>::new_unchecked::precondition_check\" }",
        "func": {
          "name": "std::num::NonZero::<T>::new_unchecked::precondition_check",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked18precondition_check17h0116c509d606ce2cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    )"
        }
      },
      {
        "def_id": "DefId { id: 84, name: \"std::num::NonZero::<T>::get\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::get",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3get17h87da58b24eb8904aE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn get(self) -> T {\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // Using the transmute `assume`s the range at runtime.\n        //\n        // Even once LLVM supports `!range` metadata for function arguments\n        // (see <https://github.com/llvm/llvm-project/issues/76628>), this can't\n        // be `.0` because MCP#807 bans field-projecting into `scalar_valid_range`\n        // types, and it arguably wouldn't want to be anyway because if this is\n        // MIR-inlined, there's no opportunity to put that argument metadata anywhere.\n        //\n        // The good answer here will eventually be pattern types, which will hopefully\n        // allow it to go back to `.0`, maybe with a cast of some sort.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 230, name: \"std::num::NonZero::<T>::new\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3new17h3cbc7a205e50ad1fE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn new(n: T) -> Option<Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        unsafe { intrinsics::transmute_unchecked(n) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 224, name: \"std::num::NonZero::<T>::new_unchecked\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new_unchecked",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked17hd3e157914eb40be4E",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 248, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17hd4ca9a9271618328E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 223, name: \"std::option::Option::<T>::is_none\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_none",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_none17hd6afafc489127163E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 225, name: \"std::option::Option::<T>::is_some\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_some",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_some17ha5fa074a52234010E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 261, name: \"std::option::Option::<T>::unwrap_or\" }",
        "func": {
          "name": "std::option::Option::<std::fmt::Alignment>::unwrap_or",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$9unwrap_or17h93449fbe40562582E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 236, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h4766a44e449f5bc0E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17h7028f0eba4c7a6f8E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he78cf8b05978fd0dE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::cast::<()>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hdc66bbbf9ca09606E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h521f17b23745bac9E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h8842d827e238f628E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h7751fb8567cbcb47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h9de03001895d0df8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h79cc454782b590c1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h4c90e7777850aeebE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h7dafd8edeaef92caE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17hc9f5a770b3d720c7E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hbab76e706044fa2eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h7c6d9cb10df2c094E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h04f77dd0bbba90e3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hd35b6c11a62aafd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h40068346434d50f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h8e78528254286707E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7757583d8ce29180E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h54ad99e807176d15E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h4637137071b370dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h157e6a6f791a927eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he7774680d992b871E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17he3b1371588b0fd61E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 205, name: \"std::ptr::align_offset\" }",
        "func": {
          "name": "std::ptr::align_offset::<u8>",
          "mangled_name": "_ZN4core3ptr12align_offset17hc37ffd11ea4851baE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n    // 1, where the method versions of these operations are not inlined.\n    use intrinsics::{\n        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n    };\n\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for `align_offset` and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x < m`; (if `x  m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }\n\n    let stride = size_of::<T>();\n\n    let addr: usize = p.addr();\n\n    // SAFETY: `a` is a power-of-two, therefore non-zero.\n    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n\n    if stride == 0 {\n        // SPECIAL_CASE: handle 0-sized types. No matter how many times we step, the address will\n        // stay the same, so no offset will be able to align the pointer unless it is already\n        // aligned. This branch _will_ be optimized out as `stride` is known at compile-time.\n        let p_mod_a = addr & a_minus_one;\n        return if p_mod_a == 0 { 0 } else { usize::MAX };\n    }\n\n    // SAFETY: `stride == 0` case has been handled by the special case above.\n    let a_mod_stride = unsafe { unchecked_rem(a, stride) };\n    if a_mod_stride == 0 {\n        // SPECIAL_CASE: In cases where the `a` is divisible by `stride`, byte offset to align a\n        // pointer can be computed more simply through `-p (mod a)`. In the off-chance the byte\n        // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n        // offset will be able to produce a `p` aligned to the specified `a`.\n        //\n        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n        // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n        // redistributes operations around the load-bearing, but pessimizing `and` instruction\n        // sufficiently for LLVM to be able to utilize the various optimizations it knows about.\n        //\n        // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated\n        // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`\n        // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n        // computation produces.\n\n        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n        let byte_offset = wrapping_sub(aligned_address, addr);\n        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n        // the value by more than `a-1`, so even though the intermediate values might have\n        // wrapped, the byte_offset is always in `[0, a)`.\n        unsafe { assume(byte_offset < a) };\n\n        // SAFETY: `stride == 0` case has been handled by the special case above.\n        let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n\n        return if addr_mod_stride == 0 {\n            // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n            // addr has been verified to be aligned to the original types alignment requirements.\n            unsafe { exact_div(byte_offset, stride) }\n        } else {\n            usize::MAX\n        };\n    }\n\n    // GENERAL_CASE: From here on were handling the very general case where `addr` may be\n    // misaligned, there isnt an obvious relationship between `stride` and `a` that we can take an\n    // advantage of, etc. This case produces machine code that isnt particularly high quality,\n    // compared to the special cases above. The code produced here is still within the realm of\n    // miracles, given the situations this case has to deal with.\n\n    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n    // FIXME(const-hack) replace with min\n    let gcdpow = unsafe {\n        let x = cttz_nonzero(stride);\n        let y = cttz_nonzero(a);\n        if x < y { x } else { y }\n    };\n    // SAFETY: gcdpow has an upper-bound thats at most the number of bits in a `usize`.\n    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n    // SAFETY: gcd is always greater or equal to 1.\n    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the\n        // second term is \"how does incrementing `p` by `s` bytes change the relative alignment of\n        // `p`\" (again divided by `g`). Division by `g` is necessary to make the inverse well\n        // formed if `a` and `s` are not co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. This `lcm(s, a)` is the same as `a'`.\n\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n        // in `a` (of which it has exactly one).\n        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let s2 = unsafe { unchecked_shr(stride & a_minus_one, gcdpow) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n        // always be strictly greater than `(p % a) >> gcdpow`.\n        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(addr & a_minus_one, gcdpow)) };\n        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::MAX\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 209, name: \"std::ptr::align_offset::mod_inv\" }",
        "func": {
          "name": "std::ptr::align_offset::mod_inv",
          "mangled_name": "_ZN4core3ptr12align_offset7mod_inv17h4226b9d4d3d5c672E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3e62dd7746f386b1E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h94920da9c4e41356E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::const_ptr::<impl *const T>::is_aligned_to\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_aligned_to",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$13is_aligned_to17hbaf8f80ac8bd74b5E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn is_aligned_to(self, align: usize) -> bool {\n        if !align.is_power_of_two() {\n            panic!(\"is_aligned_to: align is not a power-of-two\");\n        }\n\n        self.addr() & (align - 1) == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"std::ptr::const_ptr::<impl *const T>::is_null\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_null",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h39f2cba5693cfcbaE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"std::ptr::const_ptr::<impl *const T>::is_null::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::is_null::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null7runtime17h7dfd407882faecc4E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 149, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17h576dc75a826a2d0cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 153, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h347785d8fcffea35E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17h2d71e26de06a9244E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 269, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h4407a3d2505e3182E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 267, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h77a9a38a2fb82cebE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3a596104eca7202bE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h95babdad2d0fc1f3E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h0a576779c2a5921cE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h9d8ea600d403e2a7E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hea3399653658e906E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 148, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h7e1ae8494ab1b6a8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17hcedf28e570bccab6E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17hee8e32507ad62195E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb6d9630c236e0667E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hd7d033da755485feE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<&u8>",
          "mangled_name": "_ZN4core3ptr27drop_in_place$LT$$RF$u8$GT$17hc860db9297e59a65E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::fmt::Alignment>",
          "mangled_name": "_ZN4core3ptr41drop_in_place$LT$core..fmt..Alignment$GT$17h7053c6d7e77848ceE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::option::Option<(usize, char)>>",
          "mangled_name": "_ZN4core3ptr69drop_in_place$LT$core..option..Option$LT$$LP$usize$C$char$RP$$GT$$GT$17hc4a9cf5ac18a109aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<usize>",
          "mangled_name": "_ZN4core3ptr26drop_in_place$LT$usize$GT$17hc9921d2585312b1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17he2f3566df11993a9E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr772drop_in_place$LT$core..iter..adapters..map..map_fold$LT$$RF$u8$C$usize$C$usize$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$C$$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$..sum$LT$core..iter..adapters..map..Map$LT$core..slice..iter..Iter$LT$u8$GT$$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h6e7832b57095f296E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h07a46ae8aa7e8e25E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h12719edfe5decc4eE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h47876d82be15ca1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h7b125f91dbc5ce35E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[[usize; 4]], [usize; 4]>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h366ed0a3a51d837eE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17hcbff0ea135f8c822E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[usize], usize>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h41eed9c7257b5a92E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 270, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h11e9b84f3b318493E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h9e0e2cfdf0904a7fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hf944f5073ef59a74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hce2dbc0a8530746fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h8a05fb28e37fbdd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 147, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17he8e6f7cbdd8f5e6eE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h058663281978a159E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h950a6db1729acb74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hdf15e8368e89c131E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h9b6c1ed71e4b6c54E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<usize>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h0392b72387600f22E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h6ba60a2281e8a542E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h7b2fb807837541dbE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<usize>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h953360cfbc2e7273E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17he0272cf1811aedffE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hc02bc4ce2e57232fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<usize>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17h3353948db1931310E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 243, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h237867c19800b78bE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_display\" }",
        "func": {
          "name": "std::rt::panic_display::<&str>",
          "mangled_name": "_ZN4core9panicking13panic_display17h9965c83dbdce9711E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n    panic_fmt(format_args!(\"{}\", *x));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17h8206d9c4fa94b0f1E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 204, name: \"std::slice::Chunks::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Chunks::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter15Chunks$LT$T$GT$3new17h61fc0016bb33d3a4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, [usize; 4]>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h7e563fa4aafeccbeE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 217, name: \"std::slice::Iter::<'a, T>::as_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::as_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$8as_slice17h5dbeb8b275b939f1E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 219, name: \"std::slice::Iter::<'a, T>::make_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::make_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$10make_slice17h65c3cdc1b15790e4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h9fd511ca042ff46dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hf5d3176cdb446f8dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, [usize; 4]>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb0c08e21a67d8321E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, u8>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17h20fd2a93730b1004E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, usize>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb415c774c30ce8d9E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 185, name: \"std::slice::from_raw_parts::precondition_check\" }",
        "func": {
          "name": "std::slice::from_raw_parts::precondition_check",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts18precondition_check17hf1448faea35264c6E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"std::str::CharIndices::<'a>::offset\" }",
        "func": {
          "name": "std::str::CharIndices::<'_>::offset",
          "mangled_name": "_ZN4core3str4iter11CharIndices6offset17h55d0a25e76f5da95E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 100, name: \"std::str::Chars::<'a>::as_str\" }",
        "func": {
          "name": "std::str::Chars::<'_>::as_str",
          "mangled_name": "_ZN4core3str4iter5Chars6as_str17hf072d8c9a8bc6de2E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn as_str(&self) -> &'a str {\n        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 218, name: \"std::str::from_utf8_unchecked\" }",
        "func": {
          "name": "std::str::from_utf8_unchecked",
          "mangled_name": "_ZN4core3str8converts19from_utf8_unchecked17hd68ebd84e1b684d4E",
          "kind": "Item",
          "file": "library/core/src/str/converts.rs",
          "src": "pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n    // Also relies on `&str` and `&[u8]` having the same layout.\n    unsafe { mem::transmute(v) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 14, name: \"verify::contract_ensures\" }",
        "func": {
          "name": "verify::contract_ensures",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures17h79653182b146dd52E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 16, name: \"verify::contract_ensures::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract_ensures::kani_contract_mode",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures18kani_contract_mode17hf84fd0bf7e84f561E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17h16b586d379912749E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17h231f8ea1cc3c8c63E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17hacc71d9312a7ae0aE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17hbb6ad307037018a6E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      }
    ]
  },
  {
    "hash": "32008825021530252912479679579491149867",
    "def_id": "DefId { id: 33, name: \"verify::two_contracts_requires_and_ensures\" }",
    "attrs": [
      "#[kanitool::proof]"
    ],
    "func": {
      "name": "verify::two_contracts_requires_and_ensures",
      "mangled_name": "_ZN30standard_proofs_with_contracts6verify34two_contracts_requires_and_ensures17h489c80ab91e2c2beE",
      "kind": "Item",
      "file": "tests/proofs/standard_proofs_with_contracts.rs",
      "src": "fn two_contracts_requires_and_ensures() {\n        let val = contract_ensures(0);\n        contract_requires(val);\n    }",
      "before_expansion": null
    },
    "callees_len": 259,
    "callees": [
      {
        "def_id": "DefId { id: 64, name: \"<&T as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<&str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN44_$LT$$RF$T$u20$as$u20$core..fmt..Display$GT$3fmt17h410ed86c60f5cfc3E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result { $tr::fmt(&**self, f) }",
          "before_expansion": "fmt_refs! { Debug, Display, Octal, Binary, LowerHex, UpperHex, LowerExp, UpperExp }"
        }
      },
      {
        "def_id": "DefId { id: 254, name: \"<T as std::convert::From<T>>::from\" }",
        "func": {
          "name": "<std::fmt::Error as std::convert::From<std::fmt::Error>>::from",
          "mangled_name": "_ZN50_$LT$T$u20$as$u20$core..convert..From$LT$T$GT$$GT$4from17he83ac1a1ecfe098bE",
          "kind": "Item",
          "file": "library/core/src/convert/mod.rs",
          "src": "fn from(t: T) -> T {\n        t\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 112, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize17hefafed2dd7e7b23dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 116, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::{closure#0}\" }",
        "func": {
          "name": "<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize::<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count8to_usize28_$u7b$$u7b$closure$u7d$$u7d$17h58b8e91647087575E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "move |x| predicate(&x) as usize",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 108, name: \"<std::iter::Filter<I, P> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::iter::Filter<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}> as std::iter::Iterator>::count",
          "mangled_name": "_ZN108_$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17h3699bd088ef32d8bE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "fn count(self) -> usize {\n        #[inline]\n        fn to_usize<T>(mut predicate: impl FnMut(&T) -> bool) -> impl FnMut(T) -> usize {\n            move |x| predicate(&x) as usize\n        }\n\n        self.iter.map(to_usize(self.predicate)).sum()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 121, name: \"<std::iter::Map<I, F> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::fold::<usize, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN102_$LT$core..iter..adapters..map..Map$LT$I$C$F$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h6d92003bf13c783fE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn fold<Acc, G>(self, init: Acc, g: G) -> Acc\n    where\n        G: FnMut(Acc, Self::Item) -> Acc,\n    {\n        self.iter.fold(init, map_fold(self.f, g))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 114, name: \"std::iter::Iterator::sum\" }",
        "func": {
          "name": "<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}> as std::iter::Iterator>::sum::<usize>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3sum17h7d40d1f308b1005dE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn sum<S>(self) -> S\n    where\n        Self: Sized,\n        S: Sum<Self::Item>,\n    {\n        Sum::sum(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h7c9a54f8524b49a7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<u16> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17hce7831b5e86d6af1E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h9c1f64b07716f02eE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 227, name: \"<std::ops::Range<T> as std::iter::range::RangeIteratorImpl>::spec_next\" }",
        "func": {
          "name": "<std::ops::Range<usize> as std::iter::range::RangeIteratorImpl>::spec_next",
          "mangled_name": "_ZN89_$LT$core..ops..range..Range$LT$T$GT$$u20$as$u20$core..iter..range..RangeIteratorImpl$GT$9spec_next17h2e2ab1a72ff80731E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn spec_next(&mut self) -> Option<T> {\n        if self.start < self.end {\n            let old = self.start;\n            // SAFETY: just checked precondition\n            self.start = unsafe { Step::forward_unchecked(old, 1) };\n            Some(old)\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 245, name: \"<std::option::Option<T> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::option::Option<&u8> as std::ops::Try>::branch",
          "mangled_name": "_ZN75_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17h07c3e6fc52b3fedeE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Some(v) => ControlFlow::Continue(v),\n            None => ControlFlow::Break(None),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 246, name: \"<std::option::Option<T> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual\" }",
        "func": {
          "name": "<std::option::Option<u32> as std::ops::FromResidual<std::option::Option<std::convert::Infallible>>>::from_residual",
          "mangled_name": "_ZN145_$LT$core..option..Option$LT$T$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..option..Option$LT$core..convert..Infallible$GT$$GT$$GT$13from_residual17h99f2f0e144b0be9fE",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "fn from_residual(residual: Option<convert::Infallible>) -> Self {\n        match residual {\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[[usize; 4]]> as std::convert::From<&[[usize; 4]]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hf2bfe9aa01cc2a5cE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[u8]> as std::convert::From<&[u8]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17ha2f234dc854092f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize; 4]> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h9d329a2fb5d239cdE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 159, name: \"<std::ptr::NonNull<T> as std::convert::From<&T>>::from\" }",
        "func": {
          "name": "<std::ptr::NonNull<[usize]> as std::convert::From<&[usize]>>::from",
          "mangled_name": "_ZN90_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..convert..From$LT$$RF$T$GT$$GT$4from17hda64db96e84d2849E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn from(r: &T) -> Self {\n        NonNull::from_ref(r)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<u8> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h7c7ff8009b034788E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 128, name: \"<std::ptr::NonNull<T> as std::cmp::PartialEq>::eq\" }",
        "func": {
          "name": "<std::ptr::NonNull<usize> as std::cmp::PartialEq>::eq",
          "mangled_name": "_ZN78_$LT$core..ptr..non_null..NonNull$LT$T$GT$$u20$as$u20$core..cmp..PartialEq$GT$2eq17h626a1d09fbfa6da4E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "fn eq(&self, other: &Self) -> bool {\n        self.as_ptr() == other.as_ptr()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hc061659ac6d49be8E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<(), std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hb63dc43fb3b8efe3E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 95, name: \"<std::result::Result<T, F> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, E>>>::from_residual\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::FromResidual<std::result::Result<std::convert::Infallible, std::fmt::Error>>>::from_residual",
          "mangled_name": "_ZN153_$LT$core..result..Result$LT$T$C$F$GT$$u20$as$u20$core..ops..try_trait..FromResidual$LT$core..result..Result$LT$core..convert..Infallible$C$E$GT$$GT$$GT$13from_residual17hbf3169bb7998e829E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn from_residual(residual: Result<convert::Infallible, E>) -> Self {\n        match residual {\n            Err(e) => Err(From::from(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 92, name: \"<std::result::Result<T, E> as std::ops::Try>::branch\" }",
        "func": {
          "name": "<std::result::Result<core::fmt::PostPadding, std::fmt::Error> as std::ops::Try>::branch",
          "mangled_name": "_ZN79_$LT$core..result..Result$LT$T$C$E$GT$$u20$as$u20$core..ops..try_trait..Try$GT$6branch17hf0fbb1a129a09e75E",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "fn branch(self) -> ControlFlow<Self::Residual, Self::Output> {\n        match self {\n            Ok(v) => ControlFlow::Continue(v),\n            Err(e) => ControlFlow::Break(Err(e)),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 168, name: \"<I as std::iter::IntoIterator>::into_iter\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::IntoIterator>::into_iter",
          "mangled_name": "_ZN63_$LT$I$u20$as$u20$core..iter..traits..collect..IntoIterator$GT$9into_iter17h962da7a65ee8c669E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/collect.rs",
          "src": "fn into_iter(self) -> I {\n        self\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 170, name: \"<std::slice::Chunks<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Chunks<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN93_$LT$core..slice..iter..Chunks$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h28c7ddf67bd014beE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn next(&mut self) -> Option<&'a [T]> {\n        if self.v.is_empty() {\n            None\n        } else {\n            let chunksz = cmp::min(self.v.len(), self.chunk_size);\n            let (fst, snd) = self.v.split_at(chunksz);\n            self.v = snd;\n            Some(fst)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, [usize; 4]> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h0b79c4e6d4c47667E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 233, name: \"<std::slice::Iter<'_, T> as std::iter::ExactSizeIterator>::len\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::ExactSizeIterator>::len",
          "mangled_name": "_ZN102_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..exact_size..ExactSizeIterator$GT$3len17hcb764b037493d54cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn len(&self) -> usize {\n                len!(self)\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 107, name: \"std::iter::Iterator::filter\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::filter::<{closure@core::str::count::char_count_general_case::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator6filter17h89d9720e37de1568E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn filter<P>(self, predicate: P) -> Filter<Self, P>\n    where\n        Self: Sized,\n        P: FnMut(&Self::Item) -> bool,\n    {\n        Filter::new(self, predicate)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 123, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::fold\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::fold::<usize, {closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4fold17h29ba2c4b195065b9E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn fold<B, F>(self, init: B, mut f: F) -> B\n                where\n                    F: FnMut(B, Self::Item) -> B,\n            {\n                // this implementation consists of the following optimizations compared to the\n                // default implementation:\n                // - do-while loop, as is llvm's preferred loop shape,\n                //   see https://releases.llvm.org/16.0.0/docs/LoopTerminology.html#more-canonical-loops\n                // - bumps an index instead of a pointer since the latter case inhibits\n                //   some optimizations, see #111603\n                // - avoids Option wrapping/matching\n                if is_empty!(self) {\n                    return init;\n                }\n                let mut acc = init;\n                let mut i = 0;\n                let len = len!(self);\n                loop {\n                    // SAFETY: the loop iterates `i in 0..len`, which always is in bounds of\n                    // the slice allocation\n                    acc = f(acc, unsafe { & $( $mut_ )? *self.ptr.add(i).as_ptr() });\n                    // SAFETY: `i` can't overflow since it'll only reach usize::MAX if the\n                    // slice had that length, in which case we'll break out of the loop\n                    // after the increment\n                    i = unsafe { i.unchecked_add(1) };\n                    if i == len {\n                        break;\n                    }\n                }\n                acc\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 113, name: \"std::iter::Iterator::map\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::map::<usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator3map17hbfc9ceba84a749aeE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn map<B, F>(self, f: F) -> Map<Self, F>\n    where\n        Self: Sized,\n        F: FnMut(Self::Item) -> B,\n    {\n        Map::new(self, f)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, u8> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hfadf3ba7fbb0614cE",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 173, name: \"<std::slice::Iter<'a, T> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::slice::Iter<'_, usize> as std::iter::Iterator>::next",
          "mangled_name": "_ZN91_$LT$core..slice..iter..Iter$LT$T$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17hae10bd58ec770fd8E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn next(&mut self) -> Option<$elem> {\n                // intentionally not using the helpers because this is\n                // one of the most mono'd things in the library.\n\n                let ptr = self.ptr;\n                let end_or_len = self.end_or_len;\n                // SAFETY: See inner comments. (For some reason having multiple\n                // block breaks inlining this -- if you can fix that please do!)\n                unsafe {\n                    if T::IS_ZST {\n                        let len = end_or_len.addr();\n                        if len == 0 {\n                            return None;\n                        }\n                        // SAFETY: just checked that it's not zero, so subtracting one\n                        // cannot wrap.  (Ideally this would be `checked_sub`, which\n                        // does the same thing internally, but as of 2025-02 that\n                        // doesn't optimize quite as small in MIR.)\n                        self.end_or_len = without_provenance_mut(len.unchecked_sub(1));\n                    } else {\n                        // SAFETY: by type invariant, the `end_or_len` field is always\n                        // non-null for a non-ZST pointee.  (This transmute ensures we\n                        // get `!nonnull` metadata on the load of the field.)\n                        if ptr == crate::intrinsics::transmute::<$ptr, NonNull<T>>(end_or_len) {\n                            return None;\n                        }\n                        // SAFETY: since it's not empty, per the check above, moving\n                        // forward one keeps us inside the slice, and this is valid.\n                        self.ptr = ptr.add(1);\n                    }\n                    // SAFETY: Now that we know it wasn't empty and we've moved past\n                    // the first one (to avoid giving a duplicate `&mut` next time),\n                    // we can give out a reference to it.\n                    Some({ptr}.$into_ref())\n                }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 82, name: \"std::iter::Iterator::advance_by\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::advance_by",
          "mangled_name": "_ZN4core4iter6traits8iterator8Iterator10advance_by17h0040525bd95241f2E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/iterator.rs",
          "src": "fn advance_by(&mut self, n: usize) -> Result<(), NonZero<usize>> {\n        for i in 0..n {\n            if self.next().is_none() {\n                // SAFETY: `i` is always less than `n`.\n                return Err(unsafe { NonZero::new_unchecked(n - i) });\n            }\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 222, name: \"<std::str::CharIndices<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::CharIndices<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN87_$LT$core..str..iter..CharIndices$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h86991728206f71e4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<(usize, char)> {\n        let pre_len = self.iter.iter.len();\n        match self.iter.next() {\n            None => None,\n            Some(ch) => {\n                let index = self.front_offset;\n                let len = self.iter.iter.len();\n                self.front_offset += pre_len - len;\n                Some((index, ch))\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 89, name: \"<std::str::Chars<'a> as std::iter::Iterator>::count\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::count",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$5count17hd17d710ff4eee22cE",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn count(self) -> usize {\n        super::count::count_chars(self.as_str())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 234, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next17h5b0d866ec2d0f5f4E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "fn next(&mut self) -> Option<char> {\n        // SAFETY: `str` invariant says `self.iter` is a valid UTF-8 string and\n        // the resulting `ch` is a valid Unicode Scalar Value.\n        unsafe { next_code_point(&mut self.iter).map(|ch| char::from_u32_unchecked(ch)) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 238, name: \"<std::str::Chars<'a> as std::iter::Iterator>::next::{closure#0}\" }",
        "func": {
          "name": "<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}",
          "mangled_name": "_ZN81_$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$4next28_$u7b$$u7b$closure$u7d$$u7d$17hcd9a1b225c5bc517E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "|ch| char::from_u32_unchecked(ch)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 71, name: \"<str as std::fmt::Display>::fmt\" }",
        "func": {
          "name": "<str as std::fmt::Display>::fmt",
          "mangled_name": "_ZN42_$LT$str$u20$as$u20$core..fmt..Display$GT$3fmt17h2e4773966404a9e8E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn fmt(&self, f: &mut Formatter<'_>) -> Result {\n        f.pad(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 256, name: \"<u16 as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<u16 as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN47_$LT$u16$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17hf1a4da89e7daa5f0E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 212, name: \"std::cmp::Ord::min\" }",
        "func": {
          "name": "<usize as std::cmp::Ord>::min",
          "mangled_name": "_ZN4core3cmp3Ord3min17hca8e35334025e720E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn min(self, other: Self) -> Self\n    where\n        Self: Sized,\n    {\n        if other < self { other } else { self }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 229, name: \"<usize as std::iter::Step>::forward_unchecked\" }",
        "func": {
          "name": "<usize as std::iter::Step>::forward_unchecked",
          "mangled_name": "_ZN49_$LT$usize$u20$as$u20$core..iter..range..Step$GT$17forward_unchecked17ha98665aa01e86e87E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "unsafe fn forward_unchecked(start: Self, n: usize) -> Self {\n            // SAFETY: the caller has to guarantee that `start + n` doesn't overflow.\n            unsafe { start.unchecked_add(n as Self) }\n        }",
          "before_expansion": "step_unsigned_methods!()"
        }
      },
      {
        "def_id": "DefId { id: 119, name: \"<usize as std::iter::Sum>::sum\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum17hd4899a4f1283f91cE",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "fn sum<I: Iterator<Item=Self>>(iter: I) -> Self {\n                iter.fold(\n                    $zero,\n                    #[rustc_inherit_overflow_checks]\n                    |a, b| a + b,\n                )\n            }",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 124, name: \"<usize as std::iter::Sum>::sum::{closure#0}\" }",
        "func": {
          "name": "<usize as std::iter::Sum>::sum::<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}",
          "mangled_name": "_ZN56_$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$3sum28_$u7b$$u7b$closure$u7d$$u7d$17hf553ffa479b229d7E",
          "kind": "Item",
          "file": "library/core/src/iter/traits/accum.rs",
          "src": "|a, b| a + b",
          "before_expansion": "integer_sum_product!(@impls 0, 1,\n                #[stable(feature = \"iter_arith_traits\", since = \"1.12.0\")],\n                $($a)*)"
        }
      },
      {
        "def_id": "DefId { id: 263, name: \"core::fmt::PostPadding::new\" }",
        "func": {
          "name": "core::fmt::PostPadding::new",
          "mangled_name": "_ZN4core3fmt11PostPadding3new17h635173abc89c1c46E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "fn new(fill: char, padding: u16) -> PostPadding {\n        PostPadding { fill, padding }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 96, name: \"core::fmt::PostPadding::write\" }",
        "func": {
          "name": "core::fmt::PostPadding::write",
          "mangled_name": "_ZN4core3fmt11PostPadding5write17he27432ff58f0176fE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn write(self, f: &mut Formatter<'_>) -> Result {\n        for _ in 0..self.padding {\n            f.buf.write_char(self.fill)?;\n        }\n        Ok(())\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 65, name: \"core::fmt::rt::Argument::<'_>::new\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument3new17hc43cfa4d4cc7eeb3E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "const fn new<'a, T>(x: &'a T, f: fn(&T, &mut Formatter<'_>) -> Result) -> Argument<'a> {\n        Argument {\n            // INVARIANT: this creates an `ArgumentType<'a>` from a `&'a T` and\n            // a `fn(&T, ...)`, so the invariant is maintained.\n            ty: ArgumentType::Placeholder {\n                value: NonNull::from_ref(x).cast(),\n                // SAFETY: function pointers always have the same layout.\n                formatter: unsafe { mem::transmute(f) },\n                _lifetime: PhantomData,\n            },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 57, name: \"core::fmt::rt::Argument::<'_>::new_display\" }",
        "func": {
          "name": "core::fmt::rt::Argument::<'_>::new_display::<&str>",
          "mangled_name": "_ZN4core3fmt2rt8Argument11new_display17h2abb0f96064d56d7E",
          "kind": "Item",
          "file": "library/core/src/fmt/rt.rs",
          "src": "pub fn new_display<T: Display>(x: &T) -> Argument<'_> {\n        Self::new(x, Display::fmt)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 259, name: \"core::num::<impl u16>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl u16>::overflowing_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$15overflowing_add17h711f2c8f6e02c5aaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 257, name: \"core::num::<impl u16>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add17hec98168318b5d827E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = u16,\n        ActualT = u16,\n        SignedT = i16,\n        BITS = 16,\n        BITS_MINUS_ONE = 15,\n        MAX = 65535,\n        rot = 4,\n        rot_op = \"0xa003\",\n        rot_result = \"0x3a\",\n        swap_op = \"0x1234\",\n        swapped = \"0x3412\",\n        reversed = \"0x2c48\",\n        le_bytes = \"[0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 258, name: \"core::num::<impl u16>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl u16>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u16$GT$13unchecked_add18precondition_check17h9d272714b118328cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 244, name: \"core::num::<impl u32>::wrapping_sub\" }",
        "func": {
          "name": "core::num::<impl u32>::wrapping_sub",
          "mangled_name": "_ZN4core3num21_$LT$impl$u20$u32$GT$12wrapping_sub17h036191e61598aedaE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_sub(self, rhs: Self) -> Self {\n            intrinsics::wrapping_sub(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = u32,\n        ActualT = u32,\n        SignedT = i32,\n        BITS = 32,\n        BITS_MINUS_ONE = 31,\n        MAX = 4294967295,\n        rot = 8,\n        rot_op = \"0x10000b3\",\n        rot_result = \"0xb301\",\n        swap_op = \"0x12345678\",\n        swapped = \"0x78563412\",\n        reversed = \"0x1e6a2c48\",\n        le_bytes = \"[0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78]\",\n        to_xe_bytes_doc = \"\",\n        from_xe_bytes_doc = \"\",\n        bound_condition = \"\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 193, name: \"core::num::<impl usize>::count_ones\" }",
        "func": {
          "name": "core::num::<impl usize>::count_ones",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$10count_ones17h5848180a66ff35a5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn count_ones(self) -> u32 {\n            return intrinsics::ctpop(self);\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 192, name: \"core::num::<impl usize>::is_power_of_two\" }",
        "func": {
          "name": "core::num::<impl usize>::is_power_of_two",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15is_power_of_two17h25612661704e08b9E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn is_power_of_two(self) -> bool {\n            self.count_ones() == 1\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 136, name: \"core::num::<impl usize>::overflowing_add\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_add17hae858b6d0d0dc624E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 203, name: \"core::num::<impl usize>::overflowing_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::overflowing_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$15overflowing_sub17ha23631731d5dc26cE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n            let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n            (a as Self, b)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 132, name: \"core::num::<impl usize>::unchecked_add\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add17hc42a707166fea5e5E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_add(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_add(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 135, name: \"core::num::<impl usize>::unchecked_add::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_add::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_add18precondition_check17h463cf773999eaa82E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_add cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_add(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 199, name: \"core::num::<impl usize>::unchecked_sub\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub17h118193beb20e1102E",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const unsafe fn unchecked_sub(self, rhs: Self) -> Self {\n            assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            );\n\n            // SAFETY: this is guaranteed to be safe by the caller.\n            unsafe {\n                intrinsics::unchecked_sub(self, rhs)\n            }\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 202, name: \"core::num::<impl usize>::unchecked_sub::precondition_check\" }",
        "func": {
          "name": "core::num::<impl usize>::unchecked_sub::precondition_check",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$13unchecked_sub18precondition_check17hc50a9a68f99e942bE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n                check_language_ub,\n                concat!(stringify!($SelfT), \"::unchecked_sub cannot overflow\"),\n                (\n                    lhs: $SelfT = self,\n                    rhs: $SelfT = rhs,\n                ) => !lhs.overflowing_sub(rhs).1,\n            )"
        }
      },
      {
        "def_id": "DefId { id: 215, name: \"core::num::<impl usize>::wrapping_mul\" }",
        "func": {
          "name": "core::num::<impl usize>::wrapping_mul",
          "mangled_name": "_ZN4core3num23_$LT$impl$u20$usize$GT$12wrapping_mul17h0d4deee3af61861dE",
          "kind": "Item",
          "file": "library/core/src/num/uint_macros.rs",
          "src": "pub const fn wrapping_mul(self, rhs: Self) -> Self {\n            intrinsics::wrapping_mul(self, rhs)\n        }",
          "before_expansion": "uint_impl! {\n        Self = usize,\n        ActualT = u64,\n        SignedT = isize,\n        BITS = 64,\n        BITS_MINUS_ONE = 63,\n        MAX = 18446744073709551615,\n        rot = 12,\n        rot_op = \"0xaa00000000006e1\",\n        rot_result = \"0x6e10aa\",\n        swap_op = \"0x1234567890123456\",\n        swapped = \"0x5634129078563412\",\n        reversed = \"0x6a2c48091e6a2c48\",\n        le_bytes = \"[0x56, 0x34, 0x12, 0x90, 0x78, 0x56, 0x34, 0x12]\",\n        be_bytes = \"[0x12, 0x34, 0x56, 0x78, 0x90, 0x12, 0x34, 0x56]\",\n        to_xe_bytes_doc = usize_isize_to_xe_bytes_doc!(),\n        from_xe_bytes_doc = usize_isize_from_xe_bytes_doc!(),\n        bound_condition = \" on 64-bit targets\",\n    }"
        }
      },
      {
        "def_id": "DefId { id: 142, name: \"core::panic::panic_info::PanicInfo::<'a>::new\" }",
        "func": {
          "name": "core::panic::panic_info::PanicInfo::<'_>::new",
          "mangled_name": "_ZN4core5panic10panic_info9PanicInfo3new17h8572d23834841ad0E",
          "kind": "Item",
          "file": "library/core/src/panic/panic_info.rs",
          "src": "pub(crate) fn new(\n        message: &'a fmt::Arguments<'a>,\n        location: &'a Location<'a>,\n        can_unwind: bool,\n        force_no_backtrace: bool,\n    ) -> Self {\n        PanicInfo { location, message, can_unwind, force_no_backtrace }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 152, name: \"core::panicking::panic\" }",
        "func": {
          "name": "core::panicking::panic",
          "mangled_name": "_ZN4core9panicking5panic17hee37ceed2bfa2394E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic(expr: &'static str) -> ! {\n    // Use Arguments::new_const instead of format_args!(\"{expr}\") to potentially\n    // reduce size overhead. The format_args! macro uses str's Display trait to\n    // write expr, which calls Formatter::pad, which must accommodate string\n    // truncation and padding (even though none is used here). Using\n    // Arguments::new_const may allow the compiler to omit Formatter::pad from the\n    // output binary, saving up to a few kilobytes.\n    // However, this optimization only works for `'static` strings: `new_const` also makes this\n    // message return `Some` from `Arguments::as_str`, which means it can become part of the panic\n    // payload without any allocation or copying. Shorter-lived strings would become invalid as\n    // stack frames get popped during unwinding, and couldn't be directly referenced from the\n    // payload.\n    panic_fmt(fmt::Arguments::new_const(&[expr]));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 137, name: \"core::panicking::panic_nounwind\" }",
        "func": {
          "name": "core::panicking::panic_nounwind",
          "mangled_name": "_ZN4core9panicking14panic_nounwind17h21f756518b770eccE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind(expr: &'static str) -> ! {\n    panic_nounwind_fmt(fmt::Arguments::new_const(&[expr]), /* force_no_backtrace */ false);\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 139, name: \"core::panicking::panic_nounwind_fmt\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt17ha5c466fea0230c4cE",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_nounwind_fmt(fmt: fmt::Arguments<'_>, force_no_backtrace: bool) -> ! {\n    const_eval_select!(\n        @capture { fmt: fmt::Arguments<'_>, force_no_backtrace: bool } -> !:\n        if const #[track_caller] {\n            // We don't unwind anyway at compile-time so we can call the regular `panic_fmt`.\n            panic_fmt(fmt)\n        } else #[track_caller] {\n            if cfg!(feature = \"panic_immediate_abort\") {\n                super::intrinsics::abort()\n            }\n\n            // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n            // that gets resolved to the `#[panic_handler]` function.\n            unsafe extern \"Rust\" {\n                #[lang = \"panic_impl\"]\n                fn panic_impl(pi: &PanicInfo<'_>) -> !;\n            }\n\n            // PanicInfo with the `can_unwind` flag set to false forces an abort.\n            let pi = PanicInfo::new(\n                &fmt,\n                Location::caller(),\n                /* can_unwind */ false,\n                force_no_backtrace,\n            );\n\n            // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n            unsafe { panic_impl(&pi) }\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 140, name: \"core::panicking::panic_nounwind_fmt::runtime\" }",
        "func": {
          "name": "core::panicking::panic_nounwind_fmt::runtime",
          "mangled_name": "_ZN4core9panicking18panic_nounwind_fmt7runtime17h077fbeb784973dc1E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 180, name: \"core::slice::<impl [T]>::as_chunks_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::as_chunks_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked18precondition_check17hae985b6008ba8febE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 197, name: \"core::slice::<impl [T]>::split_at_unchecked::precondition_check\" }",
        "func": {
          "name": "core::slice::<impl [T]>::split_at_unchecked::precondition_check",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked18precondition_check17h036498ebedbca62dE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [[usize; 4]]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h1f796214e285bd05E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 163, name: \"core::slice::<impl [T]>::align_to\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8align_to17h3f2f55440dbd3412E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n        // Note that most of this function will be constant-evaluated,\n        if U::IS_ZST || T::IS_ZST {\n            // handle ZSTs specially, which is  don't handle them at all.\n            return (self, &[], &[]);\n        }\n\n        // First, find at what point do we split between the first and 2nd slice. Easy with\n        // ptr.align_offset.\n        let ptr = self.as_ptr();\n        // SAFETY: See the `align_to_mut` method for the detailed safety comment.\n        let offset = unsafe { crate::ptr::align_offset(ptr, align_of::<U>()) };\n        if offset > self.len() {\n            (self, &[], &[])\n        } else {\n            let (left, rest) = self.split_at(offset);\n            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n            // Inform Miri that we want to consider the \"middle\" pointer to be suitably aligned.\n            #[cfg(miri)]\n            crate::intrinsics::miri_promise_symbolic_alignment(\n                rest.as_ptr().cast(),\n                align_of::<U>(),\n            );\n            // SAFETY: now `rest` is definitely aligned, so `from_raw_parts` below is okay,\n            // since the caller guarantees that we can transmute `T` to `U` safely.\n            unsafe {\n                (\n                    left,\n                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n                    from_raw_parts(rest.as_ptr().add(rest.len() - ts_len), ts_len),\n                )\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 207, name: \"core::slice::<impl [T]>::align_to_offsets\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::align_to_offsets::<usize>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16align_to_offsets17h9a870748ec74d22cE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "fn align_to_offsets<U>(&self) -> (usize, usize) {\n        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n        //\n        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n        //\n        // Formula to calculate this is:\n        //\n        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n        //\n        // Expanded and simplified:\n        //\n        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n        //\n        // Luckily since all this is constant-evaluated... performance here matters not!\n        const fn gcd(a: usize, b: usize) -> usize {\n            if b == 0 { a } else { gcd(b, a % b) }\n        }\n\n        // Explicitly wrap the function call in a const block so it gets\n        // constant-evaluated even in debug mode.\n        let gcd: usize = const { gcd(size_of::<T>(), size_of::<U>()) };\n        let ts: usize = size_of::<U>() / gcd;\n        let us: usize = size_of::<T>() / gcd;\n\n        // Armed with this knowledge, we can find how many `U`s we can fit!\n        let us_len = self.len() / ts * us;\n        // And how many `T`s will be in the trailing slice!\n        let ts_len = self.len() % ts;\n        (us_len, ts_len)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17h78ea551bdbf9c409E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9261551842730f07E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h6fde5a5a7a6da893E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h0771b4bddc48611aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [u8]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h8b631703f7d638d3E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 171, name: \"core::slice::<impl [T]>::as_chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$9as_chunks17h62f5495583e80f1aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_chunks<const N: usize>(&self) -> (&[[T; N]], &[T]) {\n        assert!(N != 0, \"chunk size must be non-zero\");\n        let len_rounded_down = self.len() / N * N;\n        // SAFETY: The rounded-down value is always the same or smaller than the\n        // original length, and thus must be in-bounds of the slice.\n        let (multiple_of_n, remainder) = unsafe { self.split_at_unchecked(len_rounded_down) };\n        // SAFETY: We already panicked for zero, and ensured by construction\n        // that the length of the subslice is a multiple of N.\n        let array_slice = unsafe { multiple_of_n.as_chunks_unchecked() };\n        (array_slice, remainder)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 179, name: \"core::slice::<impl [T]>::as_chunks_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_chunks_unchecked::<4>",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$19as_chunks_unchecked17h8e9f62deb4bed8e1E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn as_chunks_unchecked<const N: usize>(&self) -> &[[T; N]] {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::as_chunks_unchecked requires `N != 0` and the slice to split exactly into `N`-element chunks\",\n            (n: usize = N, len: usize = self.len()) => n != 0 && len % n == 0,\n        );\n        // SAFETY: Caller must guarantee that `N` is nonzero and exactly divides the slice length\n        let new_len = unsafe { exact_div(self.len(), N) };\n        // SAFETY: We cast a slice of `new_len * N` elements into\n        // a slice of `new_len` many `N` elements chunks.\n        unsafe { from_raw_parts(self.as_ptr().cast(), new_len) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 182, name: \"core::slice::<impl [T]>::as_ptr\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::as_ptr",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6as_ptr17hb16374a047362e58E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn as_ptr(&self) -> *const T {\n        self as *const [T] as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 166, name: \"core::slice::<impl [T]>::chunks\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::chunks",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$6chunks17ha09721e0e969e33aE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn chunks(&self, chunk_size: usize) -> Chunks<'_, T> {\n        assert!(chunk_size != 0, \"chunk size must be non-zero\");\n        Chunks::new(self, chunk_size)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 164, name: \"core::slice::<impl [T]>::is_empty\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::is_empty",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8is_empty17ha518b9eb9d09acddE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn is_empty(&self) -> bool {\n        self.len() == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 106, name: \"core::slice::<impl [T]>::iter\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::iter",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$4iter17h9bded35725a0f34bE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub fn iter(&self) -> Iter<'_, T> {\n        Iter::new(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 206, name: \"core::slice::<impl [T]>::split_at\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$8split_at17h4760363bd3d8df7dE",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at(&self, mid: usize) -> (&[T], &[T]) {\n        match self.split_at_checked(mid) {\n            Some(pair) => pair,\n            None => panic!(\"mid > len\"),\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 210, name: \"core::slice::<impl [T]>::split_at_checked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_checked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$16split_at_checked17h33e3be9e163f3d84E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const fn split_at_checked(&self, mid: usize) -> Option<(&[T], &[T])> {\n        if mid <= self.len() {\n            // SAFETY: `[ptr; mid]` and `[mid; len]` are inside `self`, which\n            // fulfills the requirements of `split_at_unchecked`.\n            Some(unsafe { self.split_at_unchecked(mid) })\n        } else {\n            None\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 178, name: \"core::slice::<impl [T]>::split_at_unchecked\" }",
        "func": {
          "name": "core::slice::<impl [usize]>::split_at_unchecked",
          "mangled_name": "_ZN4core5slice29_$LT$impl$u20$$u5b$T$u5d$$GT$18split_at_unchecked17h2ba5f3ee616a9de4E",
          "kind": "Item",
          "file": "library/core/src/slice/mod.rs",
          "src": "pub const unsafe fn split_at_unchecked(&self, mid: usize) -> (&[T], &[T]) {\n        // FIXME(const-hack): the const function `from_raw_parts` is used to make this\n        // function const; previously the implementation used\n        // `(self.get_unchecked(..mid), self.get_unchecked(mid..))`\n\n        let len = self.len();\n        let ptr = self.as_ptr();\n\n        assert_unsafe_precondition!(\n            check_library_ub,\n            \"slice::split_at_unchecked requires the index to be within the slice\",\n            (mid: usize = mid, len: usize = len) => mid <= len,\n        );\n\n        // SAFETY: Caller has to check that `0 <= mid <= self.len()`\n        unsafe { (from_raw_parts(ptr, mid), from_raw_parts(ptr.add(mid), unchecked_sub(len, mid))) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[[usize; 4]]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17hd4a47bd844608dd0E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 172, name: \"core::slice::iter::<impl std::iter::IntoIterator for &'a [T]>::into_iter\" }",
        "func": {
          "name": "core::slice::iter::<impl std::iter::IntoIterator for &[usize]>::into_iter",
          "mangled_name": "_ZN4core5slice4iter87_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u5d$$GT$9into_iter17h59a4497cf99cfe33E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 103, name: \"core::str::<impl str>::as_bytes\" }",
        "func": {
          "name": "core::str::<impl str>::as_bytes",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$8as_bytes17hfe1187add6301ee6E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn as_bytes(&self) -> &[u8] {\n        // SAFETY: const sound because we transmute two types with the same layout\n        unsafe { mem::transmute(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 79, name: \"core::str::<impl str>::char_indices\" }",
        "func": {
          "name": "core::str::<impl str>::char_indices",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$12char_indices17h2ef4bb22e84c1a37E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn char_indices(&self) -> CharIndices<'_> {\n        CharIndices { front_offset: 0, iter: self.chars() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 87, name: \"core::str::<impl str>::chars\" }",
        "func": {
          "name": "core::str::<impl str>::chars",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$5chars17h8fcb935f0f5f0c0bE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub fn chars(&self) -> Chars<'_> {\n        Chars { iter: self.as_bytes().iter() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 86, name: \"core::str::<impl str>::get_unchecked\" }",
        "func": {
          "name": "core::str::<impl str>::get_unchecked::<std::ops::RangeTo<usize>>",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$13get_unchecked17h949054447ff215bbE",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n        // the slice is dereferenceable because `self` is a safe reference.\n        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n        unsafe { &*i.get_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 102, name: \"core::str::<impl str>::len\" }",
        "func": {
          "name": "core::str::<impl str>::len",
          "mangled_name": "_ZN4core3str21_$LT$impl$u20$str$GT$3len17h0efa33433be36319E",
          "kind": "Item",
          "file": "library/core/src/str/mod.rs",
          "src": "pub const fn len(&self) -> usize {\n        self.as_bytes().len()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 104, name: \"core::str::count::char_count_general_case\" }",
        "func": {
          "name": "core::str::count::char_count_general_case",
          "mangled_name": "_ZN4core3str5count23char_count_general_case17h9194c83a4785e6c0E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn char_count_general_case(s: &[u8]) -> usize {\n    s.iter().filter(|&&byte| !super::validations::utf8_is_cont_byte(byte)).count()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 111, name: \"core::str::count::char_count_general_case::{closure#0}\" }",
        "func": {
          "name": "core::str::count::char_count_general_case::{closure#0}",
          "mangled_name": "_ZN4core3str5count23char_count_general_case28_$u7b$$u7b$closure$u7d$$u7d$17h394284915c90711eE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "|&&byte| !super::validations::utf8_is_cont_byte(byte)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 176, name: \"core::str::count::contains_non_continuation_byte\" }",
        "func": {
          "name": "core::str::count::contains_non_continuation_byte",
          "mangled_name": "_ZN4core3str5count30contains_non_continuation_byte17hde3d14fc61658f17E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn contains_non_continuation_byte(w: usize) -> usize {\n    const LSB: usize = usize::repeat_u8(0x01);\n    ((!w >> 7) | (w >> 6)) & LSB\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 101, name: \"core::str::count::count_chars\" }",
        "func": {
          "name": "core::str::count::count_chars",
          "mangled_name": "_ZN4core3str5count11count_chars17h438fe512170f6882E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "pub(super) fn count_chars(s: &str) -> usize {\n    if cfg!(feature = \"optimize_for_size\") || s.len() < USIZE_SIZE * UNROLL_INNER {\n        // Avoid entering the optimized implementation for strings where the\n        // difference is not likely to matter, or where it might even be slower.\n        // That said, a ton of thought was not spent on the particular threshold\n        // here, beyond \"this value seems to make sense\".\n        char_count_general_case(s.as_bytes())\n    } else {\n        do_count_chars(s)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 105, name: \"core::str::count::do_count_chars\" }",
        "func": {
          "name": "core::str::count::do_count_chars",
          "mangled_name": "_ZN4core3str5count14do_count_chars17h75afdc7e2f50899aE",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn do_count_chars(s: &str) -> usize {\n    // For correctness, `CHUNK_SIZE` must be:\n    //\n    // - Less than or equal to 255, otherwise we'll overflow bytes in `counts`.\n    // - A multiple of `UNROLL_INNER`, otherwise our `break` inside the\n    //   `body.chunks(CHUNK_SIZE)` loop is incorrect.\n    //\n    // For performance, `CHUNK_SIZE` should be:\n    // - Relatively cheap to `/` against (so some simple sum of powers of two).\n    // - Large enough to avoid paying for the cost of the `sum_bytes_in_usize`\n    //   too often.\n    const CHUNK_SIZE: usize = 192;\n\n    // Check the properties of `CHUNK_SIZE` and `UNROLL_INNER` that are required\n    // for correctness.\n    const _: () = assert!(CHUNK_SIZE < 256);\n    const _: () = assert!(CHUNK_SIZE % UNROLL_INNER == 0);\n\n    // SAFETY: transmuting `[u8]` to `[usize]` is safe except for size\n    // differences which are handled by `align_to`.\n    let (head, body, tail) = unsafe { s.as_bytes().align_to::<usize>() };\n\n    // This should be quite rare, and basically exists to handle the degenerate\n    // cases where align_to fails (as well as miri under symbolic alignment\n    // mode).\n    //\n    // The `unlikely` helps discourage LLVM from inlining the body, which is\n    // nice, as we would rather not mark the `char_count_general_case` function\n    // as cold.\n    if unlikely(body.is_empty() || head.len() > USIZE_SIZE || tail.len() > USIZE_SIZE) {\n        return char_count_general_case(s.as_bytes());\n    }\n\n    let mut total = char_count_general_case(head) + char_count_general_case(tail);\n    // Split `body` into `CHUNK_SIZE` chunks to reduce the frequency with which\n    // we call `sum_bytes_in_usize`.\n    for chunk in body.chunks(CHUNK_SIZE) {\n        // We accumulate intermediate sums in `counts`, where each byte contains\n        // a subset of the sum of this chunk, like a `[u8; size_of::<usize>()]`.\n        let mut counts = 0;\n\n        let (unrolled_chunks, remainder) = chunk.as_chunks::<UNROLL_INNER>();\n        for unrolled in unrolled_chunks {\n            for &word in unrolled {\n                // Because `CHUNK_SIZE` is < 256, this addition can't cause the\n                // count in any of the bytes to overflow into a subsequent byte.\n                counts += contains_non_continuation_byte(word);\n            }\n        }\n\n        // Sum the values in `counts` (which, again, is conceptually a `[u8;\n        // size_of::<usize>()]`), and accumulate the result into `total`.\n        total += sum_bytes_in_usize(counts);\n\n        // If there's any data in `remainder`, then handle it. This will only\n        // happen for the last `chunk` in `body.chunks()` (because `CHUNK_SIZE`\n        // is divisible by `UNROLL_INNER`), so we explicitly break at the end\n        // (which seems to help LLVM out).\n        if !remainder.is_empty() {\n            // Accumulate all the data in the remainder.\n            let mut counts = 0;\n            for &word in remainder {\n                counts += contains_non_continuation_byte(word);\n            }\n            total += sum_bytes_in_usize(counts);\n            break;\n        }\n    }\n    total\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 175, name: \"core::str::count::sum_bytes_in_usize\" }",
        "func": {
          "name": "core::str::count::sum_bytes_in_usize",
          "mangled_name": "_ZN4core3str5count18sum_bytes_in_usize17h0fe82d38e63b1ff2E",
          "kind": "Item",
          "file": "library/core/src/str/count.rs",
          "src": "fn sum_bytes_in_usize(values: usize) -> usize {\n    const LSB_SHORTS: usize = usize::repeat_u16(0x0001);\n    const SKIP_BYTES: usize = usize::repeat_u16(0x00ff);\n\n    let pair_sum: usize = (values & SKIP_BYTES) + ((values >> 8) & SKIP_BYTES);\n    pair_sum.wrapping_mul(LSB_SHORTS) >> ((USIZE_SIZE - 2) * 8)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 266, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked17h3e681accfd37035aE",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        let slice = slice as *const [u8];\n\n        assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        );\n\n        // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n        // which satisfies all the conditions for `add`.\n        unsafe {\n            let new_len = unchecked_sub(self.end, self.start);\n            ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), new_len) as *const str\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 268, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::Range<usize>>::get_unchecked::precondition_check",
          "mangled_name": "_ZN4core3str6traits108_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..Range$LT$usize$GT$$GT$13get_unchecked18precondition_check17h9bf8221b9faf40cbE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            // We'd like to check that the bounds are on char boundaries,\n            // but there's not really a way to do so without reading\n            // behind the pointer, which has aliasing implications.\n            // It's also not possible to move this check up to\n            // `str::get_unchecked` without adding a special function\n            // to `SliceIndex` just for this.\n            check_library_ub,\n            \"str::get_unchecked requires that the range is within the string slice\",\n            (\n                start: usize = self.start,\n                end: usize = self.end,\n                len: usize = slice.len()\n            ) => end >= start && end <= len,\n        )"
        }
      },
      {
        "def_id": "DefId { id: 265, name: \"core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked\" }",
        "func": {
          "name": "core::str::traits::<impl std::slice::SliceIndex<str> for std::ops::RangeTo<usize>>::get_unchecked",
          "mangled_name": "_ZN4core3str6traits110_$LT$impl$u20$core..slice..index..SliceIndex$LT$str$GT$$u20$for$u20$core..ops..range..RangeTo$LT$usize$GT$$GT$13get_unchecked17h926389fc19e40548E",
          "kind": "Item",
          "file": "library/core/src/str/traits.rs",
          "src": "unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n        // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n        unsafe { (0..self.end).get_unchecked(slice) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 235, name: \"core::str::validations::next_code_point\" }",
        "func": {
          "name": "core::str::validations::next_code_point::<'_, std::slice::Iter<'_, u8>>",
          "mangled_name": "_ZN4core3str11validations15next_code_point17h49ef59a58d9bb16bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub unsafe fn next_code_point<'a, I: Iterator<Item = &'a u8>>(bytes: &mut I) -> Option<u32> {\n    // Decode UTF-8\n    let x = *bytes.next()?;\n    if x < 128 {\n        return Some(x as u32);\n    }\n\n    // Multibyte case follows\n    // Decode from a byte combination out of: [[[x y] z] w]\n    // NOTE: Performance is sensitive to the exact formulation here\n    let init = utf8_first_byte(x, 2);\n    // SAFETY: `bytes` produces an UTF-8-like string,\n    // so the iterator must produce a value here.\n    let y = unsafe { *bytes.next().unwrap_unchecked() };\n    let mut ch = utf8_acc_cont_byte(init, y);\n    if x >= 0xE0 {\n        // [[x y z] w] case\n        // 5th bit in 0xE0 .. 0xEF is always clear, so `init` is still valid\n        // SAFETY: `bytes` produces an UTF-8-like string,\n        // so the iterator must produce a value here.\n        let z = unsafe { *bytes.next().unwrap_unchecked() };\n        let y_z = utf8_acc_cont_byte((y & CONT_MASK) as u32, z);\n        ch = init << 12 | y_z;\n        if x >= 0xF0 {\n            // [x y z w] case\n            // use only the lower 3 bits of `init`\n            // SAFETY: `bytes` produces an UTF-8-like string,\n            // so the iterator must produce a value here.\n            let w = unsafe { *bytes.next().unwrap_unchecked() };\n            ch = (init & 7) << 18 | utf8_acc_cont_byte(y_z, w);\n        }\n    }\n\n    Some(ch)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 249, name: \"core::str::validations::utf8_acc_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_acc_cont_byte",
          "mangled_name": "_ZN4core3str11validations18utf8_acc_cont_byte17hc891eb537972639bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_acc_cont_byte(ch: u32, byte: u8) -> u32 {\n    (ch << 6) | (byte & CONT_MASK) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 247, name: \"core::str::validations::utf8_first_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_first_byte",
          "mangled_name": "_ZN4core3str11validations15utf8_first_byte17hb45ca0db55f7758bE",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "const fn utf8_first_byte(byte: u8, width: u32) -> u32 {\n    (byte & (0x7F >> width)) as u32\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 133, name: \"core::str::validations::utf8_is_cont_byte\" }",
        "func": {
          "name": "core::str::validations::utf8_is_cont_byte",
          "mangled_name": "_ZN4core3str11validations17utf8_is_cont_byte17hd8ea0d008709b6b4E",
          "kind": "Item",
          "file": "library/core/src/str/validations.rs",
          "src": "pub(super) const fn utf8_is_cont_byte(byte: u8) -> bool {\n    (byte as i8) < -64\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 134, name: \"core::ub_checks::check_language_ub\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub17h6827fd98917f2969E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn check_language_ub() -> bool {\n    // Only used for UB checks so we may const_eval_select.\n    intrinsics::ub_checks()\n        && const_eval_select!(\n            @capture { } -> bool:\n            if const {\n                // Always disable UB checks.\n                false\n            } else {\n                // Disable UB checks in Miri.\n                !cfg!(miri)\n            }\n        )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 146, name: \"core::ub_checks::check_language_ub::runtime\" }",
        "func": {
          "name": "core::ub_checks::check_language_ub::runtime",
          "mangled_name": "_ZN4core9ub_checks17check_language_ub7runtime17h105d247d9515ffcdE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 188, name: \"core::ub_checks::is_valid_allocation_size\" }",
        "func": {
          "name": "core::ub_checks::is_valid_allocation_size",
          "mangled_name": "_ZN4core9ub_checks24is_valid_allocation_size17h90616824e065af89E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn is_valid_allocation_size(size: usize, len: usize) -> bool {\n    let max_len = if size == 0 { usize::MAX } else { isize::MAX as usize / size };\n    len <= max_len\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 187, name: \"core::ub_checks::maybe_is_aligned_and_not_null\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null17h1c617f69f5e4fe01E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "pub(crate) const fn maybe_is_aligned_and_not_null(\n    ptr: *const (),\n    align: usize,\n    is_zst: bool,\n) -> bool {\n    // This is just for safety checks so we can const_eval_select.\n    const_eval_select!(\n        @capture { ptr: *const (), align: usize, is_zst: bool } -> bool:\n        if const {\n            is_zst || !ptr.is_null()\n        } else {\n            ptr.is_aligned_to(align) && (is_zst || !ptr.is_null())\n        }\n    )\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 189, name: \"core::ub_checks::maybe_is_aligned_and_not_null::runtime\" }",
        "func": {
          "name": "core::ub_checks::maybe_is_aligned_and_not_null::runtime",
          "mangled_name": "_ZN4core9ub_checks29maybe_is_aligned_and_not_null7runtime17hc3925ab73c46a78aE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 53, name: \"kani::panic\" }",
        "func": {
          "name": "kani::panic",
          "mangled_name": "_ZN4kani5panic17h6190bada9522f78aE",
          "kind": "Item",
          "file": "kani/library/kani_core/src/lib.rs",
          "src": "pub const fn panic(message: &'static str) -> ! {\n            panic!(\"{}\", message)\n        }",
          "before_expansion": "kani_core::kani_intrinsics!(std)"
        }
      },
      {
        "def_id": "DefId { id: 55, name: \"kani::panic::panic_cold_display\" }",
        "func": {
          "name": "kani::panic::panic_cold_display::<&str>",
          "mangled_name": "_ZN4kani5panic18panic_cold_display17h3c77492d46a89dbbE",
          "kind": "Item",
          "file": "library/core/src/panic.rs",
          "src": "const fn panic_cold_display<T: $crate::fmt::Display>(arg: &T) -> ! {\n            $crate::panicking::panic_display(arg)\n        }",
          "before_expansion": "panic!(\"{}\", message)"
        }
      },
      {
        "def_id": "DefId { id: 174, name: \"std::array::<impl std::iter::IntoIterator for &'a [T; N]>::into_iter\" }",
        "func": {
          "name": "std::array::<impl std::iter::IntoIterator for &[usize; 4]>::into_iter",
          "mangled_name": "_ZN4core5array98_$LT$impl$u20$core..iter..traits..collect..IntoIterator$u20$for$u20$$RF$$u5b$T$u3b$$u20$N$u5d$$GT$9into_iter17he1c19779b96d5e95E",
          "kind": "Item",
          "file": "library/core/src/array/mod.rs",
          "src": "fn into_iter(self) -> Iter<'a, T> {\n        self.iter()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 242, name: \"std::char::convert::char_try_from_u32\" }",
        "func": {
          "name": "std::char::convert::char_try_from_u32",
          "mangled_name": "_ZN4core4char7convert17char_try_from_u3217h79452afed33d8afaE",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "const fn char_try_from_u32(i: u32) -> Result<char, CharTryFromError> {\n    // This is an optimized version of the check\n    // (i > MAX as u32) || (i >= 0xD800 && i <= 0xDFFF),\n    // which can also be written as\n    // i >= 0x110000 || (i >= 0xD800 && i < 0xE000).\n    //\n    // The XOR with 0xD800 permutes the ranges such that 0xD800..0xE000 is\n    // mapped to 0x0000..0x0800, while keeping all the high bits outside 0xFFFF the same.\n    // In particular, numbers >= 0x110000 stay in this range.\n    //\n    // Subtracting 0x800 causes 0x0000..0x0800 to wrap, meaning that a single\n    // unsigned comparison against 0x110000 - 0x800 will detect both the wrapped\n    // surrogate range as well as the numbers originally larger than 0x110000.\n    //\n    if (i ^ 0xD800).wrapping_sub(0x800) >= 0x110000 - 0x800 {\n        Err(CharTryFromError(()))\n    } else {\n        // SAFETY: checked that it's a legal unicode value\n        Ok(unsafe { transmute(i) })\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 240, name: \"std::char::convert::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked17hd069e3b6813f4d52E",
          "kind": "Item",
          "file": "library/core/src/char/convert.rs",
          "src": "pub(super) const unsafe fn from_u32_unchecked(i: u32) -> char {\n    // SAFETY: the caller must guarantee that `i` is a valid char value.\n    unsafe {\n        assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        );\n        transmute(i)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 241, name: \"std::char::convert::from_u32_unchecked::precondition_check\" }",
        "func": {
          "name": "std::char::convert::from_u32_unchecked::precondition_check",
          "mangled_name": "_ZN4core4char7convert18from_u32_unchecked18precondition_check17h8dade502d8f04feeE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "assert_unsafe_precondition!(\n            check_language_ub,\n            \"invalid value for `char`\",\n            (i: u32 = i) => char_try_from_u32(i).is_ok()\n        )"
        }
      },
      {
        "def_id": "DefId { id: 239, name: \"std::char::methods::<impl char>::from_u32_unchecked\" }",
        "func": {
          "name": "std::char::methods::<impl char>::from_u32_unchecked",
          "mangled_name": "_ZN4core4char7methods22_$LT$impl$u20$char$GT$18from_u32_unchecked17h2c8c127ff9716582E",
          "kind": "Item",
          "file": "library/core/src/char/methods.rs",
          "src": "pub const unsafe fn from_u32_unchecked(i: u32) -> char {\n        // SAFETY: the safety contract must be upheld by the caller.\n        unsafe { super::convert::from_u32_unchecked(i) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 255, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for u16>::lt",
          "mangled_name": "_ZN4core3cmp5impls55_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$u16$GT$2lt17h2e1d14712d03b1a2E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 214, name: \"std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt\" }",
        "func": {
          "name": "std::cmp::impls::<impl std::cmp::PartialOrd for usize>::lt",
          "mangled_name": "_ZN4core3cmp5impls57_$LT$impl$u20$core..cmp..PartialOrd$u20$for$u20$usize$GT$2lt17h551740291a2e7191E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "fn lt(&self, other: &Self) -> bool { *self <  *other }",
          "before_expansion": "partial_ord_methods_primitive_impl!()"
        }
      },
      {
        "def_id": "DefId { id: 211, name: \"std::cmp::min\" }",
        "func": {
          "name": "std::cmp::min::<usize>",
          "mangled_name": "_ZN4core3cmp3min17hdf73c061ba7372f8E",
          "kind": "Item",
          "file": "library/core/src/cmp.rs",
          "src": "pub fn min<T: Ord>(v1: T, v2: T) -> T {\n    v1.min(v2)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 81, name: \"std::convert::num::<impl std::convert::From<u16> for usize>::from\" }",
        "func": {
          "name": "std::convert::num::<impl std::convert::From<u16> for usize>::from",
          "mangled_name": "_ZN4core7convert3num66_$LT$impl$u20$core..convert..From$LT$u16$GT$$u20$for$u20$usize$GT$4from17hcff1e1e2ee4568c2E",
          "kind": "Item",
          "file": "library/core/src/convert/num.rs",
          "src": "fn from(small: $Small) -> Self {\n                small as Self\n            }",
          "before_expansion": "impl_from!(\n            $Small => $Large,\n            #[$attr],\n            concat!(\"Converts [`\", stringify!($Small), \"`] to [`\", stringify!($Large), \"`] losslessly.\"),\n        )"
        }
      },
      {
        "def_id": "DefId { id: 138, name: \"std::fmt::Arguments::<'a>::new_const\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_const::<1>",
          "mangled_name": "_ZN4core3fmt9Arguments9new_const17hbb45028c907195c1E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_const<const N: usize>(pieces: &'a [&'static str; N]) -> Self {\n        const { assert!(N <= 1) };\n        Arguments { pieces, fmt: None, args: &[] }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 58, name: \"std::fmt::Arguments::<'a>::new_v1\" }",
        "func": {
          "name": "std::fmt::Arguments::<'_>::new_v1::<1, 1>",
          "mangled_name": "_ZN4core3fmt9Arguments6new_v117heaed1009cc26b388E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn new_v1<const P: usize, const A: usize>(\n        pieces: &'a [&'static str; P],\n        args: &'a [rt::Argument<'a>; A],\n    ) -> Arguments<'a> {\n        const { assert!(P >= A && P <= A + 1, \"invalid args\") }\n        Arguments { pieces, fmt: None, args }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 73, name: \"std::fmt::Formatter::<'a>::pad\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::pad",
          "mangled_name": "_ZN4core3fmt9Formatter3pad17he3971bd2e0830220E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub fn pad(&mut self, s: &str) -> Result {\n        // Make sure there's a fast path up front.\n        if self.options.flags & (flags::WIDTH_FLAG | flags::PRECISION_FLAG) == 0 {\n            return self.buf.write_str(s);\n        }\n\n        // The `precision` field can be interpreted as a maximum width for the\n        // string being formatted.\n        let (s, char_count) = if let Some(max_char_count) = self.options.get_precision() {\n            let mut iter = s.char_indices();\n            let remaining = match iter.advance_by(usize::from(max_char_count)) {\n                Ok(()) => 0,\n                Err(remaining) => remaining.get(),\n            };\n            // SAFETY: The offset of `.char_indices()` is guaranteed to be\n            // in-bounds and between character boundaries.\n            let truncated = unsafe { s.get_unchecked(..iter.offset()) };\n            (truncated, usize::from(max_char_count) - remaining)\n        } else {\n            // Use the optimized char counting algorithm for the full string.\n            (s, s.chars().count())\n        };\n\n        // The `width` field is more of a minimum width parameter at this point.\n        if char_count < usize::from(self.options.width) {\n            // If we're under the minimum width, then fill up the minimum width\n            // with the specified string + some alignment.\n            let post_padding =\n                self.padding(self.options.width - char_count as u16, Alignment::Left)?;\n            self.buf.write_str(s)?;\n            post_padding.write(self)\n        } else {\n            // If we're over the minimum width or there is no minimum width, we\n            // can just emit the string.\n            self.buf.write_str(s)\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 90, name: \"std::fmt::Formatter::<'a>::padding\" }",
        "func": {
          "name": "std::fmt::Formatter::<'_>::padding",
          "mangled_name": "_ZN4core3fmt9Formatter7padding17h53f9e78fb4099400E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub(crate) fn padding(\n        &mut self,\n        padding: u16,\n        default: Alignment,\n    ) -> result::Result<PostPadding, Error> {\n        let align = self.options.get_align().unwrap_or(default);\n        let fill = self.options.get_fill();\n\n        let padding_left = match align {\n            Alignment::Left => 0,\n            Alignment::Right => padding,\n            Alignment::Center => padding / 2,\n        };\n\n        for _ in 0..padding_left {\n            self.buf.write_char(fill)?;\n        }\n\n        Ok(PostPadding::new(fill, padding - padding_left))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 260, name: \"std::fmt::FormattingOptions::get_align\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_align",
          "mangled_name": "_ZN4core3fmt17FormattingOptions9get_align17h8b918746f9c015ffE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_align(&self) -> Option<Alignment> {\n        match self.flags & flags::ALIGN_BITS {\n            flags::ALIGN_LEFT => Some(Alignment::Left),\n            flags::ALIGN_RIGHT => Some(Alignment::Right),\n            flags::ALIGN_CENTER => Some(Alignment::Center),\n            _ => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 262, name: \"std::fmt::FormattingOptions::get_fill\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_fill",
          "mangled_name": "_ZN4core3fmt17FormattingOptions8get_fill17h43c04343d70b7042E",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_fill(&self) -> char {\n        // SAFETY: We only ever put a valid `char` in the lower 21 bits of the flags field.\n        unsafe { char::from_u32_unchecked(self.flags & 0x1FFFFF) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 78, name: \"std::fmt::FormattingOptions::get_precision\" }",
        "func": {
          "name": "std::fmt::FormattingOptions::get_precision",
          "mangled_name": "_ZN4core3fmt17FormattingOptions13get_precision17hbd80eaff3d1888beE",
          "kind": "Item",
          "file": "library/core/src/fmt/mod.rs",
          "src": "pub const fn get_precision(&self) -> Option<u16> {\n        if self.flags & flags::PRECISION_FLAG != 0 { Some(self.precision) } else { None }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 250, name: \"std::hint::unreachable_unchecked\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked17hb85c714223239900E",
          "kind": "Item",
          "file": "library/core/src/hint.rs",
          "src": "pub const unsafe fn unreachable_unchecked() -> ! {\n    ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    );\n    // SAFETY: the safety contract for `intrinsics::unreachable` must\n    // be upheld by the caller.\n    unsafe { intrinsics::unreachable() }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 251, name: \"std::hint::unreachable_unchecked::precondition_check\" }",
        "func": {
          "name": "std::hint::unreachable_unchecked::precondition_check",
          "mangled_name": "_ZN4core4hint21unreachable_unchecked18precondition_check17haa76a7dc7c6e5497E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n        check_language_ub,\n        \"hint::unreachable_unchecked must never be reached\",\n        () => false\n    )"
        }
      },
      {
        "def_id": "DefId { id: 216, name: \"std::intrinsics::cold_path\" }",
        "func": {
          "name": "std::intrinsics::cold_path",
          "mangled_name": "_ZN4core10intrinsics9cold_path17he733dcfdc3261fb2E",
          "kind": "Intrinsic",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn cold_path() {}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 165, name: \"std::intrinsics::unlikely\" }",
        "func": {
          "name": "std::intrinsics::unlikely",
          "mangled_name": "_ZN4core10intrinsics8unlikely17hed6aa9940a66cedcE",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "pub const fn unlikely(b: bool) -> bool {\n    if b {\n        cold_path();\n        true\n    } else {\n        false\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 157, name: \"std::iter::Filter::<I, P>::new\" }",
        "func": {
          "name": "std::iter::Filter::<std::slice::Iter<'_, u8>, {closure@core::str::count::char_count_general_case::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters6filter19Filter$LT$I$C$P$GT$3new17hc34a2f01600b7b29E",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/filter.rs",
          "src": "pub(in crate::iter) fn new(iter: I, predicate: P) -> Filter<I, P> {\n        Filter { iter, predicate }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 117, name: \"std::iter::Map::<I, F>::new\" }",
        "func": {
          "name": "std::iter::Map::<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>::new",
          "mangled_name": "_ZN4core4iter8adapters3map16Map$LT$I$C$F$GT$3new17h53f0d55450f62c1dE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "pub(in crate::iter) fn new(iter: I, f: F) -> Map<I, F> {\n        Map { iter, f }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 122, name: \"std::iter::adapters::map::map_fold\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold17hfb84ea7d0fb8cbffE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "fn map_fold<T, B, Acc>(\n    mut f: impl FnMut(T) -> B,\n    mut g: impl FnMut(Acc, B) -> Acc,\n) -> impl FnMut(Acc, T) -> Acc {\n    move |acc, elt| g(acc, f(elt))\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 125, name: \"std::iter::adapters::map::map_fold::{closure#0}\" }",
        "func": {
          "name": "std::iter::adapters::map::map_fold::<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}",
          "mangled_name": "_ZN4core4iter8adapters3map8map_fold28_$u7b$$u7b$closure$u7d$$u7d$17hb3e453f99d84d8bfE",
          "kind": "Item",
          "file": "library/core/src/iter/adapters/map.rs",
          "src": "move |acc, elt| g(acc, f(elt))",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<u16>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17h07bdeaaf39b8685aE",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 221, name: \"std::iter::range::<impl std::iter::Iterator for std::ops::Range<A>>::next\" }",
        "func": {
          "name": "std::iter::range::<impl std::iter::Iterator for std::ops::Range<usize>>::next",
          "mangled_name": "_ZN4core4iter5range101_$LT$impl$u20$core..iter..traits..iterator..Iterator$u20$for$u20$core..ops..range..Range$LT$A$GT$$GT$4next17hd27f508ace781eb9E",
          "kind": "Item",
          "file": "library/core/src/iter/range.rs",
          "src": "fn next(&mut self) -> Option<A> {\n        self.spec_next()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem8align_of17h4ccf9d5c0139d079E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<u8>",
          "mangled_name": "_ZN4core3mem8align_of17hcf7fa5208d41c27fE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 184, name: \"std::mem::align_of\" }",
        "func": {
          "name": "std::mem::align_of::<usize>",
          "mangled_name": "_ZN4core3mem8align_of17h512cbae0980bb36dE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn align_of<T>() -> usize {\n    intrinsics::min_align_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<[usize; 4]>",
          "mangled_name": "_ZN4core3mem7size_of17h0553276df7ba24c2E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<u8>",
          "mangled_name": "_ZN4core3mem7size_of17hd68b5fd240b661c5E",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 150, name: \"std::mem::size_of\" }",
        "func": {
          "name": "std::mem::size_of::<usize>",
          "mangled_name": "_ZN4core3mem7size_of17hd5b2a7cccbb61ceeE",
          "kind": "Item",
          "file": "library/core/src/mem/mod.rs",
          "src": "pub const fn size_of<T>() -> usize {\n    intrinsics::size_of::<T>()\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 231, name: \"std::num::NonZero::<T>::new_unchecked::precondition_check\" }",
        "func": {
          "name": "std::num::NonZero::<T>::new_unchecked::precondition_check",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked18precondition_check17h0116c509d606ce2cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    )"
        }
      },
      {
        "def_id": "DefId { id: 84, name: \"std::num::NonZero::<T>::get\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::get",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3get17h87da58b24eb8904aE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn get(self) -> T {\n        // Rustc can set range metadata only if it loads `self` from\n        // memory somewhere. If the value of `self` was from by-value argument\n        // of some not-inlined function, LLVM don't have range metadata\n        // to understand that the value cannot be zero.\n        //\n        // Using the transmute `assume`s the range at runtime.\n        //\n        // Even once LLVM supports `!range` metadata for function arguments\n        // (see <https://github.com/llvm/llvm-project/issues/76628>), this can't\n        // be `.0` because MCP#807 bans field-projecting into `scalar_valid_range`\n        // types, and it arguably wouldn't want to be anyway because if this is\n        // MIR-inlined, there's no opportunity to put that argument metadata anywhere.\n        //\n        // The good answer here will eventually be pattern types, which will hopefully\n        // allow it to go back to `.0`, maybe with a cast of some sort.\n        //\n        // SAFETY: `ZeroablePrimitive` guarantees that the size and bit validity\n        // of `.0` is such that this transmute is sound.\n        unsafe { intrinsics::transmute_unchecked(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 230, name: \"std::num::NonZero::<T>::new\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$3new17h3cbc7a205e50ad1fE",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const fn new(n: T) -> Option<Self> {\n        // SAFETY: Memory layout optimization guarantees that `Option<NonZero<T>>` has\n        //         the same layout and size as `T`, with `0` representing `None`.\n        unsafe { intrinsics::transmute_unchecked(n) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 224, name: \"std::num::NonZero::<T>::new_unchecked\" }",
        "func": {
          "name": "std::num::NonZero::<usize>::new_unchecked",
          "mangled_name": "_ZN4core3num7nonzero16NonZero$LT$T$GT$13new_unchecked17hd3e157914eb40be4E",
          "kind": "Item",
          "file": "library/core/src/num/nonzero.rs",
          "src": "pub const unsafe fn new_unchecked(n: T) -> Self {\n        match Self::new(n) {\n            Some(n) => n,\n            None => {\n                // SAFETY: The caller guarantees that `n` is non-zero, so this is unreachable.\n                unsafe {\n                    ub_checks::assert_unsafe_precondition!(\n                        check_language_ub,\n                        \"NonZero::new_unchecked requires the argument to be non-zero\",\n                        () => false,\n                    );\n                    intrinsics::unreachable()\n                }\n            }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 248, name: \"std::option::Option::<T>::unwrap_unchecked\" }",
        "func": {
          "name": "std::option::Option::<&u8>::unwrap_unchecked",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$16unwrap_unchecked17hd4ca9a9271618328E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const unsafe fn unwrap_unchecked(self) -> T {\n        match self {\n            Some(val) => val,\n            // SAFETY: the safety contract must be upheld by the caller.\n            None => unsafe { hint::unreachable_unchecked() },\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 223, name: \"std::option::Option::<T>::is_none\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_none",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_none17hd6afafc489127163E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_none(&self) -> bool {\n        !self.is_some()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 225, name: \"std::option::Option::<T>::is_some\" }",
        "func": {
          "name": "std::option::Option::<(usize, char)>::is_some",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$7is_some17ha5fa074a52234010E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub const fn is_some(&self) -> bool {\n        matches!(*self, Some(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 261, name: \"std::option::Option::<T>::unwrap_or\" }",
        "func": {
          "name": "std::option::Option::<std::fmt::Alignment>::unwrap_or",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$9unwrap_or17h93449fbe40562582E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn unwrap_or(self, default: T) -> T {\n        match self {\n            Some(x) => x,\n            None => default,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 236, name: \"std::option::Option::<T>::map\" }",
        "func": {
          "name": "std::option::Option::<u32>::map::<char, {closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core6option15Option$LT$T$GT$3map17h4766a44e449f5bc0E",
          "kind": "Item",
          "file": "library/core/src/option.rs",
          "src": "pub fn map<U, F>(self, f: F) -> Option<U>\n    where\n        F: FnOnce(T) -> U,\n    {\n        match self {\n            Some(x) => Some(f(x)),\n            None => None,\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 141, name: \"std::panic::Location::<'a>::caller\" }",
        "func": {
          "name": "std::panic::Location::<'_>::caller",
          "mangled_name": "_ZN4core5panic8location8Location6caller17h7028f0eba4c7a6f8E",
          "kind": "Item",
          "file": "library/core/src/panic/location.rs",
          "src": "pub const fn caller() -> &'static Location<'static> {\n        crate::intrinsics::caller_location()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he78cf8b05978fd0dE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::cast::<()>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hdc66bbbf9ca09606E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<&str>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h521f17b23745bac9E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h8842d827e238f628E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h7751fb8567cbcb47E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[[usize; 4]]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h9de03001895d0df8E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h79cc454782b590c1E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::cast::<u8>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17h4c90e7777850aeebE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[u8]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h7dafd8edeaef92caE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17hc9f5a770b3d720c7E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17hbab76e706044fa2eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize; 4]>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h7c6d9cb10df2c094E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h04f77dd0bbba90e3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 68, name: \"std::ptr::NonNull::<T>::cast\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::cast::<usize>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$4cast17hd35b6c11a62aafd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn cast<U>(self) -> NonNull<U> {\n        // SAFETY: `self` is a `NonNull` pointer which is necessarily non-null\n        unsafe { NonNull { pointer: self.as_ptr() as *mut U } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 67, name: \"std::ptr::NonNull::<T>::from_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<[usize]>::from_ref",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$8from_ref17h40068346434d50f6E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn from_ref(r: &T) -> Self {\n        // SAFETY: A reference cannot be null.\n        unsafe { NonNull { pointer: r as *const T } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h8e78528254286707E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17h7757583d8ce29180E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17h54ad99e807176d15E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 129, name: \"std::ptr::NonNull::<T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::NonNull::<u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$20offset_from_unsigned17h4637137071b370dfE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, subtracted: NonNull<T>) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { self.as_ptr().offset_from_unsigned(subtracted.as_ptr()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 130, name: \"std::ptr::NonNull::<T>::add\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::add",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$3add17h157e6a6f791a927eE",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        // Additionally safety contract of `offset` guarantees that the resulting pointer is\n        // pointing to an allocation, there can't be an allocation at null, thus it's safe to\n        // construct `NonNull`.\n        unsafe { NonNull { pointer: intrinsics::offset(self.as_ptr(), count) } }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 70, name: \"std::ptr::NonNull::<T>::as_ptr\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ptr",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ptr17he7774680d992b871E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const fn as_ptr(self) -> *mut T {\n        // This is a transmute for the same reasons as `NonZero::get`.\n\n        // SAFETY: `NonNull` is `transparent` over a `*const T`, and `*const T`\n        // and `*mut T` have the same layout, so transitively we can transmute\n        // our `NonNull` to a `*mut T` directly.\n        unsafe { mem::transmute::<Self, *mut T>(self) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 200, name: \"std::ptr::NonNull::<T>::as_ref\" }",
        "func": {
          "name": "std::ptr::NonNull::<usize>::as_ref::<'_>",
          "mangled_name": "_ZN4core3ptr8non_null16NonNull$LT$T$GT$6as_ref17he3b1371588b0fd61E",
          "kind": "Item",
          "file": "library/core/src/ptr/non_null.rs",
          "src": "pub const unsafe fn as_ref<'a>(&self) -> &'a T {\n        // SAFETY: the caller must guarantee that `self` meets all the\n        // requirements for a reference.\n        // `cast_const` avoids a mutable raw pointer deref.\n        unsafe { &*self.as_ptr().cast_const() }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 205, name: \"std::ptr::align_offset\" }",
        "func": {
          "name": "std::ptr::align_offset::<u8>",
          "mangled_name": "_ZN4core3ptr12align_offset17hc37ffd11ea4851baE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub(crate) unsafe fn align_offset<T: Sized>(p: *const T, a: usize) -> usize {\n    // FIXME(#75598): Direct use of these intrinsics improves codegen significantly at opt-level <=\n    // 1, where the method versions of these operations are not inlined.\n    use intrinsics::{\n        assume, cttz_nonzero, exact_div, mul_with_overflow, unchecked_rem, unchecked_shl,\n        unchecked_shr, unchecked_sub, wrapping_add, wrapping_mul, wrapping_sub,\n    };\n\n    /// Calculate multiplicative modular inverse of `x` modulo `m`.\n    ///\n    /// This implementation is tailored for `align_offset` and has following preconditions:\n    ///\n    /// * `m` is a power-of-two;\n    /// * `x < m`; (if `x  m`, pass in `x % m` instead)\n    ///\n    /// Implementation of this function shall not panic. Ever.\n    #[inline]\n    const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }\n\n    let stride = size_of::<T>();\n\n    let addr: usize = p.addr();\n\n    // SAFETY: `a` is a power-of-two, therefore non-zero.\n    let a_minus_one = unsafe { unchecked_sub(a, 1) };\n\n    if stride == 0 {\n        // SPECIAL_CASE: handle 0-sized types. No matter how many times we step, the address will\n        // stay the same, so no offset will be able to align the pointer unless it is already\n        // aligned. This branch _will_ be optimized out as `stride` is known at compile-time.\n        let p_mod_a = addr & a_minus_one;\n        return if p_mod_a == 0 { 0 } else { usize::MAX };\n    }\n\n    // SAFETY: `stride == 0` case has been handled by the special case above.\n    let a_mod_stride = unsafe { unchecked_rem(a, stride) };\n    if a_mod_stride == 0 {\n        // SPECIAL_CASE: In cases where the `a` is divisible by `stride`, byte offset to align a\n        // pointer can be computed more simply through `-p (mod a)`. In the off-chance the byte\n        // offset is not a multiple of `stride`, the input pointer was misaligned and no pointer\n        // offset will be able to produce a `p` aligned to the specified `a`.\n        //\n        // The naive `-p (mod a)` equation inhibits LLVM's ability to select instructions\n        // like `lea`. We compute `(round_up_to_next_alignment(p, a) - p)` instead. This\n        // redistributes operations around the load-bearing, but pessimizing `and` instruction\n        // sufficiently for LLVM to be able to utilize the various optimizations it knows about.\n        //\n        // LLVM handles the branch here particularly nicely. If this branch needs to be evaluated\n        // at runtime, it will produce a mask `if addr_mod_stride == 0 { 0 } else { usize::MAX }`\n        // in a branch-free way and then bitwise-OR it with whatever result the `-p mod a`\n        // computation produces.\n\n        let aligned_address = wrapping_add(addr, a_minus_one) & wrapping_sub(0, a);\n        let byte_offset = wrapping_sub(aligned_address, addr);\n        // FIXME: Remove the assume after <https://github.com/llvm/llvm-project/issues/62502>\n        // SAFETY: Masking by `-a` can only affect the low bits, and thus cannot have reduced\n        // the value by more than `a-1`, so even though the intermediate values might have\n        // wrapped, the byte_offset is always in `[0, a)`.\n        unsafe { assume(byte_offset < a) };\n\n        // SAFETY: `stride == 0` case has been handled by the special case above.\n        let addr_mod_stride = unsafe { unchecked_rem(addr, stride) };\n\n        return if addr_mod_stride == 0 {\n            // SAFETY: `stride` is non-zero. This is guaranteed to divide exactly as well, because\n            // addr has been verified to be aligned to the original types alignment requirements.\n            unsafe { exact_div(byte_offset, stride) }\n        } else {\n            usize::MAX\n        };\n    }\n\n    // GENERAL_CASE: From here on were handling the very general case where `addr` may be\n    // misaligned, there isnt an obvious relationship between `stride` and `a` that we can take an\n    // advantage of, etc. This case produces machine code that isnt particularly high quality,\n    // compared to the special cases above. The code produced here is still within the realm of\n    // miracles, given the situations this case has to deal with.\n\n    // SAFETY: a is power-of-two hence non-zero. stride == 0 case is handled above.\n    // FIXME(const-hack) replace with min\n    let gcdpow = unsafe {\n        let x = cttz_nonzero(stride);\n        let y = cttz_nonzero(a);\n        if x < y { x } else { y }\n    };\n    // SAFETY: gcdpow has an upper-bound thats at most the number of bits in a `usize`.\n    let gcd = unsafe { unchecked_shl(1usize, gcdpow) };\n    // SAFETY: gcd is always greater or equal to 1.\n    if addr & unsafe { unchecked_sub(gcd, 1) } == 0 {\n        // This branch solves for the following linear congruence equation:\n        //\n        // ` p + so = 0 mod a `\n        //\n        // `p` here is the pointer value, `s` - stride of `T`, `o` offset in `T`s, and `a` - the\n        // requested alignment.\n        //\n        // With `g = gcd(a, s)`, and the above condition asserting that `p` is also divisible by\n        // `g`, we can denote `a' = a/g`, `s' = s/g`, `p' = p/g`, then this becomes equivalent to:\n        //\n        // ` p' + s'o = 0 mod a' `\n        // ` o = (a' - (p' mod a')) * (s'^-1 mod a') `\n        //\n        // The first term is \"the relative alignment of `p` to `a`\" (divided by the `g`), the\n        // second term is \"how does incrementing `p` by `s` bytes change the relative alignment of\n        // `p`\" (again divided by `g`). Division by `g` is necessary to make the inverse well\n        // formed if `a` and `s` are not co-prime.\n        //\n        // Furthermore, the result produced by this solution is not \"minimal\", so it is necessary\n        // to take the result `o mod lcm(s, a)`. This `lcm(s, a)` is the same as `a'`.\n\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let a2 = unsafe { unchecked_shr(a, gcdpow) };\n        // SAFETY: `a2` is non-zero. Shifting `a` by `gcdpow` cannot shift out any of the set bits\n        // in `a` (of which it has exactly one).\n        let a2minus1 = unsafe { unchecked_sub(a2, 1) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`.\n        let s2 = unsafe { unchecked_shr(stride & a_minus_one, gcdpow) };\n        // SAFETY: `gcdpow` has an upper-bound not greater than the number of trailing 0-bits in\n        // `a`. Furthermore, the subtraction cannot overflow, because `a2 = a >> gcdpow` will\n        // always be strictly greater than `(p % a) >> gcdpow`.\n        let minusp2 = unsafe { unchecked_sub(a2, unchecked_shr(addr & a_minus_one, gcdpow)) };\n        // SAFETY: `a2` is a power-of-two, as proven above. `s2` is strictly less than `a2`\n        // because `(s % a) >> gcdpow` is strictly less than `a >> gcdpow`.\n        return wrapping_mul(minusp2, unsafe { mod_inv(s2, a2) }) & a2minus1;\n    }\n\n    // Cannot be aligned at all.\n    usize::MAX\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 209, name: \"std::ptr::align_offset::mod_inv\" }",
        "func": {
          "name": "std::ptr::align_offset::mod_inv",
          "mangled_name": "_ZN4core3ptr12align_offset7mod_inv17h4226b9d4d3d5c672E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "const unsafe fn mod_inv(x: usize, m: usize) -> usize {\n        /// Multiplicative modular inverse table modulo 2 = 16.\n        ///\n        /// Note, that this table does not contain values where inverse does not exist (i.e., for\n        /// `0 mod 16`, `2 mod 16`, etc.)\n        const INV_TABLE_MOD_16: [u8; 8] = [1, 11, 13, 7, 9, 3, 5, 15];\n        /// Modulo for which the `INV_TABLE_MOD_16` is intended.\n        const INV_TABLE_MOD: usize = 16;\n\n        // SAFETY: `m` is required to be a power-of-two, hence non-zero.\n        let m_minus_one = unsafe { unchecked_sub(m, 1) };\n        let mut inverse = INV_TABLE_MOD_16[(x & (INV_TABLE_MOD - 1)) >> 1] as usize;\n        let mut mod_gate = INV_TABLE_MOD;\n        // We iterate \"up\" using the following formula:\n        //\n        // $$ xy  1 (mod 2)  xy (2 - xy)  1 (mod 2) $$\n        //\n        // This application needs to be applied at least until `2  m`, at which point we can\n        // finally reduce the computation to our desired `m` by taking `inverse mod m`.\n        //\n        // This computation is `O(log log m)`, which is to say, that on 64-bit machines this loop\n        // will always finish in at most 4 iterations.\n        loop {\n            // y = y * (2 - xy) mod n\n            //\n            // Note, that we use wrapping operations here intentionally  the original formula\n            // uses e.g., subtraction `mod n`. It is entirely fine to do them `mod\n            // usize::MAX` instead, because we take the result `mod n` at the end\n            // anyway.\n            if mod_gate >= m {\n                break;\n            }\n            inverse = wrapping_mul(inverse, wrapping_sub(2usize, wrapping_mul(x, inverse)));\n            let (new_gate, overflow) = mul_with_overflow(mod_gate, mod_gate);\n            if overflow {\n                break;\n            }\n            mod_gate = new_gate;\n        }\n        inverse & m_minus_one\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3e62dd7746f386b1E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h94920da9c4e41356E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 190, name: \"std::ptr::const_ptr::<impl *const T>::is_aligned_to\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_aligned_to",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$13is_aligned_to17hbaf8f80ac8bd74b5E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn is_aligned_to(self, align: usize) -> bool {\n        if !align.is_power_of_two() {\n            panic!(\"is_aligned_to: align is not a power-of-two\");\n        }\n\n        self.addr() & (align - 1) == 0\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 191, name: \"std::ptr::const_ptr::<impl *const T>::is_null\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const ()>::is_null",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null17h39f2cba5693cfcbaE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn is_null(self) -> bool {\n        // Compare via a cast to a thin pointer, so fat pointers are only\n        // considering their \"data\" part for null-ness.\n        let ptr = self as *const u8;\n        const_eval_select!(\n            @capture { ptr: *const u8 } -> bool:\n            // This use of `const_raw_ptr_comparison` has been explicitly blessed by t-lang.\n            if const #[rustc_allow_const_fn_unstable(const_raw_ptr_comparison)] {\n                match (ptr).guaranteed_eq(null_mut()) {\n                    Some(res) => res,\n                    // To remain maximally convervative, we stop execution when we don't\n                    // know whether the pointer is null or not.\n                    // We can *not* return `false` here, that would be unsound in `NonNull::new`!\n                    None => panic!(\"null-ness of this pointer cannot be determined in const context\"),\n                }\n            } else {\n                ptr.addr() == 0\n            }\n        )\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 195, name: \"std::ptr::const_ptr::<impl *const T>::is_null::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::is_null::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$7is_null7runtime17h7dfd407882faecc4E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 149, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::precondition_check",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned18precondition_check17h576dc75a826a2d0cE",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 153, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge17h347785d8fcffea35E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 154, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const T>::offset_from_unsigned::runtime_ptr_ge::runtime",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned14runtime_ptr_ge7runtime17h2d71e26de06a9244E",
          "kind": "Item",
          "file": "library/core/src/intrinsics/mod.rs",
          "src": "fn runtime$(<$($binders)*>)?($($arg: $ty),*) $( -> $ret )? {\n            $runtime\n        }",
          "before_expansion": "$crate::intrinsics::const_eval_select!(\n            @capture$([$($binders)*])? { $($arg : $ty = $val),* } $(-> $ret)? :\n            #[noinline]\n            if const\n                #[inline] // prevent codegen on this function\n                $(#[$compiletime_attr])*\n                $compiletime\n            else\n                #[inline] // avoid the overhead of an extra fn call\n                $(#[$runtime_attr])*\n                $runtime\n        )"
        }
      },
      {
        "def_id": "DefId { id: 269, name: \"std::ptr::const_ptr::<impl *const [T]>::as_ptr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::as_ptr",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$6as_ptr17h4407a3d2505e3182E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn as_ptr(self) -> *const T {\n        self as *const T\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 267, name: \"std::ptr::const_ptr::<impl *const [T]>::len\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [u8]>::len",
          "mangled_name": "_ZN4core3ptr9const_ptr43_$LT$impl$u20$$BP$const$u20$$u5b$T$u5d$$GT$3len17h77a9a38a2fb82cebE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn len(self) -> usize {\n        metadata(self)\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h3a596104eca7202bE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const [usize; 4]>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17h95babdad2d0fc1f3E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17h0a576779c2a5921cE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17h9d8ea600d403e2a7E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hea3399653658e906E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 148, name: \"std::ptr::const_ptr::<impl *const T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$20offset_from_unsigned17h7e1ae8494ab1b6a8E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_ptr_ge(this: *const (), origin: *const ()) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), origin: *const () } -> bool:\n                if const {\n                    true\n                } else {\n                    this >= origin\n                }\n            )\n        }\n\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::offset_from_unsigned requires `self >= origin`\",\n            (\n                this: *const () = self as *const (),\n                origin: *const () = origin as *const (),\n            ) => runtime_ptr_ge(this, origin)\n        );\n\n        let pointee_size = size_of::<T>();\n        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n        // SAFETY: the caller must uphold the safety contract for `ptr_offset_from_unsigned`.\n        unsafe { intrinsics::ptr_offset_from_unsigned(self, origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 198, name: \"std::ptr::const_ptr::<impl *const T>::add\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::add",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$3add17hcedf28e570bccab6E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 126, name: \"std::ptr::const_ptr::<impl *const T>::addr\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::addr",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4addr17hee8e32507ad62195E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub fn addr(self) -> usize {\n        // A pointer-to-integer transmute currently has exactly the right semantics: it returns the\n        // address without exposing the provenance. Note that this is *not* a stable guarantee about\n        // transmute semantics, it relies on sysroot crates having special status.\n        // SAFETY: Pointer-to-integer transmutes are valid (if you are okay with losing the\n        // provenance).\n        unsafe { mem::transmute(self.cast::<()>()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<()>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hb6d9630c236e0667E",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 156, name: \"std::ptr::const_ptr::<impl *const T>::cast\" }",
        "func": {
          "name": "std::ptr::const_ptr::<impl *const usize>::cast::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr9const_ptr33_$LT$impl$u20$$BP$const$u20$T$GT$4cast17hd7d033da755485feE",
          "kind": "Item",
          "file": "library/core/src/ptr/const_ptr.rs",
          "src": "pub const fn cast<U>(self) -> *const U {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<&u8>",
          "mangled_name": "_ZN4core3ptr27drop_in_place$LT$$RF$u8$GT$17hc860db9297e59a65E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::fmt::Alignment>",
          "mangled_name": "_ZN4core3ptr41drop_in_place$LT$core..fmt..Alignment$GT$17h7053c6d7e77848ceE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<std::option::Option<(usize, char)>>",
          "mangled_name": "_ZN4core3ptr69drop_in_place$LT$core..option..Option$LT$$LP$usize$C$char$RP$$GT$$GT$17hc4a9cf5ac18a109aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<usize>",
          "mangled_name": "_ZN4core3ptr26drop_in_place$LT$usize$GT$17hc9921d2585312b1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@<std::str::Chars<'_> as std::iter::Iterator>::next::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr136drop_in_place$LT$$LT$core..str..iter..Chars$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..next..$u7b$$u7b$closure$u7d$$u7d$$GT$17he2f3566df11993a9E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@std::iter::adapters::map::map_fold<&u8, usize, usize, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}, {closure@<usize as std::iter::Sum>::sum<std::iter::Map<std::slice::Iter<'_, u8>, {closure@<std::iter::Filter<I, P> as std::iter::Iterator>::count::to_usize<&u8, {closure@core::str::count::char_count_general_case::{closure#0}}>::{closure#0}}>>::{closure#0}}>::{closure#0}}>",
          "mangled_name": "_ZN4core3ptr772drop_in_place$LT$core..iter..adapters..map..map_fold$LT$$RF$u8$C$usize$C$usize$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$C$$LT$usize$u20$as$u20$core..iter..traits..accum..Sum$GT$..sum$LT$core..iter..adapters..map..Map$LT$core..slice..iter..Iter$LT$u8$GT$$C$$LT$core..iter..adapters..filter..Filter$LT$I$C$P$GT$$u20$as$u20$core..iter..traits..iterator..Iterator$GT$..count..to_usize$LT$$RF$u8$C$core..str..count..char_count_general_case..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$..$u7b$$u7b$closure$u7d$$u7d$$GT$17h6e7832b57095f296E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h07a46ae8aa7e8e25E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h12719edfe5decc4eE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h47876d82be15ca1aE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN4core3ptr106drop_in_place$LT$standard_proofs_with_contracts..verify..contract_ensures..$u7b$$u7b$closure$u7d$$u7d$$GT$17h7b125f91dbc5ce35E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17h17b5b31bf44d2b41E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17h4d53b215fb76b000E",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17hb7b2e8dda93db67eE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 54, name: \"std::ptr::drop_in_place\" }",
        "func": {
          "name": "std::ptr::drop_in_place::<{closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN4core3ptr107drop_in_place$LT$standard_proofs_with_contracts..verify..contract_requires..$u7b$$u7b$closure$u7d$$u7d$$GT$17hce6ba17a777dd83fE",
          "kind": "Shim",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub unsafe fn drop_in_place<T: ?Sized>(to_drop: *mut T)",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[[usize; 4]], [usize; 4]>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h366ed0a3a51d837eE",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[u8], u8>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17hcbff0ea135f8c822E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 196, name: \"std::ptr::from_raw_parts\" }",
        "func": {
          "name": "std::ptr::from_raw_parts::<[usize], usize>",
          "mangled_name": "_ZN4core3ptr8metadata14from_raw_parts17h41eed9c7257b5a92E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn from_raw_parts<T: ?Sized>(\n    data_pointer: *const impl Thin,\n    metadata: <T as Pointee>::Metadata,\n) -> *const T {\n    aggregate_raw_ptr(data_pointer, metadata)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 270, name: \"std::ptr::metadata\" }",
        "func": {
          "name": "std::ptr::metadata::<[u8]>",
          "mangled_name": "_ZN4core3ptr8metadata8metadata17h11e9b84f3b318493E",
          "kind": "Item",
          "file": "library/core/src/ptr/metadata.rs",
          "src": "pub const fn metadata<T: ?Sized>(ptr: *const T) -> <T as Pointee>::Metadata {\n    ptr_metadata(ptr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h9e0e2cfdf0904a7fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut [usize; 4]>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17hf944f5073ef59a74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17hce2dbc0a8530746fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h8a05fb28e37fbdd3E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 147, name: \"std::ptr::mut_ptr::<impl *mut T>::offset_from_unsigned\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut u8>::offset_from_unsigned",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$20offset_from_unsigned17he8e6f7cbdd8f5e6eE",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn offset_from_unsigned(self, origin: *const T) -> usize\n    where\n        T: Sized,\n    {\n        // SAFETY: the caller must uphold the safety contract for `sub_ptr`.\n        unsafe { (self as *const T).offset_from_unsigned(origin) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 161, name: \"std::ptr::mut_ptr::<impl *mut T>::add\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::add",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$3add17h058663281978a159E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const unsafe fn add(self, count: usize) -> Self\n    where\n        T: Sized,\n    {\n        #[cfg(debug_assertions)]\n        #[inline]\n        #[rustc_allow_const_fn_unstable(const_eval_select)]\n        const fn runtime_add_nowrap(this: *const (), count: usize, size: usize) -> bool {\n            const_eval_select!(\n                @capture { this: *const (), count: usize, size: usize } -> bool:\n                if const {\n                    true\n                } else {\n                    let Some(byte_offset) = count.checked_mul(size) else {\n                        return false;\n                    };\n                    let (_, overflow) = this.addr().overflowing_add(byte_offset);\n                    byte_offset <= (isize::MAX as usize) && !overflow\n                }\n            )\n        }\n\n        #[cfg(debug_assertions)] // Expensive, and doesn't catch much in the wild.\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"ptr::add requires that the address calculation does not overflow\",\n            (\n                this: *const () = self as *const (),\n                count: usize = count,\n                size: usize = size_of::<T>(),\n            ) => runtime_add_nowrap(this, count, size)\n        );\n\n        // SAFETY: the caller must uphold the safety contract for `offset`.\n        unsafe { intrinsics::offset(self, count) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 201, name: \"std::ptr::mut_ptr::<impl *mut T>::cast_const\" }",
        "func": {
          "name": "std::ptr::mut_ptr::<impl *mut usize>::cast_const",
          "mangled_name": "_ZN4core3ptr7mut_ptr31_$LT$impl$u20$$BP$mut$u20$T$GT$10cast_const17h950a6db1729acb74E",
          "kind": "Item",
          "file": "library/core/src/ptr/mut_ptr.rs",
          "src": "pub const fn cast_const(self) -> *const T {\n        self as _\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17hdf15e8368e89c131E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<u8>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h9b6c1ed71e4b6c54E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 186, name: \"std::ptr::slice_from_raw_parts\" }",
        "func": {
          "name": "std::ptr::slice_from_raw_parts::<usize>",
          "mangled_name": "_ZN4core3ptr20slice_from_raw_parts17h0392b72387600f22E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn slice_from_raw_parts<T>(data: *const T, len: usize) -> *const [T] {\n    from_raw_parts(data, len)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h6ba60a2281e8a542E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<u8>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h7b2fb807837541dbE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 160, name: \"std::ptr::without_provenance\" }",
        "func": {
          "name": "std::ptr::without_provenance::<usize>",
          "mangled_name": "_ZN4core3ptr18without_provenance17h953360cfbc2e7273E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance<T>(addr: usize) -> *const T {\n    without_provenance_mut(addr)\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<[usize; 4]>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17he0272cf1811aedffE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<u8>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17hc02bc4ce2e57232fE",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 162, name: \"std::ptr::without_provenance_mut\" }",
        "func": {
          "name": "std::ptr::without_provenance_mut::<usize>",
          "mangled_name": "_ZN4core3ptr22without_provenance_mut17h3353948db1931310E",
          "kind": "Item",
          "file": "library/core/src/ptr/mod.rs",
          "src": "pub const fn without_provenance_mut<T>(addr: usize) -> *mut T {\n    // An int-to-pointer transmute currently has exactly the intended semantics: it creates a\n    // pointer without provenance. Note that this is *not* a stable guarantee about transmute\n    // semantics, it relies on sysroot crates having special status.\n    // SAFETY: every valid integer is also a valid pointer (as long as you don't dereference that\n    // pointer).\n    unsafe { mem::transmute(addr) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 243, name: \"std::result::Result::<T, E>::is_ok\" }",
        "func": {
          "name": "std::result::Result::<char, std::char::CharTryFromError>::is_ok",
          "mangled_name": "_ZN4core6result19Result$LT$T$C$E$GT$5is_ok17h237867c19800b78bE",
          "kind": "Item",
          "file": "library/core/src/result.rs",
          "src": "pub const fn is_ok(&self) -> bool {\n        matches!(*self, Ok(_))\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 56, name: \"std::rt::panic_display\" }",
        "func": {
          "name": "std::rt::panic_display::<&str>",
          "mangled_name": "_ZN4core9panicking13panic_display17h9965c83dbdce9711E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_display<T: fmt::Display>(x: &T) -> ! {\n    panic_fmt(format_args!(\"{}\", *x));\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 59, name: \"std::rt::panic_fmt\" }",
        "func": {
          "name": "std::rt::panic_fmt",
          "mangled_name": "_ZN4core9panicking9panic_fmt17h8206d9c4fa94b0f1E",
          "kind": "Item",
          "file": "library/core/src/panicking.rs",
          "src": "pub const fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n    if cfg!(feature = \"panic_immediate_abort\") {\n        super::intrinsics::abort()\n    }\n\n    // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n    // that gets resolved to the `#[panic_handler]` function.\n    unsafe extern \"Rust\" {\n        #[lang = \"panic_impl\"]\n        fn panic_impl(pi: &PanicInfo<'_>) -> !;\n    }\n\n    let pi = PanicInfo::new(\n        &fmt,\n        Location::caller(),\n        /* can_unwind */ true,\n        /* force_no_backtrace */ false,\n    );\n\n    // SAFETY: `panic_impl` is defined in safe Rust code and thus is safe to call.\n    unsafe { panic_impl(&pi) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 204, name: \"std::slice::Chunks::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Chunks::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter15Chunks$LT$T$GT$3new17h61fc0016bb33d3a4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n        Self { v: slice, chunk_size: size }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, [usize; 4]>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h7e563fa4aafeccbeE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 217, name: \"std::slice::Iter::<'a, T>::as_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::as_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$8as_slice17h5dbeb8b275b939f1E",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub fn as_slice(&self) -> &'a [T] {\n        self.make_slice()\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 219, name: \"std::slice::Iter::<'a, T>::make_slice\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::make_slice",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$10make_slice17h65c3cdc1b15790e4E",
          "kind": "Item",
          "file": "library/core/src/slice/iter/macros.rs",
          "src": "fn make_slice(&self) -> &'a [T] {\n                // SAFETY: the iterator was created from a slice with pointer\n                // `self.ptr` and length `len!(self)`. This guarantees that all\n                // the prerequisites for `from_raw_parts` are fulfilled.\n                unsafe { from_raw_parts(self.ptr.as_ptr(), len!(self)) }\n            }",
          "before_expansion": "iterator! {struct Iter -> *const T, &'a T, const, {/* no mut */}, as_ref, {\n    fn is_sorted_by<F>(self, mut compare: F) -> bool\n    where\n        Self: Sized,\n        F: FnMut(&Self::Item, &Self::Item) -> bool,\n    {\n        self.as_slice().is_sorted_by(|a, b| compare(&a, &b))\n    }\n}}"
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, u8>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17h9fd511ca042ff46dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 158, name: \"std::slice::Iter::<'a, T>::new\" }",
        "func": {
          "name": "std::slice::Iter::<'_, usize>::new",
          "mangled_name": "_ZN4core5slice4iter13Iter$LT$T$GT$3new17hf5d3176cdb446f8dE",
          "kind": "Item",
          "file": "library/core/src/slice/iter.rs",
          "src": "pub(super) fn new(slice: &'a [T]) -> Self {\n        let len = slice.len();\n        let ptr: NonNull<T> = NonNull::from(slice).cast();\n        // SAFETY: Similar to `IterMut::new`.\n        unsafe {\n            let end_or_len =\n                if T::IS_ZST { without_provenance(len) } else { ptr.as_ptr().add(len) };\n\n            Self { ptr, end_or_len, _marker: PhantomData }\n        }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, [usize; 4]>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb0c08e21a67d8321E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, u8>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17h20fd2a93730b1004E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 183, name: \"std::slice::from_raw_parts\" }",
        "func": {
          "name": "std::slice::from_raw_parts::<'_, usize>",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts17hb415c774c30ce8d9E",
          "kind": "Item",
          "file": "library/core/src/slice/raw.rs",
          "src": "pub const unsafe fn from_raw_parts<'a, T>(data: *const T, len: usize) -> &'a [T] {\n    // SAFETY: the caller must uphold the safety contract for `from_raw_parts`.\n    unsafe {\n        ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        );\n        &*ptr::slice_from_raw_parts(data, len)\n    }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 185, name: \"std::slice::from_raw_parts::precondition_check\" }",
        "func": {
          "name": "std::slice::from_raw_parts::precondition_check",
          "mangled_name": "_ZN4core5slice3raw14from_raw_parts18precondition_check17hf1448faea35264c6E",
          "kind": "Item",
          "file": "library/core/src/ub_checks.rs",
          "src": "const fn precondition_check($($name:$ty),*) {\n                if !$e {\n                    ::core::panicking::panic_nounwind(concat!(\"unsafe precondition(s) violated: \", $message,\n                        \"\\n\\nThis indicates a bug in the program. \\\n                        This Undefined Behavior check is optional, and cannot be relied on for safety.\"));\n                }\n            }",
          "before_expansion": "ub_checks::assert_unsafe_precondition!(\n            check_language_ub,\n            \"slice::from_raw_parts requires the pointer to be aligned and non-null, and the total size of the slice not to exceed `isize::MAX`\",\n            (\n                data: *mut () = data as *mut (),\n                size: usize = size_of::<T>(),\n                align: usize = align_of::<T>(),\n                len: usize = len,\n            ) =>\n            ub_checks::maybe_is_aligned_and_not_null(data, align, false)\n                && ub_checks::is_valid_allocation_size(size, len)\n        )"
        }
      },
      {
        "def_id": "DefId { id: 85, name: \"std::str::CharIndices::<'a>::offset\" }",
        "func": {
          "name": "std::str::CharIndices::<'_>::offset",
          "mangled_name": "_ZN4core3str4iter11CharIndices6offset17h55d0a25e76f5da95E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn offset(&self) -> usize {\n        self.front_offset\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 100, name: \"std::str::Chars::<'a>::as_str\" }",
        "func": {
          "name": "std::str::Chars::<'_>::as_str",
          "mangled_name": "_ZN4core3str4iter5Chars6as_str17hf072d8c9a8bc6de2E",
          "kind": "Item",
          "file": "library/core/src/str/iter.rs",
          "src": "pub fn as_str(&self) -> &'a str {\n        // SAFETY: `Chars` is only made from a str, which guarantees the iter is valid UTF-8.\n        unsafe { from_utf8_unchecked(self.iter.as_slice()) }\n    }",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 218, name: \"std::str::from_utf8_unchecked\" }",
        "func": {
          "name": "std::str::from_utf8_unchecked",
          "mangled_name": "_ZN4core3str8converts19from_utf8_unchecked17hd68ebd84e1b684d4E",
          "kind": "Item",
          "file": "library/core/src/str/converts.rs",
          "src": "pub const unsafe fn from_utf8_unchecked(v: &[u8]) -> &str {\n    // SAFETY: the caller must guarantee that the bytes `v` are valid UTF-8.\n    // Also relies on `&str` and `&[u8]` having the same layout.\n    unsafe { mem::transmute(v) }\n}",
          "before_expansion": null
        }
      },
      {
        "def_id": "DefId { id: 14, name: \"verify::contract_ensures\" }",
        "func": {
          "name": "verify::contract_ensures",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures17h79653182b146dd52E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 16, name: \"verify::contract_ensures::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract_ensures::kani_contract_mode",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures18kani_contract_mode17hf84fd0bf7e84f561E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17h16b586d379912749E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17h231f8ea1cc3c8c63E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17hacc71d9312a7ae0aE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 15, name: \"verify::contract_ensures::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_ensures::kani_register_contract::<u8, {closure@tests/proofs/standard_proofs_with_contracts.rs:11:5: 11:37}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify16contract_ensures22kani_register_contract17hbb6ad307037018a6E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::ensures(|&ret| ret > 0)]",
          "before_expansion": "#[kani::ensures(|&ret| ret > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 0, name: \"verify::contract_requires\" }",
        "func": {
          "name": "verify::contract_requires",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires17h8ea4e103f55510c3E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 2, name: \"verify::contract_requires::kani_contract_mode\" }",
        "func": {
          "name": "verify::contract_requires::kani_contract_mode",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires18kani_contract_mode17h095815dd71e1bf74E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17h35512546ce26d64aE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17h7cd3005d1148b7d7E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17hacdf4063781e55ccE",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      },
      {
        "def_id": "DefId { id: 1, name: \"verify::contract_requires::kani_register_contract\" }",
        "func": {
          "name": "verify::contract_requires::kani_register_contract::<(), {closure@tests/proofs/standard_proofs_with_contracts.rs:3:5: 3:29}>",
          "mangled_name": "_ZN30standard_proofs_with_contracts6verify17contract_requires22kani_register_contract17hbf238611e5467868E",
          "kind": "Item",
          "file": "tests/proofs/standard_proofs_with_contracts.rs",
          "src": "#[kani::requires(a > 0)]",
          "before_expansion": "#[kani::requires(a > 0)]"
        }
      }
    ]
  }
]